<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个Rust生命周期问题</title>
    <link href="/2020/12/17/a-lifetime-problem/"/>
    <url>/2020/12/17/a-lifetime-problem/</url>
    
    <content type="html"><![CDATA[<p>给知乎上一个生命周期问题提供的解决办法</p><a id="more"></a><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p><a href="https://zhuanlan.zhihu.com/p/104742696">一个关于rust生命周期的问题分析 - 知乎 (zhihu.com)</a></p><p>相关的 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f1ffcb16c412679feeaa5fe594052ed">Rust Playground (rust-lang.org)</a></p><p>场景目标是，有一个已经存在的 <code>&amp;[u8]</code> buffer，一个<code>Parser</code>结构的<code>parse</code>方法希望查阅这个buffer，同时修改自身的状态，以自身状态为基础产生一个新的<code>&amp;[u8]</code> buffer，返回这个新引用。 <code>parse</code> 方法可以多次调用，所以希望在<code>Parser</code>结构的基础上制作一个迭代器，每次迭代执行<code>parse</code>，返回构建的 <code>u8</code> buffer</p><p>由此有以下代码：<br><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Parser</span></span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> Parser &#123;<br>       <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>&gt; &#123;<br>           todo!()<br>       &#125;<br>    <br>       <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>]) -&gt; ParseIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>           ParseIter &#123; parser: <span class="hljs-keyword">self</span>, buf &#125;<br>       &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParseIter</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    parser: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Parser,<br>    buf: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>],<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> ParseIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; &#123;<br>        <span class="hljs-keyword">self</span>.parser.parse(<span class="hljs-keyword">self</span>.buf)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>但是甚至不待使用<code>ParseIter&lt;&#39;a&gt;</code>，就会因为生命周期问题产生编译错误。<br>个人感觉错误本身对修改的指导意义不大，就不贴在这里了，有需要可以看原文。</p><blockquote><p>评论中提出，去掉<code>parser</code>中<code>self</code>的生命周期标记，变成<br><code>fn parse&lt;&#39;a&gt;(&amp;mut self, buf: &amp;&#39;a [u8]) -&gt; Option&lt;&amp;&#39;a u8&gt;</code><br>这的确可以通过编译，但是这表明的是作为返回值的引用和<code>Parser</code>本身无关，并没有基于它的任何字段。显然这和设计的目标不一致。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在不实现<code>ParseIter&lt;&#39;a&gt;</code>的<code>next</code>时，程序可以编译，所以从<code>next</code>的实现着手分析，看他破坏了什么东西。将实现做如下展开：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>&lt;<span class="hljs-symbol">&#x27;iter</span>&gt;(&amp;<span class="hljs-symbol">&#x27;iter</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> parser: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Parser = &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.parser;<br>    <span class="hljs-keyword">let</span> buf: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>] = <span class="hljs-keyword">self</span>.buf;<br>    <span class="hljs-keyword">return</span> Parser::parse(parser, buf);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>buf的引用可以直接通过Copy复制，所以可以得到<code>&amp;&#39;a [u8]</code>。</p><p>但是<code>parser</code>属于可变引用，不能Copy，只能通过<code>Deref</code>再重新取引用，如原文作者所说，实际发生的是</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>&lt;<span class="hljs-symbol">&#x27;iter</span>&gt;(&amp;<span class="hljs-symbol">&#x27;iter</span> <span class="hljs-keyword">mut</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Parser) -&gt; &amp;<span class="hljs-symbol">&#x27;iter</span> <span class="hljs-keyword">mut</span> Self::Target;<br></code></pre></div></td></tr></table></figure><p>返回的引用需要受限于<code>&#39;iter</code>生命周期，但是这里并没有<code>&#39;iter: &#39;a</code>关系，所以不能保证parser的存活范围，换言之，万一<code>&#39;iter</code>更小，从中借出一个生命周期更长的引用显然不可能。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原文作者并没有给出解决方法。这里给出一个大佬 <a href="https://github.com/BurntSushi">BurntSushi</a> 在 fst 库中给出的方案：<a href="https://docs.rs/fst/0.4.5/fst/trait.Streamer.html">Streamer</a>。</p><p>在上节分析的最后，我们发现缺少<code>&#39;iter: &#39;a</code>的保证，如果想加上，就会发想<code>Iterator</code>这个trait阻止你这么做了。Iterator的本意，是希望迭代出的元素的生命周期和自身无关，可以被外界同时持有多个，甚至迭代器被drop也没有关系。但是上述场景不是这样的，每次迭代返回的引用，不可能被同时持有，因为受限制于<code>Parser</code>本身的状态，自然也就和持有<code>&amp;mut Parser</code>引用的<code>ParserIter</code>有关了。因此我们可以说，针对这个场景，<code>Iterator</code>这个trait选错了。</p><p>fst中的迭代也是类似的场景，所以制作了一个<code>Streamer</code>的trait。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Streamer</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>: <span class="hljs-symbol">&#x27;a</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>形式上和<code>Iterator</code>很像，区别在于对迭代器本身和返回值多了<code>&#39;a</code>生命周期绑定，表明返回值的生命周期不能超过迭代器本身。因此迭代的元素不可以被同时持有，要么阅后即焚，要么及时复制，所以得名<code>Stream-流</code></p><p>如果实现<code>Streamer&lt;&#39;a&gt;</code>，整个的生命周期会按照最短的迭代器的声明周期进行对齐，比如<code>buf</code>的长生命周期在编译时缩短(协变)，以配合<code>Parser::iter</code>方法。成功通过编译，cool</p><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>下面是Streamer文档的后续翻译，作为补充</p><p>“””</p><p>但是本身这个结构非常难用，会涉及到高阶生命周期绑定。在一个函数中使用该trait，<code>Streamer</code>的生命周期和使用函数没有任何关联，必须用一种方法表示<code>Streamer&lt;&#39;a&gt;</code>的<code>&#39;a</code>可以对任意生命周期有效，不必受制于函数的调用作用域。大概长这样</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_stream</span></span>&lt;T, S&gt;(s: S)<br>    <span class="hljs-keyword">where</span> S: <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Streamer&lt;<span class="hljs-symbol">&#x27;a</span>, Item=T&gt;<br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>但是这个声明有 <strong>三个</strong> 问题：</p><ol><li><code>S</code> 没有绑定特定生命周期，实际上大多数 stream 都包含者一个底层状态机的引用，才能迭代访问Fst</li><li>区分 “stream” 和 “stream 构建器” 的概念，往往会给我们带来方便。在标准库中，这对应这 <code>Iterator</code> 和 <code>IntoIterator</code></li><li><code>Item=T</code> 是非法的，因为 <code>Streamer</code> 的关联类型要求绑定一个生命周期参数，但是我们没有办法给任意的类型构建器标记一个生命周期绑定。（当前的情况里，<code>T</code>就是一个类型构建器，因为它始终需要一个生命周期才能成为一个具体的类型）</li></ol><p>因此，我们需要重新写成这样的庞然大物</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_stream</span></span>&lt;<span class="hljs-symbol">&#x27;f</span>, I, S&gt;(s: I)<br>    <span class="hljs-keyword">where</span> I: <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; IntoStreamer&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-built_in">Into</span>=S, Item=(&amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>], Output)&gt;,<br>          S: <span class="hljs-symbol">&#x27;f</span> + <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Streamer&lt;<span class="hljs-symbol">&#x27;a</span>, Item=(&amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>], Output)&gt;<br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>我们是这样解决问题的：</p><ol><li><code>S</code>现在绑定<code>&#39;f</code>，表示底层stream的生命周期，可能是<code>&#39;static</code></li><li>类型参数<code>I</code>加入，表示一个知道如何构建 stream 的类型。注意<code>I</code> 和 <code>S</code>并没有共享相同的生命周期，因为高阶生命周期绑定的<code>’a</code>表示任意的生命周期。</li><li><code>T</code> 被替换成了一个具体类型。注意到具体类型在 <code>I</code> 和 <code>S</code> 中是重复的。在 <code>Iterator</code> 和 <code>IntoIterator</code> 中，<code>I</code>可以通过<code>S::Item</code>简写，但是在高阶生命周期绑定中，我们不能访问关联类型。</li></ol><p>如你所见，stream 的灵活零欠缺，一丢丢反人类，给了一大堆难以阅读的trait绑定。情况就是这么尴尬，但是没有它，我们又不能组合各种数据流。</p><p>唯一的慰藉可能是，完全相同的 trait bound 可以到处用。一旦你领会了精神，剩下的可能就是复制粘贴。</p><p>“””</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><code>Iterator</code>并不是万能的，需要了解它的使用场景和局限</li><li>编译错误可能并不能指导修改，程序的语义需要自己把握</li><li>单是函数的签名就能反应出整个工作流程，很神奇</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用递归下降和Pratt方法求值算术表达式</title>
    <link href="/2020/12/16/eval-expr/"/>
    <url>/2020/12/16/eval-expr/</url>
    
    <content type="html"><![CDATA[<p>复习向，<a href="https://craftinginterpreters.com/contents.html"><em>Crafting Interpreters</em></a> 中介绍的两种方法</p><a id="more"></a><h2 id="表达式定义"><a href="#表达式定义" class="headerlink" title="表达式定义"></a>表达式定义</h2><p>简单起见，算数表达式只包含以下元素：</p><ul><li>整数</li><li>括号</li><li>一元运算符：<code>-</code></li><li>二元运算符：<code>+ - * /</code></li></ul><p>比如<code>-1 + 2*(1 + 3 - 2)</code></p><h2 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h2><p>第一步将输入表达式分成小单位的token，因为表达式内容较少，只用产出如下组件：</p><ul><li>整数</li><li><code>(</code></li><li><code>)</code></li><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li><code>/</code></li></ul><p>表达式<code>-112 + 2*(1 + 3 - 42)</code> 产出的token序列为<code>-, 112, +, 2, *, (, 1, +, 3, -, 42, ), None</code></p><p>此外增加peek功能，方便后续解析，Lexer如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lexer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, expr: <span class="hljs-built_in">str</span></span>):</span><br>        self.expr_str = expr<br>        self.peeked = <span class="hljs-literal">None</span><br>        self.tokens = self.tokens_iter()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tokens_iter</span>(<span class="hljs-params">self</span>):</span><br>        num = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> self.expr_str:<br>            <span class="hljs-keyword">if</span> ch.isdigit():<br>                <span class="hljs-keyword">if</span> num:<br>                    num = <span class="hljs-number">10</span> * num + <span class="hljs-built_in">int</span>(ch)<br>                <span class="hljs-keyword">else</span>:<br>                    num = <span class="hljs-built_in">int</span>(ch)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> num <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                    <br>                    <span class="hljs-keyword">yield</span> num <span class="hljs-comment"># yield an int</span><br>                    num = <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">if</span> ch != <span class="hljs-string">&#x27; &#x27;</span>:                    <br>                    <span class="hljs-keyword">yield</span> ch <span class="hljs-comment"># yield an operation</span><br>        <span class="hljs-keyword">if</span> num:<br>            <span class="hljs-keyword">yield</span> num<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;consume next token and return it</span><br><span class="hljs-string">        None means end of the token stream</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.peeked <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            ret = self.peeked<br>            self.peeked = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">try</span>:<br>                ret = <span class="hljs-built_in">next</span>(self.tokens)<br>            <span class="hljs-keyword">except</span> StopIteration:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> ret<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;peek the next token without consuming it </span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.peeked <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.peeked = self.<span class="hljs-built_in">next</span>()<br>        <span class="hljs-keyword">return</span> self.peeked<br><br></code></pre></div></td></tr></table></figure><h2 id="EvalBase"><a href="#EvalBase" class="headerlink" title="EvalBase"></a>EvalBase</h2><p>写一个求值的基类，把Lexer组合进去，复用一点代码</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Eval</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, expr: <span class="hljs-built_in">str</span></span>):</span><br>        self.lexer = Lexer(expr)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.lexer.<span class="hljs-built_in">next</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.lexer.peek()<br></code></pre></div></td></tr></table></figure><h2 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h2><ul><li><p>编程领域的语言都有明确的生成规则，算术表达式的生成规则如下：</p><ol><li><code>expr: factor ( (&#39;+&#39; | &#39;-&#39;) factor )*</code></li><li><code>factor: unary ( (&#39;*&#39; | &#39;/&#39;) unary)*</code></li><li><code>unary: &#39;-&#39;? unary | primary</code></li><li><code>primary: num | &#39;(&#39; expr &#39;)&#39;</code></li></ol></li><li><p>从上往下，计算的优先级依次升高，问题的求解规模减少，直到遇到计算数据的基本单位，一个整形<code>num</code>。</p></li><li>所谓递归下降，就把每个生成规则都做成一个函数，调用更规模更小的子问题，子问题的优先级一般会更高，如果同级，就表示右结合的运算，比如一元运算符<code>-</code>。</li><li>易错点是写出无限循环，自己调用自己，问题规模没有减小，就是常说的直接、间接左递归</li><li>每一个函数完整控制着表达式中的一个计算单元，可以利用他们的返回值进行运算。</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Descent</span>(<span class="hljs-params">Eval</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">primary</span>(<span class="hljs-params">self</span>):</span><br>        token = self.<span class="hljs-built_in">next</span>()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(token, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">return</span> token<br>        <span class="hljs-keyword">elif</span> token == <span class="hljs-string">&#x27;(&#x27;</span>:<br>            ret = self.expr()<br>            <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;)&#x27;</span> == self.<span class="hljs-built_in">next</span>(), <span class="hljs-string">&#x27;unbalanced parentheses&#x27;</span><br>            <span class="hljs-keyword">return</span> ret<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;unrecognized token <span class="hljs-subst">&#123;token!r&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary</span>(<span class="hljs-params">self</span>):</span><br>        token = self.peek()<br>        <span class="hljs-keyword">if</span> token == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            self.<span class="hljs-built_in">next</span>()<br>            <span class="hljs-keyword">return</span> - self.unary()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> self.primary()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factor</span>(<span class="hljs-params">self</span>):</span><br>        left = self.unary()<br>        <span class="hljs-keyword">while</span> self.peek() <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>):<br>            op = self.<span class="hljs-built_in">next</span>()<br>            <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                left *= self.unary()<br>            <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;/&#x27;</span>:<br>                left //= self.unary()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;unrecognized operator <span class="hljs-subst">&#123;op!r&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> left<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expr</span>(<span class="hljs-params">self</span>):</span><br>        left = self.factor()<br>        <span class="hljs-keyword">while</span> self.peek() <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>):<br>            op = self.<span class="hljs-built_in">next</span>()<br>            <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                left += self.factor()<br>            <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                left -= self.factor()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;unrecognized operator <span class="hljs-subst">&#123;op!r&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> left<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eval</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.expr()<br></code></pre></div></td></tr></table></figure><h2 id="Pratt方法"><a href="#Pratt方法" class="headerlink" title="Pratt方法"></a>Pratt方法</h2><ul><li>每一次表达式解析，都是将一个表达式看作 <code>一个前缀表达式 (若干中缀表达式)*</code>进行收集，求值后入栈，该次收集的表达式所涉及的操作数的优先级，一定不高于参数所给定的优先级。比如<code>1 + 2 + 3</code>解析，参数为最低优先级：前缀表达式<code>1</code>，中缀表达式<code>+ 2</code>，中缀表达式<code>+ 3</code>。两个中缀表达式去掉操作符后，再递归调用表达式解析，各自通过两个前缀表达式得到 <code>2</code> 和 <code>3</code>。</li><li><p>收集函数根据token进行查找确定。同样的<code>-</code>，可以分发到作为前缀的<code>unary</code>，也可以分发到作为中缀的<code>bianry</code>，视上下文而定。</p></li><li><p>中缀表达式的停止，用操作符的优先级来进行，比如<code>1 + 2 + 3</code>中，<code>+</code> 操作符分发的<code>binary</code>开启的新一轮表达式收集，只能包含比自己更高的操作符，比如<code>* /</code>，看到<code>2</code>后面的<code>+</code>号和自己同级，于是停止，形成一个左结合的操作。</p></li><li>需要一个最低的优先级<code>Null</code>，可以停止一切中缀表达式的匹配。</li><li>和递归下降的模拟生成规则的函数不同，Pratt中的分发函数属于收集函数，只会根据优先级收集计算单元的某部分，没有完整信息，所以需要使用栈记录信息并求值。</li></ul><p>代码方面，首先记录运算符的优先级，而递归下降中的类似</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prec</span>(<span class="hljs-params">Enum</span>):</span> <span class="hljs-comment"># precedence</span><br>    Null = auto()<br>    Term = auto()     <span class="hljs-comment"># &#x27;+ -&#x27; </span><br>    Factor = auto()   <span class="hljs-comment"># &#x27;* /&#x27;</span><br>    Unary = auto()    <span class="hljs-comment"># &#x27;-&#x27;</span><br>    Primary = auto()  <span class="hljs-comment"># num &#x27;(&#x27; expr &#x27;)&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;return the next level precedence</span><br><span class="hljs-string">        Prec.Primary will return itself&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> Prec(<span class="hljs-built_in">min</span>(self.value + <span class="hljs-number">1</span>, self.Primary.value))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__le__</span>(<span class="hljs-params">self, other: <span class="hljs-string">&#x27;Prec&#x27;</span></span>):</span><br>        <span class="hljs-keyword">return</span> self.value &lt;= other.value<br></code></pre></div></td></tr></table></figure><p>新建一个Pratt类，主要构建出根据token进行分发的函数表格。</p><ul><li>加入Prec信息和<code>prec_of</code>，是因为合并了一些逻辑，比如<code>binary</code>的参数token可能横跨两个优先级，需要识别出以继续收集。事实上，如果没有合并，每个收集函数，对自己该继续收集什么层级的表达式，都是清楚的，比如之后会看到的unary直接调用<code>parse_with(Prec::Unary)</code>，这也是<code>-</code>在表中只记录它在<code>binary</code>中的优先级的原因。</li><li>默认返回的优先级是<code>Null</code>，所以最后的中止token为None，可以用来跳出所有中缀表达式的调用，结束解析</li><li>stack用来求值</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatchEntry</span>:</span><br>    prefix: MethodWrapperType = <span class="hljs-literal">None</span><br>    infix: MethodWrapperType = <span class="hljs-literal">None</span><br>    prec: Prec = Prec.Null<br><br><br>EmptyEntry = DispatchEntry()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pratt</span>(<span class="hljs-params">Eval</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, expr: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(expr)<br>        self.stack = []<br>        self.index_map = &#123;<br>            <span class="hljs-string">&#x27;num&#x27;</span>: DispatchEntry(self.num, <span class="hljs-literal">None</span>, Prec.Null),<br>            <span class="hljs-string">&#x27;+&#x27;</span>: DispatchEntry(<span class="hljs-literal">None</span>, self.binary, Prec.Term),<br>            <span class="hljs-string">&#x27;-&#x27;</span>: DispatchEntry(self.unary, self.binary, Prec.Term),<br>            <span class="hljs-string">&#x27;*&#x27;</span>: DispatchEntry(<span class="hljs-literal">None</span>, self.binary, Prec.Factor),<br>            <span class="hljs-string">&#x27;/&#x27;</span>: DispatchEntry(<span class="hljs-literal">None</span>, self.binary, Prec.Factor),<br>            <span class="hljs-string">&#x27;(&#x27;</span>: DispatchEntry(self.group, <span class="hljs-literal">None</span>, Prec.Null)<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch_entry</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">if</span> token <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(token, <span class="hljs-built_in">int</span>):<br>            token = <span class="hljs-string">&#x27;num&#x27;</span><br>        <span class="hljs-keyword">return</span> self.index_map.get(token, EmptyEntry)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prefix_fn_call</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">if</span> fn := self.fetch_entry(token).prefix:<br>            <span class="hljs-keyword">return</span> fn(token)<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;unkown token to dispatch prefix: <span class="hljs-subst">&#123;token!r&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">infix_fn_call</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">if</span> fn := self.fetch_entry(token).infix:<br>            <span class="hljs-keyword">return</span> fn(token)<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;unkown token to dispatch infix: <span class="hljs-subst">&#123;token!r&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prec_of</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">return</span> self.fetch_entry(token).prec<br></code></pre></div></td></tr></table></figure><p>然后加入被分配的收集函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># in class Pratt</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_with</span>(<span class="hljs-params">self, prec: Prec</span>):</span><br>        token = self.<span class="hljs-built_in">next</span>()<br>        self.prefix_fn_call(token)<br>        <span class="hljs-keyword">while</span> prec &lt;= self.prec_of(self.peek()):<br>            token = self.<span class="hljs-built_in">next</span>()<br>            self.infix_fn_call(token)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">str</span></span>):</span><br>        self.parse_with(Prec.Unary)<br>        <span class="hljs-keyword">if</span> token == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            self.stack[-<span class="hljs-number">1</span>] = -self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary</span>(<span class="hljs-params">self, token</span>):</span><br>        self.parse_with(self.prec_of(token).<span class="hljs-built_in">next</span>())<br>        right = self.stack.pop()<br>        left = self.stack.pop()<br>        <span class="hljs-keyword">if</span> token == <span class="hljs-string">&#x27;+&#x27;</span>:<br>            self.stack.append(left + right)<br>        <span class="hljs-keyword">elif</span> token == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            self.stack.append(left - right)<br>        <span class="hljs-keyword">elif</span> token == <span class="hljs-string">&#x27;*&#x27;</span>:<br>            self.stack.append(left * right)<br>        <span class="hljs-keyword">elif</span> token == <span class="hljs-string">&#x27;/&#x27;</span>:<br>            self.stack.append(left // right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group</span>(<span class="hljs-params">self, token</span>):</span><br>        self.expr()<br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;)&#x27;</span> == self.<span class="hljs-built_in">next</span>(), <span class="hljs-string">&#x27;unbalanced parentheses&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num</span>(<span class="hljs-params">self, token: <span class="hljs-built_in">int</span></span>):</span><br>        self.stack.append(token)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expr</span>(<span class="hljs-params">self</span>):</span><br>        self.parse_with(Prec.Null.<span class="hljs-built_in">next</span>())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eval</span>(<span class="hljs-params">self</span>):</span><br>        self.expr()<br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><p>画了一个调用栈来表示解析过程，<code>paser_with</code>都用主色表示，它所引发的prefix调用都用浅色表示，所引发的infix调用使用深色。</p><p><img src="https://s3.ax1x.com/2020/12/16/rQbV0J.png" alt="pratt-call-stack"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>递归下降中的规则从上往下，优先级上升，问题规模下降</li><li>Pratt方法的核心是<code>parse_with(prec :Prec) &#123; 前缀表达式 (中缀表达式)*&#125;</code>将下一个表示式的值入栈，该值的求解过程中使用的操作数，都大于等于prec优先级</li><li>Pratt中的<code>prec_of</code>出现是因为收集函数的逻辑合并</li><li>Pratt方法中的最小逻辑用来跳出中缀匹配</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust生命周期误解翻译</title>
    <link href="/2020/12/15/lifetime-misconceptions/"/>
    <url>/2020/12/15/lifetime-misconceptions/</url>
    
    <content type="html"><![CDATA[<p>生命周期误解的意译版 + 个人批注</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">原文链接</a></li><li>为什么要翻译：强制放慢阅读速度，加深对内容的理解；分享自己的一些理解和总结</li><li>如何翻译的：主要是意译，有意将长句子拆开，便于阅读，同时加入了一些承上启下的句子，补充更容易理解的行文逻辑。另外还添加了一些结论性的注释，论据主要来自于<a href="https://doc.rust-lang.org/nomicon/ownership.html">Ownership - The Rustonomicon</a>，作为不同视角的参考。</li><li>应该如何阅读：<strong>时刻参照原文</strong>。根据我读译文的经验，不能过分相信翻译者！当读起来不顺畅，有异样感觉时，就看原文吧，可能找到导向更好理解的线索。</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文所列出的对生命周期的误解，我过去都经历过，而如今，我发现很多初学者依然身陷其中。</p><p>可能我所用的术语并不标准，因此列出下表，阐明我将使用的词语，以及对应的含义</p><table><thead><tr><th>短语</th><th>含义</th></tr></thead><tbody><tr><td>T</td><td>1. 一个集合，包含所有可能的类型<br>2. 在该集合中的某个类型</td></tr><tr><td>所有权类型</td><td>非引用的类型，比如<code>i32</code>,<code>String</code>,<code>Vec</code>等</td></tr><tr><td>1. 借用类型 或者<br>2. 引用类型</td><td>无关可变性的引用类型，比如<code>&amp;i32</code>, <code>&amp;mut i32</code>等</td></tr><tr><td>1. 可变引用(借用) 或者<br>2. 排它引用(借用)</td><td>具有排它性、唯一性的可变引用，比如<code>&amp;mut T</code></td></tr><tr><td>1. 不可变引用 或者<br>2. 共享引用</td><td>共享的不可变引用，比如<code>&amp;T</code></td></tr></tbody></table><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>概括一下，一个变量的生命周期是指，变量所指向的内存数据，在其当前内存地址上可以保持多长的有效性，该有效性由编译器静态验证。</p><blockquote><p><strong>Rutonomicon定义</strong>：Lifetimes are named regions of code that a reference must be valid for. 有名称的代码作用域，在作用域中引用必须保证有效 </p></blockquote><h3 id="1-T只包含所有权类型"><a href="#1-T只包含所有权类型" class="headerlink" title="1) T只包含所有权类型"></a>1) <code>T</code>只包含所有权类型</h3><p>相比生命周期，泛型可能是更适合这个误解的主题。但在Rust世界中，泛型和生命周期关联十分紧密，几乎不能单独谈论。</p><p>当我开始学习Rust时，我能够理解 <code>i32</code>, <code>&amp;i32</code>, 和<code>&amp;mut i32</code> 属于不同的类型，同时我也理解，泛型<code>T</code>代表着一个类型集合。尽管分开理解没有障碍，但放在一起时就有了问题。在早期，我对Rust泛型的理解是这样的：</p><table><thead><tr><th><strong>Type Variable</strong></th><th><code>T</code></th><th><code>&amp;T</code></th><th><code>&amp;mut T</code></th></tr></thead><tbody><tr><td><strong>Examples</strong></td><td><code>i32</code>，<code>Vec&lt;T&gt;</code></td><td><code>&amp;i32</code>，<code>&amp;Vec&lt;T&gt;</code></td><td><code>&amp;mut i32</code>, <code>&amp;mut Vec&lt;T&gt;</code></td></tr></tbody></table><p><code>T</code>是所有权类型集合，<code>&amp;T</code>是不可变借用集合，<code>&amp;mut T</code>则是可变借用集合， <code>T</code>, <code>&amp;T</code>, <code>&amp;mut T</code> 是三个不相交的有限集合。简洁，清晰，容易，符合直觉，但是，完全错了。实际情况是这样的</p><table><thead><tr><th><strong>Type Variable</strong></th><th><code>T</code></th><th><code>&amp;T</code></th><th><code>&amp;mut T</code></th></tr></thead><tbody><tr><td><strong>Examples</strong></td><td><code>i32</code>, <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code>, …</td><td><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code>, …</td><td><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code>,</td></tr></tbody></table><p> <code>T</code>, <code>&amp;T</code>, <code>&amp;mut T</code> 都是无限集合，因为你可以对一个类型一直借用，无限套娃。<code>T</code>是<code>&amp;T</code>和<code>&amp;mut</code>的超集，而<code>&amp;T</code>和<code>&amp;mut T</code>确实是不相交的。</p><p>下面是几个解释相关概念的样例：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> T &#123;&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br></code></pre></div></td></tr></table></figure><p>编译器并不会允许我们为<code>&amp;T</code>和<code>&amp;mut T</code>实现<code>Trait</code>，因为和为<code>T</code>实现的<code>Trait</code>冲突了，正如之前所说，<code>T</code>包含所有的<code>&amp;T</code>和<code>&amp;mut T</code>。而如下的程序则可以编译，因为<code>&amp;T</code>和<code>&amp;mut T</code>不相交。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li><code>T</code>是<code>&amp;T</code>和<code>&amp;mut</code>的超集</li><li><code>&amp;T</code>和<code>&amp;mut T</code>不相交</li></ul><h3 id="2-T-39-static表示T必须对整个程序有效"><a href="#2-T-39-static表示T必须对整个程序有效" class="headerlink" title="2) T: &#39;static表示T必须对整个程序有效"></a>2) <code>T: &#39;static</code>表示<code>T</code>必须对整个程序有效</h3><p>该误解的推论：</p><ul><li><code>T: &#39;static</code> 读作 “<code>T</code> 拥有 <code>&#39;static</code> 生命周期”</li><li><code>&amp;&#39;static T</code> 和<code>T: &#39;static</code> 没有区别</li><li><code>T: &#39;static</code> 表示 <code>T</code> 不可修改</li><li><code>T: &#39;static</code> 表示 <code>T</code> 只能在编译期被创建</li></ul><p>大部分的Rust初学者，第一次看到<code>&#39;static</code>恐怕是在这样的代码中：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> str_literal: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;str literal&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>他们感觉到，<code>&quot;str literal&quot;</code>被硬编码到编译后的二进制文件中，在运行时被载入内存，所以它不可变，并且在整个程序范围内有效，因此被标记为<code>&#39;static</code>。当他们发现还可以使用<code>static</code>关键字声明静态变量时，这种理解被进一步地加强了。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> BYTES: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> MUT_BYTES: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>; <span class="hljs-comment">// 编译错误，修改static变量需要unsafe</span><br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">99</span>, MUT_BYTES[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态变量有如下性质：</p><ul><li>只在编译期被创建</li><li>默认不可变，修改需要unsafe</li><li>对整个程序范围有效</li></ul><p>所以<code>&#39;static</code>生命周期标记，就是以静态变量默认生命周期命名的，对吧？</p><p>所以如果我们断言<code>&#39;static</code> 生命周期也遵守上述静态变量的规则，也理所应当，对吧？</p><p>是的，这没错。但是，我们要区分：</p><ul><li><p>一个变量<strong>拥有</strong><code>&#39;static</code>生命周期</p><blockquote><p>具体例子是什么？就是静态变量本身吗？</p></blockquote></li><li><p>一个变量被<code>&#39;static</code>生命周期<strong>绑定</strong></p><blockquote><p>这个应该指<code>T: &#39;static</code></p></blockquote></li></ul><p>后者实际上可以在运行时分配内存并创建，也能在safe Rust中自由访问修改，甚至被drop，在任意长度存活。</p><blockquote><p>其实这里我非常很困惑，原文如下：</p><p>The <code>&#39;static</code> lifetime was probably named after the default lifetime of <code>static</code> variables, right? So it makes sense that the <code>&#39;static</code> lifetime has to follow all the same rules, right?</p><p>Well yes, but a type <em>with</em> a <code>&#39;static</code> lifetime is different from a type <em>bounded by</em> a <code>&#39;static</code> lifetime. The latter can be dynamically allocated at run-time, can be safely and freely mutated, can be dropped, and can live for arbitrary durations.</p><p>这个<code>Well, yes</code>具体肯定的是什么东西？<code>’static</code> lifetime has to follow 一句中<code>&#39;static lifetime</code>是主语，这个主语怎么实施follow这个动作？凡是出现<code>‘static</code>，不都是被绑定的情况吗，<code>with &#39;static</code>是什么意思体现在哪里呢？</p></blockquote><p>由此我们再区分一个重要的点： <code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code></p><p><code>&amp;&#39;static</code>是一个对<code>T</code>的不可变引用，可以在任意长的范围内被持有，甚至到程序终止。这当然要求<code>T</code>本身是不可变的(创建共享引用后，原则上不再被修改)，并且在创建引用后不会移动。<code>T</code>不必在编译时创建，因为我们完全可以在运行时动态分配内存，返回一个<code>&#39;static</code>引用，代价是(可能的)内存泄漏，比如：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-comment">// 运行时动态生成随机 &#x27;static str 引用</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rand_str_generator</span></span>() -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">let</span> rand_string = rand::random::&lt;<span class="hljs-built_in">u64</span>&gt;().to_string();<br>    <span class="hljs-built_in">Box</span>::leak(rand_string.into_boxed_str())<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>T: &#39;static</code> 不仅包含 <code>&amp;&#39;static T</code>，还包含所有权类型，比如<code>String</code>，<code>Vec</code>等等，范围更广。所有权类型保证数据的有效性，只要所有权类型被持有，就保证数据在之后任意长的范围内被持有，甚至到程序终止，自然符合<code>&#39;static</code>的意思。<code>T: &#39;static</code>不应该被读作 “<code>T</code> 拥有 <code>&#39;static</code> 生命周期”，应该是“<code>T</code>被<code>&#39;static</code>生命周期<strong>绑定</strong>”。</p><blockquote><p>所有权类型本身就是随时创建，允许被持有到程序结束，也可以随时drop。它可以被<code>&#39;static</code>绑定，就很好地反驳了 <code>T: &#39;static</code> 表示T必须在整个程序范围内有效这一误解</p></blockquote><p>下面这个程序帮我们阐释了这些概念。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop_static</span></span>&lt;T: <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::mem::<span class="hljs-built_in">drop</span>(t);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> strings: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = <span class="hljs-built_in">Vec</span>::new();<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">if</span> rand::random() &#123;<br>            <span class="hljs-comment">// 所有的字符串都是动态随机生成的a</span><br>            <span class="hljs-keyword">let</span> string = rand::random::&lt;<span class="hljs-built_in">u64</span>&gt;().to_string();<br>            strings.push(string);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// String属于所有权类型，所以自然被 &#x27;static 绑定</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">mut</span> string <span class="hljs-keyword">in</span> strings &#123;<br>        <span class="hljs-comment">// 所有字符串可变，并不需要unsafe code</span><br>        string.push_str(<span class="hljs-string">&quot;a mutation&quot;</span>);<br>        <span class="hljs-comment">// 因为满足 &#x27;static 绑定，可以传入`drop_static`销毁</span><br>        drop_static(string); <span class="hljs-comment">// compiles</span><br>    &#125;<br><br>    <span class="hljs-comment">// 在程序结尾，所有字符串已经被销毁了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i am the end of the program&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h4><ul><li><p><code>T: &#39;static</code>应该被读作“<code>T</code>被<code>&#39;static</code>生命周期<strong>绑定</strong>”。</p></li><li><p><code>T: &#39;static</code> 表示<code>T</code>是一个拥有 <code>&#39;static</code> 生命周期的借用 <strong>或者</strong> 是一个所有权类型 </p><blockquote><p>原文这里用的就是<code>with &#39;static</code>，人晕了，不应该是绑定吗？</p></blockquote></li><li><p>由于<code>T: &#39;static</code>中的<code>T</code>包含所有权类型，也就意味着<code>T</code>：</p><ul><li>可以在运行时被动态创建</li><li>不必对整个程序有效</li><li>可以在safe Rust中自由地修改</li><li>可以在运行时被释放</li><li>可以有自由的生命周期</li></ul></li></ul><h3 id="3-amp-39-a和T-39-a含义相同"><a href="#3-amp-39-a和T-39-a含义相同" class="headerlink" title="3) &amp;&#39;a和T:&#39;a含义相同"></a>3) <code>&amp;&#39;a</code>和<code>T:&#39;a</code>含义相同</h3><p>这个误解是2）的泛化版本</p><p><code>&amp;&#39;a T</code> 的出现，实际上也暗示着 <code>T: &#39;a</code>。因为如果<code>T</code>本身不能在范围 <code>&#39;a</code> 中有效，那么对 <code>T</code>的引用自然不会在范围 <code>&#39;a</code> 中有效. 比如，Rust 编译期不会允许创建类型 <code>&amp;&#39;static Ref&lt;&#39;a, T&gt;</code> ，因为 <code>Ref</code> 类型本身只在 <code>&#39;a</code> 范围内有效，我们不可能制作一个 <code>&#39;static</code> 引用指向它。</p><p>另外一点已经提过，<code>T:&#39;a</code> 包含  <code>&amp;&#39;a T</code>，反之不成立</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 只接受被&#x27;a 绑定的引用类型</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">t_ref</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: &amp;<span class="hljs-symbol">&#x27;a</span> T) &#123;&#125;<br><br><span class="hljs-comment">// 只接受被&#x27;a 绑定的任意类型</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">t_bound</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) &#123;&#125;<br><br><span class="hljs-comment">// 所有权类型，包含一个引用，只对 &#x27;a 范围有效</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ref</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;string&quot;</span>);<br><br>    t_bound(&amp;string); <span class="hljs-comment">// compiles</span><br>    t_bound(Ref(&amp;string)); <span class="hljs-comment">// compiles</span><br>    t_bound(&amp;Ref(&amp;string)); <span class="hljs-comment">// compiles</span><br><br>    t_ref(&amp;string); <span class="hljs-comment">// compiles</span><br>    t_ref(Ref(&amp;string)); <span class="hljs-comment">// 编译失败，期望引用类型，</span><br>    t_ref(&amp;Ref(&amp;string)); <span class="hljs-comment">// compiles</span><br><br>    <span class="hljs-comment">// string 被 &#x27;static 绑定，自然可以由范围更小的&#x27;a处理</span><br>    t_bound(string); <span class="hljs-comment">// compiles</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul><li><code>T:&#39;a</code> 比  <code>&amp;&#39;a T</code> 更广泛，更灵活</li><li>如果 <code>T: &#39;static</code> 那么 <code>T: &#39;a</code> 也成立，因为对任意 <code>&#39;a</code>都有 <code>&#39;static</code> &gt;= <code>&#39;a</code> (<code>&#39;static</code> 是所有生命周期类型的子类型)</li></ul><h3 id="4-我的代码没有泛型，而且不需要生命周期"><a href="#4-我的代码没有泛型，而且不需要生命周期" class="headerlink" title="4) 我的代码没有泛型，而且不需要生命周期"></a>4) 我的代码没有泛型，而且不需要生命周期</h3><p>该误解的推论：</p><ul><li>有可能完全避免使用泛型和生命周期</li></ul><p>这个误解的出现，可能有Rust的生命周期省略规则<code>(lifetime elision rules)</code>的责任。这些规则允许你在函数签名中省略生命周期标注，因为编译器会按照如下的规则进行推断：</p><ul><li>每个输入引用都有不同的生命周期</li><li>如果只有一个输入引用，则所有输出引用都应用该生命周期</li><li>如果<code>&amp;self</code>、<code>&amp;mut self</code>出现在输入引用中，那么所有输出引用都应用该生命周期</li><li>其他情况下，生命周期参数都必须显示指定</li></ul><p>一次性也消化不了这么多规则，我们还是看例子吧：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 省略</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>(s: &amp;<span class="hljs-built_in">str</span>);<br><br><span class="hljs-comment">// 展开</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>);<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trim</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 展开</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trim</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 非法，没有输入引用，不能推断输出生命周期</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>() -&gt; &amp;<span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 显式地修复包括：</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 泛型</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>() -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// &#x27;static</span><br><br><span class="hljs-comment">// 非法，有多个输入引用，不能推断输出生命周期</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>(s: &amp;<span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 显式地修复(部分仍然应用了省略规则)包括：</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 输出引用的有效范围不能大于 s 的有效范围</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 输出引用的有效范围不能大于 t 的有效范围</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 输出引用的有效范围不能大于 t或s 的有效范围</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>(s: &amp;<span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 输出引用的有效范围 **可以** 大于输入的s或者t</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// 输出引用的生命周期和输入引用没有关系</span><br><br><span class="hljs-comment">// 展开</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">overlap</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;c</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;c</span> <span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">compare</span></span>(&amp;<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;<br><br><span class="hljs-comment">// 展开</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">compare</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>;<br></code></pre></div></td></tr></table></figure><p>当你写出：</p><ul><li>为结构体实现的方法</li><li>有引用参数的函数</li><li>返回值是引用的函数</li><li>泛型函数</li><li>trait object</li><li>闭包</li></ul><p>实际上都会应用被省略的生命周期标记</p><h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>几乎所有Rust代码都是泛型代码，同时到处都有被省略的生命周期标记。</li></ul><h3 id="5-如果程序可以编译，我的生命周期标注就是正确的"><a href="#5-如果程序可以编译，我的生命周期标注就是正确的" class="headerlink" title="5) 如果程序可以编译，我的生命周期标注就是正确的"></a>5) 如果程序可以编译，我的生命周期标注就是正确的</h3><p>该误解的推论</p><ul><li>Rust的生命周期省略规则总是正确的</li><li>Rust的借用检查器总是正确的，无论在技术层面还是语义层面</li><li>Rust比我更了解我程序的语义</li></ul><p>Rust 可能编译出一个语义上错误的代码。比如</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ByteIter</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-built_in">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.is_empty() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> byte = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-literal">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> bytes = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1&quot;</span> &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">Some</span>(&amp;<span class="hljs-string">b&#x27;1&#x27;</span>), bytes.next());<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, bytes.next());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们实现了一个bytes切片的迭代器，并且成功调用next，看上去一切正常。但是当我们同时持有多个元素，会发生什么呢?</p><figure class="highlight zephir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> mut bytes = ByteIter &#123; remainder: b<span class="hljs-string">&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> byte_1 = bytes.next();<br>    <span class="hljs-keyword">let</span> byte_2 = bytes.next();<br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>报错了</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0499]: cannot borrow `bytes` <span class="hljs-keyword">as</span> mutable more than once at a time<br>  --&gt; src/main.rs:<span class="hljs-number">20</span>:<span class="hljs-number">18</span><br>   |<br><span class="hljs-number">19</span> |     <span class="hljs-keyword">let</span> byte_1 = bytes.next();<br>   |                  ----- first mutable borrow occurs here<br><span class="hljs-number">20</span> |     <span class="hljs-keyword">let</span> byte_2 = bytes.next();<br>   |                  ^^^^^ second mutable borrow occurs here<br><span class="hljs-number">21</span> |     <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>   |        ------ first borrow later used here<br></code></pre></div></td></tr></table></figure><p>要修复这个错误，我们猜测可以使用Copy，每次迭代都复制u8。这当然可以，但是如果我们扩展<code>ByteIter</code>，变为一个泛型的迭代器，工作在<code>&amp;[T]</code>序列上，数据<code>T</code>的复制可能是一个复杂甚至不可实现的操作，那怎么办呢？好吧，那好像没有什么可以做的了，毕竟代码已经正确编译了，生命周期也没有改进的余地了，对吧？</p><p>并不是，其实当前的生命周期标注正是bug的罪魁祸首。而标记的省略，又让这个bug很难被发现。我们先将被省略的标记补充回来，更清楚地观察这个问题：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ByteIter</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-built_in">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.is_empty() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> byte = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-literal">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>好像没什么帮助，仍然让人困惑。Rust专家们有一个建议：给生命周期参数取描述性的名字。我们试试看：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ByteIter</span></span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-built_in">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>&lt;<span class="hljs-symbol">&#x27;mut_self</span>&gt;(&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-built_in">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.is_empty() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> byte = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-literal">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样我们能理解了，每个返回的byte引用都是<code>&#39;mut_self</code>标记，但是显然它应该来自于<code>&#39;remainder</code>！让我们修复这一点：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ByteIter</span></span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-built_in">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;remainder</span> <span class="hljs-built_in">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.is_empty() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> byte = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-literal">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> bytes = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> byte_1 = bytes.next();<br>    <span class="hljs-keyword">let</span> byte_2 = bytes.next();<br>    std::mem::<span class="hljs-built_in">drop</span>(bytes); <span class="hljs-comment">// 我们甚至可以迭代器释放掉</span><br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123; <span class="hljs-comment">// 编译通过，我们可以同时持有多个迭代元素</span><br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在让我们回看有错误的版本，为什么编译通过了？答案很简单：它内存安全。</p><p>Rust借用检查器对生命周期标记的使用，仅停留在静态验证内存安全性，语义层面不关心，即使有错误，只要内存安全就可以编译。比如上面例子中，语义上迭代器需要支持多个迭代引用同时存活，但是只支持一个存活也是内存安全的，所以编译通过，代价是程序变得过分严格，没必要。</p><blockquote><p>修改后可以满足语义，借助的是编译器可以从结构体的字段中自动split出引用 —— rustonomicon。</p></blockquote><p>这里还有一个反面的例子：生命周期的省略正好在语义上正确，我们显示标注的生命周期反而产生了一个“过分严格”的方法。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NumRef</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// NumRef是建立在&#x27;a上的泛型，所以需要把self标记为’a，对吗？</span><br>    <span class="hljs-comment">// (答案: 不, 这样不对)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_method</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num_ref = NumRef(&amp;<span class="hljs-number">5</span>);<br>    num_ref.some_method();     <span class="hljs-comment">// 可变借用num_ref，直到结构体的生命周期结束</span><br>    num_ref.some_method();     <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们有一个建立在<code>&#39;a</code>上的泛型结构体，我们几乎不会为<code>&amp;&#39;a mut self</code>这个<code>方法接收者</code>编写方法。这样表示告诉Rust，”这个方法需要可变借用该结构体，并且保持有效，直到结构体销毁“。在上面的实际情况中，Rust的借用检查器只会允许对<code>some_method</code>进行一次调用，之后结构体就被永久可变借用，几乎陷入不可使用的状态。当然这个情况非常罕见，但是迷糊的初学者还是容易写出。修复方法就是不要加额外的标记，让省略规则处理它。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NumRef</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 不再添加&#x27;a</span><br>    <span class="hljs-comment">// 拓展为 fn some_method_desugared&lt;&#x27;b&gt;(&amp;&#x27;b mut self)&#123;&#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_method</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num_ref = NumRef(&amp;<span class="hljs-number">5</span>);<br>    num_ref.some_method();<br>    num_ref.some_method();     <span class="hljs-comment">// compiles</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// compiles</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>因为使用了省略规则，some_method使用全新的生命周期参数，调用前新建一个作用域，泛型’b单态化到这个新建的作用域，调用结束后退出作用域，归还可变借用。</p></blockquote><h4 id="关键点：-2"><a href="#关键点：-2" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>Rust关于函数的生命周期省略规则并不是对任何情况都适用</li><li>在你程序的语义层面，Rust了解得有限，并不及你</li><li>Rust专家建议：给生命周期标记取描述性的名字</li><li>在显式放置生命周期标记时，多思考为什么</li></ul><h3 id="6-Box托管的trait-object没有生命周期"><a href="#6-Box托管的trait-object没有生命周期" class="headerlink" title="6) Box托管的trait object没有生命周期"></a>6) <code>Box</code>托管的<code>trait object</code>没有生命周期</h3><blockquote><p>额外参考</p><p><a href="https://doc.rust-lang.org/reference/types/trait-object.html">Trait object types - The Rust Reference (rust-lang.org)</a></p><p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">Lifetime elision - The Rust Reference (rust-lang.org)</a></p><p><a href="https://doc.rust-lang.org/std/raw/struct.TraitObject.html">std::raw::TraitObject</a> 本身是两个裸指针，其中有指向数据的引用，该引用的有效范围自然也就确定着 trait object 的生命周期。其他包含引用的结构体都会显式声明生命周期，比如<code>ByteIter&lt;&#39;a&gt;</code>，但是<code>dyn SomeTrait</code>不方便采用类似的声明格式，于是加了另一种语法<code>dyn SomeTrait + &#39;a</code>来表示 <code>struct TraitObject</code> 所绑定的生命周期。而大部分情况下，这种语法的生命周期都是自动推断的，这也是本节讨论的内容。</p></blockquote><p>早前我们讨论了<strong>对函数</strong>的生命周期省略规则。Rust 对 <strong>trait object</strong> 也有相应的生命周期省略规则：</p><ul><li>如果 trait object 被用做一个外围类型的泛型参数，首先考虑基于该外围类型进行生命周期推断<ul><li>如果外围类型有唯一的生命周期绑定，沿用它 (对应<code>&amp;&#39;a dyn Trait</code> 和 <code>Ref&lt;&#39;a, dyn Trait&gt;</code>)</li><li>如果外围类型有多个生命周期绑定，则需要显式指明 trait object 的生命周期 (对应 <code>TwoBounds&lt;&#39;a, &#39;b,  dyn Foo&gt;</code>)</li></ul></li><li>如果上述规则不适用，考虑下列规则:<ul><li>如果 trait 本身定义包含单个生命周期绑定，默认使用 (对应 <code>dyn GenericTrait&lt;&#39;a&gt;</code>)</li><li>如果可以全部 <code>&#39;static</code> , 就用<code>&#39;static</code> . (对应 <code>Box&lt;dyn Trait&gt;</code> ?)</li><li>如果不存在生命周期绑定, 则利用表达式推断，非表达式就使用<code>&#39;static</code> (对应 <code>impl dyn Trait</code>)</li></ul></li></ul><p>这些规则听起来超级复杂，但是可以简单地总结为：<strong>一个 trait object 的生命周期绑定可由从上下文推断</strong>。通过一些例子，我们可以看到这种推断非常符合直觉，所以不必记忆上述规则。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::Ref;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T1</span></span> = <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Trait&gt;;<br><span class="hljs-comment">// 展开， Box&lt;T&gt; 中的 T 没有任何生命周期绑定，所以推断为 &#x27;static</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T2</span></span> = <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">impl</span> <span class="hljs-keyword">dyn</span> Trait &#123;&#125;<br><span class="hljs-comment">// 展开</span><br><span class="hljs-keyword">impl</span> <span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span> &#123;&#125;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T3</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">dyn</span> Trait;<br><span class="hljs-comment">// 展开, &amp;&#x27;a T 要求 T: &#x27;a, 所以推断为 &#x27;a</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T4</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> (<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>);<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T5</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait&gt;;<br><span class="hljs-comment">// 展开, Ref&lt;&#x27;a, T&gt; 要求 T: &#x27;a (Ref内部字段为&amp;&#x27;a dyn Trait), 所以推断为 &#x27;a</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T6</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>&gt;;<br><br><span class="hljs-comment">// 补充来自官方文档的例子</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoBounds</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-symbol">&#x27;a</span> + <span class="hljs-symbol">&#x27;b</span>&gt; &#123;<br>    f1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>,<br>    f2: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span>,<br>    f3: T,<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T7</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; = TwoBounds&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-keyword">dyn</span> Foo&gt;;<br><span class="hljs-comment">//                                  ^^^^^^^</span><br><span class="hljs-comment">// 错误: 这个trait object的生命周期绑定无法从上下文推断</span><br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">GenericTrait</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;: <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">T8</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&gt;;<br><span class="hljs-comment">// 展开</span><br>type &lt;&#x27;a&gt; = Box&lt;dyn GenericTrait&lt;&#x27;a&gt; + &#x27;a&gt;;<br><br><span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;&#125;<br><span class="hljs-comment">// 展开</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; + <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>实现 traits 的具体类型能够持有引用，因此类型本身拥有生命周期绑定，自然它的 trait object 也有对应的生命周期绑定。(即使实现 trait 的类型没有引用)，还可以专门为引用类型实现 trait，这样 trait object 拥有生命周期绑定就显而易见了。</p><blockquote><p>这里显然在解释为什么Box托管的trait object也有生命周期绑定，为什么不放在开头呢？然后再解释如何推断这些生命周期不是更自然，更容易理解吗？后面一段又说了spawn的例子，又是建立在默认推断 <code>’static</code> 的知识上。啊这……这一段的行文我觉得有问题。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Struct</span></span> &#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ref</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> Struct &#123;&#125;<br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> &amp;Struct &#123;&#125; <span class="hljs-comment">// 直接对引用类型实现 Trait</span><br><span class="hljs-comment">// 显然，使用&amp;Struct来制作Box托管的trait object，比如`Box::new(&amp;&#x27;a Struct&#123;&#125;) as Box&lt;dyn Trait&gt;`</span><br><span class="hljs-comment">// 其类型实际是`Box&lt;dyn Trait + &#x27;a&gt;`，不能用到期待Box&lt;dyn Trait + &#x27;static&gt;的地方</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; Trait <span class="hljs-keyword">for</span> Ref&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;&#125; <span class="hljs-comment">// 对包含引用类型的结构实现 Trait</span><br></code></pre></div></td></tr></table></figure><p>(虽然这些规则很繁复、多数时候省略都OK，但是)，无论怎样，审视这些规则是值得的，因为在某些场合，新手会被这个问题导致的奇怪错误搞迷糊，比如当他们把函数中的 trait object 重构为 泛型，后者反过来，将 泛型 重构为 trait object，比如下面这个例子</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dynamic_thread_print</span></span>(t: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).join();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_thread_print</span></span>&lt;T: Display + <span class="hljs-built_in">Send</span>&gt;(t: T) &#123;<br>    std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).join();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>报错为：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0310]: the parameter type `T` may not live long enough<br>  --&gt; src/lib.rs:<span class="hljs-number">10</span>:<span class="hljs-number">5</span><br>   |<br><span class="hljs-number">9</span>  | <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_thread_print</span></span>&lt;T: Display + <span class="hljs-built_in">Send</span>&gt;(t: T) &#123;<br>   |                        -- help: consider adding an explicit lifetime bound...: `T: <span class="hljs-symbol">&#x27;static</span> +`<br><span class="hljs-number">10</span> |     std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br>   |<br>note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds<br>  --&gt; src/lib.rs:<span class="hljs-number">10</span>:<span class="hljs-number">5</span><br>   |<br><span class="hljs-number">10</span> |     std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br></code></pre></div></td></tr></table></figure><p>编译器已经告诉我们如修改，那就：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dynamic_thread_print</span></span>(t: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).join();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_thread_print</span></span>&lt;T: Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::thread::spawn(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).join();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译成功，但是这两个函数有些奇怪，为什么第二个需要<code>&#39;static</code>绑定，而第一个不需要？这就是因为 trait object 的生命周期默认推断，编译器实际上看到的第一个函数有<code>’static</code>绑定。</p><h4 id="关键点：-3"><a href="#关键点：-3" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>所有的 trait objects 都有一些默认推断的生命周期绑定</li></ul><h3 id="7-编译器错误信息会指明如何修改我的程序"><a href="#7-编译器错误信息会指明如何修改我的程序" class="headerlink" title="7) 编译器错误信息会指明如何修改我的程序"></a>7) 编译器错误信息会指明如何修改我的程序</h3><p>该误解的推论</p><ul><li>Rust针对 trait objects 的生命周期省略规则总是正确的</li><li>Rust比我更了解我程序的语义</li></ul><p>该误解是前两个误解的结合，这是例子：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">box_displayable</span></span>&lt;T: Display&gt;(t: T) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>抛出如下错误：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0310]: the parameter type `T` may not live long enough<br> --&gt; src/lib.rs:<span class="hljs-number">4</span>:<span class="hljs-number">5</span><br>  |<br><span class="hljs-number">3</span> | <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">box_displayable</span></span>&lt;T: Display&gt;(t: T) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>  |                    -- help: consider adding an explicit lifetime bound...: `T: <span class="hljs-symbol">&#x27;static</span> +`<br><span class="hljs-number">4</span> |     <span class="hljs-built_in">Box</span>::new(t)<br>  |     ^^^^^^^^^^^<br>  |<br>note: ...so that the type `T` will meet its required lifetime bounds<br> --&gt; src/lib.rs:<span class="hljs-number">4</span>:<span class="hljs-number">5</span><br>  |<br><span class="hljs-number">4</span> |     <span class="hljs-built_in">Box</span>::new(t)<br>  |     ^^^^^^^^^^^<br></code></pre></div></td></tr></table></figure><p>这个推荐的修复信息，依据的是Box为 trait object 自动推断出的<code>&#39;static</code>生命周期绑定，但不管怎样，我们先试着按照它的说的修改。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">box_displayable</span></span>&lt;T: Display + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此程序通过了编译……但这是我们希望的吗？大概是，也可能有问题。虽然编译期没有提及，但是这样修改可能更合适：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">box_displayable</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: Display + <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个函数可以接受的参数兼容上一个版本，并且还支持更多。情况更好了吗？也不一定，取决于我们程序本身的要求和约束。这个例子可能有点抽象，所以我们再看一个更简单的、更明显的例子：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">return_first</span></span>(a: &amp;<span class="hljs-built_in">str</span>, b: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    a<br>&#125;<br></code></pre></div></td></tr></table></figure><p>报错</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0106]: missing lifetime specifier<br> --&gt; src/lib.rs:<span class="hljs-number">1</span>:<span class="hljs-number">38</span><br>  |<br><span class="hljs-number">1</span> | <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">return_first</span></span>(a: &amp;<span class="hljs-built_in">str</span>, b: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>  |                    ----     ----     ^ expected named lifetime parameter<br>  |<br>  = help: this function<span class="hljs-symbol">&#x27;s</span> <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">contains</span></span> a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`<br>help: consider introducing a named lifetime parameter<br>  |<br><span class="hljs-number">1</span> | <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">return_first</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(a: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, b: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br></code></pre></div></td></tr></table></figure><p>错误信息推荐为输入引用和输出引用使用相同的标记。虽然能编译了，但是我们我们的返回值的限制可能过强，也许我们需要的是</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">return_first</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(a: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, b: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    a<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="关键点：-4"><a href="#关键点：-4" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>Rust关于 trait objects 的生命周期省略规则并不是对任何情况都适用</li><li>在你程序的语义层面，Rust了解得有限，并不及你</li><li>Rust在错误信息中给出的修改意见虽然可以让程序通过编译，但可能并不是最适合你程序的方案。</li></ul><h3 id="8-生命周期可以在运行时扩张或者缩小"><a href="#8-生命周期可以在运行时扩张或者缩小" class="headerlink" title="8) 生命周期可以在运行时扩张或者缩小"></a>8) 生命周期可以在运行时扩张或者缩小</h3><p>该误解的推论：</p><ul><li>容器类型可以在运行时交换(swap)引用，从而改变交换双方的生命周期</li><li>Rust的借用检查器执行了高级的控制流分析</li></ul><p>这段代码不能编译：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Has</span></span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-built_in">str</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> long = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> has = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> short = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-comment">// &quot;切换&quot; 到更短的生命周期</span><br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        <span class="hljs-comment">// &quot;切换回&quot; 长生命周期</span><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 在这里 dropped</span><br>    &#125;<br><br>    <span class="hljs-comment">// 编译错误，显示 `short` 被drop后仍然被借用</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>抛出错误</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0597]: `short` does not live long enough<br>  --&gt; src/main.rs:<span class="hljs-number">11</span>:<span class="hljs-number">24</span><br>   |<br><span class="hljs-number">11</span> |         has.lifetime = &amp;short;<br>   |                        ^^^^^^ borrowed value does not live long enough<br>...<br><span class="hljs-number">15</span> |     &#125;<br>   |     - `short` dropped here <span class="hljs-keyword">while</span> still borrowed<br><span class="hljs-number">16</span> |     <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>   |     --------------------------------- borrow later used here<br></code></pre></div></td></tr></table></figure><blockquote><p>这个错误是因为Rust发现了替换动作，并选择了最短的生命周期进行绑定，然后静态分析到最后一句<code>println</code>时，发现引用应该在更大的范围内有效，于是报错。如果删除最后一句话，这段代码可以编译：确定的周期是short，long被缩短后使用。</p></blockquote><p>(尝试使用false，让替换分支在运行时不执行，看Rust编译器是否提前知道，从而避免对生命周期的错误判断）</p><p>下面这段代码也不能通过编译，报告相同的错误</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Has</span></span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-built_in">str</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> long = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> has = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    <span class="hljs-comment">// 使用false，指明不执行以下block</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> &#123;<br>        <span class="hljs-keyword">let</span> short = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;short&quot;</span>);<br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 在这里 dropped</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还是编译错误，显示 `short` 被drop后仍然被借用</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由此我们知道，生命周期参数是在编译期就被静态验证的，并且借用检查器的控制流分析很初级，它假定每个<code>if-else</code>的 block 都可能会执行，每个 match 的 arm 都可能会被选中，从而为(未限制执行生命周期的)变量选择一个最短的生命周期绑定。一旦生命周期被绑定，就永远被绑定了。变量的生命周期只有可能缩短(子类型当作父类型使用)，但这种缩短，也是在编译期就被确定的。</p><h4 id="关键点：-5"><a href="#关键点：-5" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>生命周期在编译时被静态验证</li><li>在运行时，变量的生命周期不会以任何形式发生改变</li><li>Rust的借用检查器假定所有分支都会被命中，为变量选择最短的生命周期。</li></ul><h3 id="9-将可变引用退化为共享引用是安全的"><a href="#9-将可变引用退化为共享引用是安全的" class="headerlink" title="9) 将可变引用退化为共享引用是安全的"></a>9) 将可变引用退化为共享引用是安全的</h3><p>该误解的推论：</p><ul><li>重新借用一个引用，会结束被借引用的生命周期并产生一个新的引用</li></ul><p>如果函数的一个参数是共享引用，那么你其实可以传递一个可变引用，因为Rust会将可变引用重新借用出一个不可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_shared_ref</span></span>(n: &amp;<span class="hljs-built_in">i32</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = <span class="hljs-number">10</span>;<br>    takes_shared_ref(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// 通过编译</span><br>    takes_shared_ref(&amp;*(&amp;<span class="hljs-keyword">mut</span> a)); <span class="hljs-comment">// 将上一行的语法糖去掉后，使用deref重新借出不可变引用</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>直觉上这容易理解，因为把一个可变应用重借出一个不可变引用，不会造成什么危害，对吧？答案是否定的，下面这段程序不能编译</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> b: &amp;<span class="hljs-built_in">i32</span> = &amp;*(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// re-borrowed as immutable</span><br>    <span class="hljs-keyword">let</span> c: &amp;<span class="hljs-built_in">i32</span> = &amp;a;<br>    dbg!(b, c); <span class="hljs-comment">// compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>抛出错误</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0502]: cannot borrow `a` <span class="hljs-keyword">as</span> immutable because it is also borrowed <span class="hljs-keyword">as</span> mutable<br> --&gt; src/main.rs:<span class="hljs-number">4</span>:<span class="hljs-number">19</span><br>  |<br><span class="hljs-number">3</span> |     <span class="hljs-keyword">let</span> b: &amp;<span class="hljs-built_in">i32</span> = &amp;*(&amp;<span class="hljs-keyword">mut</span> a);<br>  |                     -------- mutable borrow occurs here<br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> c: &amp;<span class="hljs-built_in">i32</span> = &amp;a;<br>  |                   ^^ immutable borrow occurs here<br><span class="hljs-number">5</span> |     dbg!(b, c);<br>  |          - mutable borrow later used here<br></code></pre></div></td></tr></table></figure><p>这段代码中，(第三行) 我们的确执行了可变借用，但是立马重借出不可变借用(b)，(期望)可变借用自动销毁。但Rust对待重借出的不可变引用(b)时，感觉和原有的可变借用如出一辙(b，c不能同时存活，变相等于可变引用并未销毁)。尽管上例中(即使放开限制，drop掉可变引用)不会出现问题，但是允许将可变引用直接降级为不可变引用（并且销毁(归还)原有的可变引用），确实会造成潜在的内存不安全：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Struct</span></span> &#123;<br>    mutex: Mutex&lt;<span class="hljs-built_in">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Struct &#123;<br>    <span class="hljs-comment">// 把 mut self 降级为 shared str</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_string</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.mutex.get_mut().unwrap()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mutate_string</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 如果 Rust 允许将 可变引用 直接降级为 不可变引用</span><br>        <span class="hljs-comment">// 那么下一行代码会使通过`get_string` 方法得到的共享引用失效</span><br>        *<span class="hljs-keyword">self</span>.mutex.lock().unwrap() = <span class="hljs-string">&quot;surprise!&quot;</span>.to_owned();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = Struct &#123;<br>        mutex: Mutex::new(<span class="hljs-string">&quot;string&quot;</span>.to_owned())<br>    &#125;;<br>    <span class="hljs-keyword">let</span> str_ref = s.get_string(); <span class="hljs-comment">// 可变引用 直接降级为 不可变引用</span><br>    s.mutate_string(); <span class="hljs-comment">// str_ref 失效, 成为悬空指针</span><br>    dbg!(str_ref); <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个例子的重点是，当你向可变引用 mut self 重借出共享引用时，你会陷入一个反直觉的陷阱：这个动作实际拓展了 mut self 的生命周期，和被借出的共享应用一样长（编译时确定作用域和生命周期参数），即使 可变借用 本身已经被drop</p><blockquote><p>我一直不是很理解这里的”即使被drop“，既然编译器都已经给可变引用<code>mut self</code>和重借出引用<code>&amp;str</code>附上了相同的生命周期参数，那显然<code>mut self</code>就没有释放啊，作者的思维还是停留在上一个例子里？）</p></blockquote><p>使用重借出引用很麻烦(反直觉)，它本身虽然是不可变的，但是却不能和其他不可变引用同时存活。重借出引用有 可变引用 和 不可变引用 的缺点，却没有他们的优点。我认为“向可变引用重借出不可变引用”这一行为，在Rust中属于反模式的行为。对这种反模式保持警惕很重要，当你看到下面这样的代码时，可以轻松地识别到它。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 降级了，要小心!</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_function</span></span>&lt;T&gt;(some_arg: &amp;<span class="hljs-keyword">mut</span> T) -&gt; &amp;T;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Struct</span></span>;<br><br><span class="hljs-keyword">impl</span> Struct &#123;<br>    <span class="hljs-comment">// 降级了，要小心!</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_method</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-comment">// 降级了，要小心!</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">other_method</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;T;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>即使你在函数或者方法签名中避免了使用重借出，Rust还是存在隐式的重借出，让你不经意间又遇到这个问题，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">PlayerID</span></span> = <span class="hljs-built_in">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Player</span></span> &#123;<br>    score: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">start_game</span></span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// 从服务器获取选手信息，不存在时创建并更新选手信息</span><br>    <span class="hljs-keyword">let</span> player_a: &amp;Player = server.entry(player_a).or_default();<br>    <span class="hljs-keyword">let</span> player_b: &amp;Player = server.entry(player_b).or_default();<br><br>    <span class="hljs-comment">// 同时持有两个选手并操作</span><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>出错原因是<code>entry</code>语法中<code>or_default</code>返回的是<code>&amp;mut Player</code>，由于显式的类型标注，发生了隐式的重借出。完成相同的目的，我们需要</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">PlayerID</span></span> = <span class="hljs-built_in">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Player</span></span> &#123;<br>    score: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">start_game</span></span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// drop 返回的 Player的可变引用，它们不能同时使用</span><br>    server.entry(player_a).or_default();<br>    server.entry(player_b).or_default();<br><br>    <span class="hljs-comment">// 再次获取选手信息，以不可变引用的形式，没有重借出</span><br>    <span class="hljs-keyword">let</span> player_a = server.get(&amp;player_a);<br>    <span class="hljs-keyword">let</span> player_b = server.get(&amp;player_b);<br><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 成功编译</span><br></code></pre></div></td></tr></table></figure><p>这有点笨拙和繁复，但也算我们为”内存安全祭坛“献上的祭品吧。</p><h4 id="关键点：-6"><a href="#关键点：-6" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>尽量不要向可变引用重借出共享引用，否则你会很难受</li><li>对一个可变引用重借出，并不会终止它的生命周期（会伴随借出的共享引用，随时备查），即使它被drop</li></ul><h3 id="10-闭包和函数有相同的生命周期省略规则"><a href="#10-闭包和函数有相同的生命周期省略规则" class="headerlink" title="10) 闭包和函数有相同的生命周期省略规则"></a>10) 闭包和函数有相同的生命周期省略规则</h3><p>与其说这是一个误解，不如说它是Rust本身的陷阱。</p><p>闭包，尽管(其行为)也是个函数，却不遵守函数的生命周期省略规则。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function</span></span>(x: &amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> closure = |x: &amp;<span class="hljs-built_in">i32</span>| x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>报错：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error: lifetime may not live long enough<br> --&gt; src/main.rs:<span class="hljs-number">6</span>:<span class="hljs-number">29</span><br>  |<br><span class="hljs-number">6</span> |     <span class="hljs-keyword">let</span> closure = |x: &amp;<span class="hljs-built_in">i32</span>| x;<br>  |                       -   - ^ returning this value requires that `&#x27;<span class="hljs-number">1</span>` must outlive `&#x27;<span class="hljs-number">2</span>`<br>  |                       |   |<br>  |                       |   <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">of</span></span> closure is &amp;&#x27;<span class="hljs-number">2</span> <span class="hljs-built_in">i32</span><br>  |                       <span class="hljs-keyword">let</span><span class="hljs-symbol">&#x27;s</span> call the lifetime of this reference `&#x27;<span class="hljs-number">1</span>`<br></code></pre></div></td></tr></table></figure><p>去掉语法糖后：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 输出引用 沿用 输入引用 的生命周期</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 输入和输出有个各自的生命周期参数</span><br>    <span class="hljs-keyword">let</span> closure = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>| -&gt; &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span> &#123; x &#125;;<br>    <span class="hljs-comment">// 注意: 上面这行有语法错误，但是为了表达意图，姑且任之</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>并没有一个好的理由来解释这种差异的出现。最早闭包实现的时候就用了不同的类型推断语义，现在统一也来不及了，因为这会是一个不向后兼容的修改。所以我们如何显式标注一个闭包的类型？可能的方法有：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 转换为trait object, 但这是个DST，不能放到栈上，编译错误</span><br>    <span class="hljs-keyword">let</span> identity: <span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span> = |x: &amp;<span class="hljs-built_in">i32</span>| x;<br><br>    <span class="hljs-comment">// 放到堆上，当然可以，但是这有点笨重</span><br>    <span class="hljs-keyword">let</span> identity: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Box</span>::new(|x: &amp;<span class="hljs-built_in">i32</span>| x);<br><br>    <span class="hljs-comment">// 也可以跳过堆分配，直接做静态引用</span><br>    <span class="hljs-keyword">let</span> identity: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span> = &amp;|x: &amp;<span class="hljs-built_in">i32</span>| x;<br><br>    <span class="hljs-comment">// 上一行去掉语法糖后:)</span><br>    <span class="hljs-keyword">let</span> identity: &amp;<span class="hljs-symbol">&#x27;static</span> (<span class="hljs-keyword">dyn</span> <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span> + <span class="hljs-symbol">&#x27;static</span>) = &amp;|x: &amp;<span class="hljs-built_in">i32</span>| -&gt; &amp;<span class="hljs-built_in">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// 要是写法可以换成这样，这把将绝杀，可惜换不得</span><br>    <span class="hljs-keyword">let</span> identity: <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span> = |x: &amp;<span class="hljs-built_in">i32</span>| x;<br><br>    <span class="hljs-comment">// 这样也不错，可还是不行</span><br>    <span class="hljs-keyword">let</span> identity = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>| -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// impl Trait 的语法可以写在在函数的返回值，所以我们可以引入这样一个工具函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">return_identity</span></span>() -&gt; <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-built_in">i32</span>) -&gt; &amp;<span class="hljs-built_in">i32</span> &#123;<br>        |x| x<br>    &#125;<br>    <span class="hljs-keyword">let</span> identity = return_identity();<br><br>    <span class="hljs-comment">// 工具函数可以写得更泛化一些</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">annotate</span></span>&lt;T, F&gt;(f: F) -&gt; F <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">Fn</span>(&amp;T) -&gt; &amp;T &#123;<br>        f<br>    &#125;<br>    <span class="hljs-keyword">let</span> identity = annotate(|x: &amp;<span class="hljs-built_in">i32</span>| x);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="关键点：-7"><a href="#关键点：-7" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>每门语言都有陷阱🤷</li></ul><h3 id="11-39-static引用总能强制转换为-39-a引用"><a href="#11-39-static引用总能强制转换为-39-a引用" class="headerlink" title="11) &#39;static引用总能强制转换为&#39;a引用"></a>11) <code>&#39;static</code>引用总能强制转换为<code>&#39;a</code>引用</h3><p>之前我已经举过这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// generic version</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_str</span></span>() -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>; <span class="hljs-comment">// &#x27;static version</span><br></code></pre></div></td></tr></table></figure><p>一些读者曾联系我，询问这两种方法是否有现实意义的区别。经过探究，答案是肯定的，他们确实有区别。</p><p>通常对值来说，在使用<code>&#39;a</code>绑定引用的地方，我们总可以使用<code>&#39;static</code>绑定引用进行替换，因为Rust会把<code>&#39;static</code>引用强制转换为<code>&#39;a</code>引用。(比如代码期待<code>&amp;&#39;a i32</code>的地方，我们总可以使用<code>&amp;&#39;static i32</code>)。这是符合直觉的，在期待短生命周期引用的地方使用长生命周期引用，并不会产生内存安全问题（长生命周期的引用必然在更小的作用域内保持有效）。下面的代码可以如期编译：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">generic_str_fn</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_str_fn</span></span>() -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">a_or_b</span></span>&lt;T&gt;(a: T, b: T) -&gt; T &#123;<br>    <span class="hljs-keyword">if</span> rand::random() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-string">&quot;string&quot;</span>.to_owned();<br>    <span class="hljs-keyword">let</span> some_str = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> str_ref = a_or_b(some_str, generic_str_fn()); <span class="hljs-comment">// compiles</span><br>    <span class="hljs-keyword">let</span> str_ref = a_or_b(some_str, static_str_fn()); <span class="hljs-comment">// compiles</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>然而，当引用属于函数类型签名的一部分时，这种转换不会生效</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">generic_str_fn</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_str_fn</span></span>() -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">a_or_b_fn</span></span>&lt;T, F&gt;(a: T, b_fn: F) -&gt; T<br>    <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">Fn</span>() -&gt; T<br>&#123;<br>    <span class="hljs-keyword">if</span> rand::random() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b_fn()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-string">&quot;string&quot;</span>.to_owned();<br>    <span class="hljs-keyword">let</span> some_str = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> str_ref = a_or_b_fn(some_str, generic_str_fn); <span class="hljs-comment">// compiles</span><br>    <span class="hljs-keyword">let</span> str_ref = a_or_b_fn(some_str, static_str_fn); <span class="hljs-comment">// compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>抛出这样的错误</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0597]: `some_string` does not live long enough<br>  --&gt; src/main.rs:<span class="hljs-number">23</span>:<span class="hljs-number">21</span><br>   |<br><span class="hljs-number">23</span> |     <span class="hljs-keyword">let</span> some_str = &amp;some_string[..];<br>   |                     ^^^^^^^^^^^ borrowed value does not live long enough<br>...<br><span class="hljs-number">25</span> |     <span class="hljs-keyword">let</span> str_ref = a_or_b_fn(some_str, static_str_fn);<br>   |                   ---------------------------------- argument requires that `some_string` is borrowed <span class="hljs-keyword">for</span> `<span class="hljs-symbol">&#x27;static</span>`<br><span class="hljs-number">26</span> | &#125;<br>   | - `some_string` dropped here <span class="hljs-keyword">while</span> still borrowed<br></code></pre></div></td></tr></table></figure><p>这是否属于 Rust 缺陷还存在争议，毕竟前一个例子中，是在值上做直接转换，从 <code>&amp;&#39;static str</code> 到 <code>&amp;&#39;a str</code>。但是当前例子是在转换类型，从 <code>for&lt;T&gt; Fn() -&gt; &amp;&#39;static T</code> 到 <code>for&lt;&#39;a, T&gt; Fn() -&gt; &amp;&#39;a T</code>。</p><h4 id="关键点：-8"><a href="#关键点：-8" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>拥有签名<code>for&lt;&#39;a, T&gt; fn() -&gt; &amp;&#39;a T</code>的函数，比<code>for&lt;T&gt; fn() -&gt; &amp;&#39;static T</code>更加灵活，适应更多的场景</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><code>T</code>是<code>&amp;T</code>和<code>&amp;mut</code>的超集</li><li><p><code>&amp;T</code>和<code>&amp;mut T</code>不相交</p></li><li><p><code>T: &#39;static</code>应该被读作“<code>T</code>被<code>&#39;static</code>生命周期<strong>绑定</strong>”。</p></li><li><code>T: &#39;static</code> 表示<code>T</code>是一个拥有 <code>&#39;static</code> 生命周期的借用 <strong>或者</strong> 是一个所有权类型 (原文这里用的就是<code>with &#39;static</code>，人晕了，不应该是绑定吗？ )</li><li><p>由于<code>T: &#39;static</code>中的<code>T</code>包含所有权类型，也就意味着<code>T</code>：</p><ul><li>可以在运行时被动态创建</li><li>不必对整个程序有效</li><li>可以在safe Rust中自由地修改</li><li>可以在运行时被释放</li><li>可以有自由的生命周期</li></ul></li><li><p><code>T:&#39;a</code> 比  <code>&amp;&#39;a T</code> 更广泛，更灵活</p></li><li>如果 <code>T: &#39;static</code> 那么 <code>T: &#39;a</code> 也成立，因为对任意 <code>&#39;a</code>都有 <code>&#39;static</code> &gt;= <code>&#39;a</code> (<code>&#39;static</code> 是所有生命周期类型的子类型)</li><li>几乎所有Rust代码都是泛型代码，同时到处都有被省略的生命周期标记。</li><li>Rust关于函数的生命周期省略规则并不是对任何情况都适用</li><li>在你程序的语义层面，Rust了解得有限，并不及你</li><li>Rust专家建议：给生命周期标记取描述性的名字</li><li>在显式放置生命周期标记时，多思考为什么</li><li>Rust在错误信息中给出的修改意见虽然可以让程序通过编译，但可能并不是最适合你程序的方案。</li><li>生命周期在编译时被静态验证</li><li>在运行时，变量的生命周期不会以任何形式发生改变</li><li><p>Rust的借用检查器假定所有分支都会被命中，为变量选择最短的生命周期。</p></li><li><p>尽量不要向可变引用重借出共享引用，否则你会很难受</p></li><li>对一个可变引用重借出，并不会终止它的生命周期（会伴随借出的共享引用，随时备查），即使它被drop</li><li>每门语言都有陷阱🤷</li><li>拥有签名<code>for&lt;&#39;a, T&gt; fn() -&gt; &amp;&#39;a T</code>的函数，比<code>for&lt;T&gt; fn() -&gt; &amp;&#39;static T</code>更加灵活，适应更多的场景</li></ul><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>在这些地方讨论这篇文章</p><ul><li><a href="https://www.reddit.com/r/learnrust/comments/gmrcrq/common_rust_lifetime_misconceptions/">learnrust subreddit</a></li><li><a href="https://users.rust-lang.org/t/blog-post-common-rust-lifetime-misconceptions/42950">official Rust users forum</a></li><li><a href="https://twitter.com/pretzelhammer/status/1263505856903163910">Twitter</a></li><li><a href="https://www.reddit.com/r/rust/comments/golrsx/common_rust_lifetime_misconceptions/">rust subreddit</a></li><li><a href="https://news.ycombinator.com/item?id=23279731">Hackernews</a></li></ul><h2 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h2><ul><li><a href="https://twitter.com/pretzelhammer">在twitter上关注pretzelhammer</a></li><li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">watch GitHub 仓库</a></li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness in Rust</a></li><li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/learning-rust-in-2020.md">Learning Rust in 2020</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课程 nand2tetris Part-I 回顾</title>
    <link href="/2020/04/18/nand2tetris/"/>
    <url>/2020/04/18/nand2tetris/</url>
    
    <content type="html"><![CDATA[<p>⭐⭐⭐⭐⭐推荐</p><a id="more"></a><h1 id="课程脉络"><a href="#课程脉络" class="headerlink" title="课程脉络"></a>课程脉络</h1><h2 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h2><p>关键的理论保证：<strong>任何一个真值表，都能用布尔表达式来实现</strong></p><p>这一章以与非门为起点，构建了基础了逻辑门，Not、And、Or、Xor, 并且实现了选择器(Mux)和分发器(DMux)。</p><p>两个想法：</p><ol><li><p>用我自己的话说，Mux就是赛马比赛，分半区，一个个地选择局部冠军，最后到总冠军；DMux就是在二叉树中的接力赛，一层层传递，但是每层只有一个节点包含输入值。</p></li><li><p>Mux启示，在布尔逻辑层，<code>if</code>的实现是两个分支都计算，然后选择结果，而不是像高级语言那样，判断条件后选择分支去计算结果。</p></li></ol><h2 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h2><p>构建的逻辑是</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">半加器 两个bit，(a, b)，计算出(进位，结果)<br><br>|<br>v<br><br>全加器 三个bit，(进位，a，b)，计算出(进位，结果)<br><br>|<br>v<br><br>加法器 串联全加器，每个全加器给出一位结果，并向下一个全加器传入进位<br><br>|<br>v<br><br>算术逻辑单元  给出控制位，控制计算行为，比如计算a+b, !a, -a, a &amp; b等<br>             这是CPU芯片能力的体现，乘除法、浮点计算可以有专门的单元<br><br></code></pre></div></td></tr></table></figure><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>构建的逻辑<br><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">DFF 原语<br><br>|<br>v<br><br>Bit寄存器 Mux + DFF + load控制位<br><br>|<br>v<br><br>16位寄存器<br><br>|<br>v<br><br>RAM N个16位寄存器 + address, N=8,64, 512, 4K,...<br><br>\_ PC 程序计数器<br></code></pre></div></td></tr></table></figure></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>区分了两类元件，<code>combinational</code> 和 <code>sequential</code></p><p>关键在于元件是否含有触发器(flip-flop)，在本课程中，特指DFF，Data Flip Flop。包含的就属于<code>sequential</code>。</p><p>DFF的特点是，它的输出，是前一个时刻的输入，表达式为<code>out(t) = in(t-1)</code></p><p>所谓时刻，是指计算机都有一个全局的时钟脉冲，高-低-高-低的循环往复，tick, tock, tick, tock。而触发器总会被高电平或者低电平所”触发”而产生输出，而这个输出，像前面说的，就是上一个脉冲时，输入是多少。</p><p>正是因为这样的特性，<code>sequential</code>可以把输出接到输入上，因为他们实际上是<strong>不同时刻</strong>的值，不会造成问题。而<code>combinational</code>的输入和输出是在同一时刻确定的，所以不能形成有效的loop，比如之前的And、Or、加法器等等。输出接输入loop的意义是，DFF可以记住自己的值，也就是在时间(tick-tock)流动过程中，保持输出值不变。</p><p>寄存器就是在利用DFF，增加一个<code>load</code>的控制，显示控制是否让DFF记住新的值，换个说法就是读/写模式的切换。如下图<br><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck">                <span class="hljs-comment">|</span><br><span class="hljs-comment"></span>                <span class="hljs-comment">|</span> <span class="hljs-comment">load</span><br><span class="hljs-comment">in</span>              <span class="hljs-comment">v</span><br><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<span class="hljs-literal">+</span>--<span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>      <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>            <span class="hljs-comment">out</span><br><span class="hljs-comment"></span>             <span class="hljs-comment">|</span> <span class="hljs-comment">Mux</span> <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-literal">+</span> <span class="hljs-comment">DFF</span> <span class="hljs-literal">+</span> --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <br>          --&gt;<span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>      <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>    <span class="hljs-comment">|</span><br><span class="hljs-comment"></span>          <span class="hljs-comment">|</span>                          <span class="hljs-comment">|</span><br><span class="hljs-comment"></span>          --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><br></code></pre></div></td></tr></table></figure><br><code>load=1</code>的时刻，寄存器的输出仍然时上一次储存的值，但是Mux已经选择了<code>in</code>成为DFF的输入，所以下一个时刻，寄存器将输出<code>in</code>。</p><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>字：用16位的寄存器来造内存，16就是字长</p><p>RAM由多个寄存器组成，输入为<code>load</code>， <code>address[16]</code>，输出为<code>out[16]</code></p><p><code>address</code>能够指定了读写具体发生在哪一个寄存器上</p><p>RAM的全称为Random Access Memory，含义是，任意指定<code>address</code>，都能在相同的单位时间内完成读写。这是<code>Mux</code>、 <code>DMux</code>下层电路的能力。</p><p>RAM的叠加过程很简单，MSB指定大区，剩下的指定具体位置，然后递归，在每个大区里面执行一样的动作。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>程序计数器三个基本控制位:</p><ul><li><code>reset</code> 起始数字归0</li><li><code>load</code> 写入新的起始数字</li><li><code>inc</code> +1输出</li></ul><p>优先级依次降低，实现上可以反向计算结果，然后选择结果输出</p><p>下面一张图，更清晰地理解，上一时刻的状态决定当前时间输出的特性：</p><p><img src="https://s1.ax1x.com/2020/04/14/GzfRkq.png" alt="GzfRkq.png"></p><h2 id="机器码和汇编"><a href="#机器码和汇编" class="headerlink" title="机器码和汇编"></a>机器码和汇编</h2><p>机器码是给CPU看的，一串01010101001， 要包含三方面的信息：</p><p><strong>从哪来？干什么？到哪去？</strong></p><ol><li>操作数在哪里，怎么读取它？ 比如操作数直接在寄存器里，或者在主存某个位置</li><li>要执行什么操作？ 比如之前造的ALU支持6位的控制位，那么机器码至少要包含这6个控制位，ALU才能读懂要做什么事情。</li><li>当前指令执行完后，下一条执行什么？ 没有指定，就顺序执行，否则就按照指令中的规则跳转</li></ol><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">000010101 0010101 01010<br>--------- ------- -----<br>  指令     操作数   跳转<br></code></pre></div></td></tr></table></figure><p>所谓寻址，是看待操作数的0101的不妨方式</p><ul><li>立即数，操作数本身就是数据，实际上没有必要寻址 e.g. <code>LOADI R1, 67  // R1 &lt;- 67</code> </li><li>寄存器寻址，操作数是寄存器的地址，从寄存器中读取数据 e.g. <code>Add R2, R1, R3/ / R2 &lt;- R1 + R3</code> </li><li>直接寻址，数据在主存中，操作数就是数据在主存中的地址，到内存中读取得到数据 e.g. <code>LOAD R1, 67 // R1 &lt;- M[67]</code></li><li>间接寻址，操作数是一个地址，读取其内容(主存、寄存器)后，才得到数据在内存中的地址，再从内中得到数据 e.g. <code>LOAD* R2, R1 // R2 &lt;- M[R1]</code></li></ul><blockquote><p>所以间接寻址，就可以看作是C语言中的指针的实现</p></blockquote><p>指令包含加减法、布尔操作等</p><p>跳转指根据ALU的计算结果(<code>&gt;0, &lt;0 ...</code>)来触发跳转</p><p><strong>汇编语言</strong>就是建立起字符串和底层01001的映射关系，方便人来书写。并且支持一定的符号解析功能。符号解析在第六章-构建汇编器，有仔细说明</p><h2 id="制作CPU"><a href="#制作CPU" class="headerlink" title="制作CPU"></a>制作CPU</h2><p>CPU要能理解上一节的机器码，因此它的主要功能有：</p><ol><li>解析机器码，转化为内部CPU的控制位</li><li>读取、储存操作数，因此需要<strong>内部寄存器</strong>作为CPU的组件</li><li>执行计算，因此需要一个<strong>ALU</strong>作为组件</li><li>判断是否跳转，<strong>输出</strong>下一条指令的位置，因此需要一个<strong>Counter</strong>作为组件</li></ol><blockquote><p>在Hack中，内存的操作数的读取是用A-instruction读取的，所以没有同步的问题</p></blockquote><h2 id="编写汇编器"><a href="#编写汇编器" class="headerlink" title="编写汇编器"></a>编写汇编器</h2><p>总体上，汇编器是简单的文本处理程序，翻译为二进制格式。</p><p>只是会因为增加更多的数据类型以及支持符号解析而变得复杂一些。</p><p>本课程中的符号分为标签和变量。标签是机器码指令的地址。变量是内存地址。变量对应的具体的内存地址的值不重要，一般按照地址空间递增就好了。高级语言的变量其实也是这样，变量就是某个内存地址，变量的值，是那个地址中的内容。</p><p>流程是两次扫描。第一次解析全局标签。第二次生成机器码。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>课程配套简直完美。教材语言简单直接，Project环境完备操作方便反馈清晰，每个Project难度适中，对我来说刚刚好，做起来很顺畅，做完有收获有成就感。</p><p>总体脉络写的是通用的知识点，HACK本身的一些笔记和想法，放在了<a href="https://github.com/aptend/nand2tetris">gitbub</a>上备份存档</p>]]></content>
    
    
    
    <tags>
      
      <tag>TYCS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go工作队列学习(三) - 限速队列</title>
    <link href="/2020/03/20/work-queue-ratelimit/"/>
    <url>/2020/03/20/work-queue-ratelimit/</url>
    
    <content type="html"><![CDATA[<p>第三篇，限速队列: 等多久？让我找个大仙算算</p><a id="more"></a><h2 id="限速队列"><a href="#限速队列" class="headerlink" title="限速队列"></a>限速队列</h2><p>限速队列之前都没听说过，看了接口定义也不懂，直接看限速器的定义了</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// client-go/util/workqueue/rate_limiting_queue.go</span><br><br><span class="hljs-keyword">type</span> RateLimitingInterface <span class="hljs-keyword">interface</span> &#123;<br><br>  DelayingInterface                <span class="hljs-comment">// 组合延时队列</span><br>  AddRateLimited(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 按照限速方式添加元素的接口</span><br>  Forget(item <span class="hljs-keyword">interface</span>&#123;&#125;)         <span class="hljs-comment">// 丢弃指定元素</span><br>  NumRequeues(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">int</span> <span class="hljs-comment">// 查询元素放入队列的次数</span><br><br>&#125;<br><br><span class="hljs-comment">// 限速队列的实现</span><br><span class="hljs-keyword">type</span> rateLimitingType <span class="hljs-keyword">struct</span> &#123;<br>  DelayingInterface         <span class="hljs-comment">// 组合延迟队列</span><br>  rateLimiter RateLimiter    <span class="hljs-comment">// 限速器</span><br>&#125;<br><br><span class="hljs-comment">//client-go/blob/master/util/workqueue/default_rate_limiters.go</span><br><span class="hljs-keyword">type</span> RateLimiter <span class="hljs-keyword">interface</span> &#123;<br>  When(item <span class="hljs-keyword">interface</span>&#123;&#125;) time.Duration <span class="hljs-comment">// 返回元素item需要等待多长时间</span><br>  Forget(item <span class="hljs-keyword">interface</span>&#123;&#125;)            <span class="hljs-comment">// 从限速器中丢弃该元素，比如元素重入队列的次数该清零</span><br>  NumRequeues(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 元素重入队列的次数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>最开始不是很明白<code>Forget</code>和<code>NumRequeues</code>的作用，但是根据<code>When</code>和限速的语义，是这么猜的，限速队列的入队列接口是<code>AddRateLimited</code>，<code>When</code>自动计算延时时间<code>duration</code>，再安排调用<code>AddAfter(item，duration)</code>。比如说现在一秒内调用了10次<code>AddRateLimited</code>，但是可以通过限速器，把对象真正加入队列的时间分配到10s上。<code>AddAfter(obj0, 0)</code>, <code>AddAfter(obj1, 1)</code>, <code>AddAfter(obj2, 2)</code>……这样就把每秒10次限速到了1秒1次。</p><p>没错，限速队列的实现上就是调用<code>AddAfter</code>。<code>duration</code>的计算靠限速器实现。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *rateLimitingType)</span> <span class="hljs-title">AddRateLimited</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>  <span class="hljs-comment">// 通过限速器获取延迟时间，然后加入到延时队列</span><br>  q.DelayingInterface.AddAfter(item, q.rateLimiter.When(item))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *rateLimitingType)</span> <span class="hljs-title">NumRequeues</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">int</span></span> &#123;<br>  <span class="hljs-keyword">return</span> q.rateLimiter.NumRequeues(item)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *rateLimitingType)</span> <span class="hljs-title">Forget</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>  q.rateLimiter.Forget(item)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以现在重点是猜一下限速器的实现？具体实现，大概会把每秒钟看成一个盒子，只能放一个Add事件。基于这个思路用Python写了一版:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketRateLimiter</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, period, quota</span>):</span><br>        <span class="hljs-comment"># capacity for every bucket</span><br>        self.b_quota = quota<br>        <span class="hljs-comment"># current bucket start postion</span><br>        self.b_pos = self.tick()<br>        <span class="hljs-comment"># current bucket span</span><br>        self.b_span = period<br>        <span class="hljs-comment"># how many items in current bucket</span><br>        self.b_cnt = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tick</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># return fractional seconds</span><br>        <span class="hljs-keyword">return</span> time.monotonic()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc_current_bucket</span>(<span class="hljs-params">self</span>):</span><br>        self.b_cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> self.b_cnt &gt;= self.b_quota:<br>            <span class="hljs-comment"># use next bucket</span><br>            self.new_bucket_at(self.b_pos+self.b_span)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_bucket_at</span>(<span class="hljs-params">self, pos</span>):</span><br>        self.b_pos = pos<br>        self.b_cnt = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">when</span>(<span class="hljs-params">self, _obj</span>):</span><br>        now = time.monotonic()<br>        <span class="hljs-comment"># at any time, we ensure that the current bucket is not full</span><br>        <span class="hljs-comment"># so we can calculate `delay` first</span><br>        delay = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, self.b_pos - now)<br>        <span class="hljs-keyword">if</span> now &gt; self.b_pos + self.b_span:<br>            self.new_bucket_at(now)<br>            self.inc_current_bucket()<br>        <span class="hljs-keyword">else</span>:<br>            self.inc_current_bucket()<br>        <span class="hljs-keyword">return</span> delay<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forget</span>(<span class="hljs-params">self, _obj</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_requeues</span>(<span class="hljs-params">self, _obj</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rate_limiter = BucketRateLimiter(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        print(rate_limiter.when(<span class="hljs-literal">None</span>))<br><br></code></pre></div></td></tr></table></figure><p>看上去效果还行。</p><p>思路是维护<code>period</code>长的<code>bucket</code>窗口，保证当前窗口永远不满，<code>when</code>时计算当前时间和窗口左边缘的距离，得到等待的时间。然后根据当前时间和窗口的位置关系，往窗口添加事件或者新建窗口再添加事件。时间用的<code>monotonic</code>，符合这种只关注时间跨度的场景，而<code>pref_counter</code>精度更高，且忽略线程休眠的时间，没有必要。</p><p>但是重入队列该怎么理解？<code>NumRequeues</code>和<code>Forget</code>有什么用？我是这么猜的，<code>NumRequeues</code>是个只读接口，修改它，必然是靠<code>When</code>来修改。所以限速器内部会有一个字典结构，对每个对象<code>When</code>一下，就把该对象的<code>NumRequeues+1</code>，重入队列就是字面意义上的对相同对象调用多次<code>AddRateLimited</code>，这个动作就是重试，这是用户发起的，并不是限速队列帮你重试。<code>NumRequeues</code>的值越大，限速器就会把该对象入队列的时间越往后延，等于说限速器帮你实现重试时间backoff的逻辑。而<code>Forget</code>就是忘记该对象的重试历史，重置backoff的时间序列。</p><p>共有如下几个限速器的具体实现： </p><ul><li>BucketRateLimiter </li><li>ItemBucketRateLimiter</li><li>ItemExponentialFailureRateLimiter</li><li>ItemFastSlowRateLimiter</li><li>MaxOfRateLimiter</li></ul><p>前三个，看名字也差不多能猜到是什么了。具体说明：</p><table><thead><tr><th>限速器</th><th>说明</th></tr></thead><tbody><tr><td>BucketRateLimiter</td><td>无视对象身份的速率限制(就是我的Python版本)</td></tr><tr><td>ItemBucketRateLimiter</td><td>对每个对象使用一个BucketRateLimiter，限制每个对象的插入速率</td></tr><tr><td>ItemExponentialFailureRateLimiter</td><td>对每个重试项的指数型backoff控制，backoff = min(base * 2 ^ times, max_delay)，实现上要注意防止指数计算溢出</td></tr><tr><td>ItemFastSlowRateLimiter</td><td>对每个重试项的阶跃型backoff控制，backoff = fast_delay  if times &lt; n else slow_delay</td></tr><tr><td>MaxOfRateLimiter</td><td>聚合类型，包装其他Limiter，从中取最长的等待时间，最大重试次数</td></tr></tbody></table><p>其中BucketRateLimiter是基于 “<a href="https://godoc.org/golang.org/x/time/rate">golang.org/x/time/rate</a>“ 实现的。</p><p>看了一下，使用的是名为令牌桶的方案。思路是维护一个容量为quota的桶，每秒往桶里放入n个token，如果满了就不放置。消费者从桶里拿token，拿到表示允许事件发生，拿不到就阻塞或者返回需要等待的时间。</p><p>关键动作是：</p><p><code>ReserveN(time time.Time, n int)</code></p><p>表示从time时间点(一般传入当前时间)<strong>预定</strong>n个token，需要等待多长时间。</p><p><code>n &gt; quota</code>等待时间就是无限长。返回的是一个名为<code>Reservation</code>的结构r，r.Delay()可查询等待的时间，ok查询是否<code>n &gt; quota</code>。该结构一返回，就表示n个token被消费的事实。</p><p>在<code>ReserveN</code>的基础上，就可以派生出其他行为</p><table><thead><tr><th>接口</th><th>等效</th><th>用途</th></tr></thead><tbody><tr><td>Reserve()</td><td>ReserveN(now, 1)</td><td>得到时间，自由调度</td></tr><tr><td>Allow()</td><td>AllowN(now, 1) = Reserve(now,  1).ok</td><td>用于高峰直接丢弃过多的请求</td></tr><tr><td>Wait(context)</td><td>WaitN(context, 1) = 阻塞时长Reserve().Delay()</td><td>主动等待，尽量不丢失请求</td></tr></tbody></table><p>所以使用rate提供的limiter来实现<code>BucketRateLimiter</code>，就是在<code>When</code>时调用<code>Reserve().Delay()</code>，源码就是这样搞的:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *BucketRateLimiter)</span> <span class="hljs-title">When</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span> &#123;<br>  <span class="hljs-keyword">return</span> r.Limiter.Reserve().Delay()<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul><li><p>限速队列，就是通过把操作延时到未来发生，控制后得到某条事件发生曲线，平稳限速或者实现重试时间backoff的指数增长</p></li><li><p>我猜的限时器实现使用的滑动窗口，go中rate的方案果然更工程化，接口更丰富，更灵活，适用场景更多</p></li></ul><p>至此，三个队列都学习完了，对我这种菜鸡，收获感还是很足</p><p><strong>普通队列 （保证相同对象不会被不同消费者处理、Get+Done的接口组合） -&gt;</strong> </p><p><strong>延时队列 （引入优先队列，高效地协程唤醒策略，基于Add实现AddAfter） -&gt;</strong> </p><p><strong>限速队列 （引入限速器，自动分配延长时间，基于AddAfter实现AddRateLimit)</strong></p><p>分层的设计，复用下层实现，附加电池，创造了更多功能，不愧是你啊阿谷😍</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Go</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go工作队列学习(二) - 延时队列</title>
    <link href="/2020/03/20/work-queue-delay/"/>
    <url>/2020/03/20/work-queue-delay/</url>
    
    <content type="html"><![CDATA[<p>第二篇，延时队列: 想进去排队啊？等着</p><a id="more"></a><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DelayingInterface <span class="hljs-keyword">interface</span> &#123;<br>  Interface                     <span class="hljs-comment">// 继承了通用队列所有接口          </span><br>  AddAfter(item <span class="hljs-keyword">interface</span>&#123;&#125;, duration time.Duration) <span class="hljs-comment">// 增加了延迟添加的接口</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>从接口定义看，猜测是元素在duration之后的再加入队列，那维护一个优先队列，设定线程timer，轮询队列头元素是否满足加入队列的绝对时间条件，满足就直接调用通用队列的Add？哎呀终于猜对了一把方向。</p><p>下面是实现用的结构：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> delayingType <span class="hljs-keyword">struct</span> &#123;<br>  Interface                    <span class="hljs-comment">// 组合通用队列实现</span><br>  clock clock.Clock            <span class="hljs-comment">// 时钟，用于获取时间</span><br>  stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// 优先队列的协程需要退出信号</span><br>  stopOnce sync.Once           <span class="hljs-comment">// 向优先队列协程发送关闭信号只能发一次</span><br>  heartbeat clock.Ticker       <span class="hljs-comment">// 定时器，定时唤醒处理协程去看队列头是否满足插入时间</span><br>  waitingForAddCh <span class="hljs-keyword">chan</span> *waitFor <span class="hljs-comment">// 所有延迟添加的元素封装成waitFor放到chan中</span><br>  metrics retryMetrics         <span class="hljs-comment">// 和通用队列中的metrics功能类似</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>waitFor就是要放入优先队列中的元素结构</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitFor <span class="hljs-keyword">struct</span> &#123;<br>  data  t             <span class="hljs-comment">// 元素数据，这个t就是在通用队列中定义的类型interface&#123;&#125;</span><br>  readyAt time.Time   <span class="hljs-comment">// 插入动作生效的绝对时间</span><br>  index <span class="hljs-keyword">int</span>           <span class="hljs-comment">// 指示这个元素在优先队列中的位置，用来调整在队列中的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然允许多次调用关闭，但在stopOnce的作用下只会关闭一次。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 只关闭一次</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *delayingType)</span> <span class="hljs-title">ShutDown</span><span class="hljs-params">()</span></span> &#123;<br>  q.stopOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    q.Interface.ShutDown()<br>    <span class="hljs-built_in">close</span>(q.stopCh)<br>    q.heartbeat.Stop()<br>  &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><code>AddAfter</code>长这样，逻辑足够简单了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *delayingType)</span> <span class="hljs-title">AddAfter</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;, duration time.Duration)</span></span> &#123;<br><br>  <span class="hljs-comment">// don&#x27;t add if we&#x27;re already shutting down</span><br>  <span class="hljs-keyword">if</span> q.ShuttingDown() &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  q.metrics.retry()<br>  <span class="hljs-comment">// immediately add things with no delay</span><br>  <span class="hljs-keyword">if</span> duration &lt;= <span class="hljs-number">0</span> &#123;<br>    q.Add(item)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;-q.stopCh:<br>    <span class="hljs-comment">// unblock if ShutDown() is called</span><br>    <span class="hljs-comment">// 可以从stopCh中读出，说明关闭事件发生，直接跳过后面的添加</span><br>  <span class="hljs-keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;:<br>    <span class="hljs-comment">// 向优先队列发送waitFor</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是关于优先队列的逻辑，还是有太多我想不到的优化。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// waitingLoop runs until the workqueue is shutdown and</span><br><span class="hljs-comment">// keeps a check on the list of items to be added.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *delayingType)</span> <span class="hljs-title">waitingLoop</span><span class="hljs-params">()</span></span> &#123;<br><br>  <span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><br>  <span class="hljs-comment">// Make a placeholder channel to use when there are no items in our list</span><br>  <span class="hljs-comment">// 队列中没有元素时，这个watiloop实际上不用醒来，这里的具体做法就是创建一个永远不会有输入的chan，</span><br>  <span class="hljs-comment">// select就永远睡去了</span><br>  never := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> time.Time) <br><br>  <span class="hljs-comment">// Make a timer that expires when the item at the head of the waiting queue is ready</span><br>  <span class="hljs-comment">// 假如，队列中第一个事件开始于4min后，而且期间新元素插入，waitloop应该4min之后再醒来执行事件</span><br>  <span class="hljs-keyword">var</span> nextReadyAtTimer clock.Timer<br><br>  <span class="hljs-comment">// 初始化优先队列</span><br>  waitingForQueue := &amp;waitForPriorityQueue&#123;&#125;<br>  heap.Init(waitingForQueue)<br><br><br><span class="hljs-comment">// t是对象，队列要维护对象的身份，相同对象插入时，仅更新时间，不要重复插入</span><br>  waitingEntryByData := <span class="hljs-keyword">map</span>[t]*waitFor&#123;&#125;<br><br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> q.Interface.ShuttingDown() &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    now := q.clock.Now()<br>      <br>    <span class="hljs-comment">// Add ready entries</span><br><span class="hljs-comment">// 醒来了，开始干活，队列中有对象</span><br>    <span class="hljs-keyword">for</span> waitingForQueue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>      entry := waitingForQueue.Peek().(*waitFor)<br>      <span class="hljs-keyword">if</span> entry.readyAt.After(now) &#123;<br>        <span class="hljs-keyword">break</span> <span class="hljs-comment">// 后面的对象都不会生效了，跳出处理</span><br>      &#125;<br><br>  <span class="hljs-comment">// 满足生效时间，弹出对象，插入下层队列</span><br>      entry = heap.Pop(waitingForQueue).(*waitFor)<br>      q.Add(entry.data)<br>      <span class="hljs-comment">// 去重用的map中删除</span><br>      <span class="hljs-built_in">delete</span>(waitingEntryByData, entry.data)<br>    &#125;<br> <br>    <span class="hljs-comment">// Set up a wait for the first item&#x27;s readyAt (if one exists)</span><br>    <span class="hljs-comment">// 经过上步，生效的对象都插入队列了，看距离下一次生效要多长时间，先假设队列已空，无限长</span><br>    nextReadyAt := never<br><br>    <span class="hljs-keyword">if</span> waitingForQueue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">if</span> nextReadyAtTimer != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 新插入的元素生效时间可能更短，取消之前的timer</span><br>        nextReadyAtTimer.Stop()<br>      &#125;<br><br>      entry := waitingForQueue.Peek().(*waitFor)<br>      nextReadyAtTimer = q.clock.NewTimer(entry.readyAt.Sub(now))<br>      nextReadyAt = nextReadyAtTimer.C()<br>    &#125;<br><br>    <span class="hljs-keyword">select</span> &#123;<br><br>    <span class="hljs-keyword">case</span> &lt;-q.stopCh:<br>      <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">case</span> &lt;-q.heartbeat.C():<br>      <span class="hljs-comment">// continue the loop, which will add ready items</span><br>  <span class="hljs-comment">// 理论上这个没用，保险一下，跳出select，去到上面的处理流程，尝试去添加生效的事件</span><br><br>    <span class="hljs-keyword">case</span> &lt;-nextReadyAt:<br>      <span class="hljs-comment">// continue the loop, which will add ready items</span><br>      <span class="hljs-comment">// 之前设置的队列头部事件设里的timer，此时第一个事件应该生效了</span><br><br>    <span class="hljs-keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:<br><br>  <span class="hljs-comment">// AddAfter被调用啦，新加入元素</span><br>      <span class="hljs-keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;<br>        insert(waitingForQueue, waitingEntryByData, waitEntry)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        q.Add(waitEntry.data)<br>      &#125;<br><br><br>      <span class="hljs-comment">// 把chan中可用的entry一次性处理完</span><br>      drained := <span class="hljs-literal">false</span><br>      <span class="hljs-keyword">for</span> !drained &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:<br>          <span class="hljs-keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;<br>            insert(waitingForQueue, waitingEntryByData, waitEntry)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.Add(waitEntry.data)<br>          &#125;<br>        <span class="hljs-keyword">default</span>:<br>          drained = <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 插入优先队列</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(q waitForPriorityQueue, knownEntries <span class="hljs-keyword">map</span>[t]waitFor, entry *waitFor)</span></span> &#123;<br>  <span class="hljs-comment">// if the entry already exists, update the time only if it would cause the item to be queued sooner</span><br>  <span class="hljs-comment">// 已在队列中，并且生效时间提前，更新时间。Heap.Fix，大概相当于swim和sink吧</span><br>  existing, exists := knownEntries[entry.data]<br>  <span class="hljs-keyword">if</span> exists &#123;<br>    <span class="hljs-keyword">if</span> existing.readyAt.After(entry.readyAt) &#123;<br>      existing.readyAt = entry.readyAt<br>      heap.Fix(q, existing.index)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  heap.Push(q, entry)<br>  knownEntries[entry.data] = entry<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul><li><p>优先队列的检查，并不是依靠无差别的heartbeat做的。每次插入时会检查，没有插入时，检查队列头，确定最近事件的发生，调整timer时机，避免loop无意义地醒来，性能更好。</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">+--------------------------------------+<br>|                                      |<br>|                              +------------------+<br>|                              |  Add all ready   |<br>|                              | elements in pq   | <br>|                              | by loop          |<br>|                              +------------------+<br>|                                      |<br>|                                      |<br>|                              +------------------+<br>|                              | set `nextReadyAt`|<br>|                              | according to the |<br>|                              | head of pq       |<br>|                              +------------------+<br>|                                      |<br>|                                      | select on!<br>|                                      |<br>|             +------------------------+-----------------+-------------+<br>|             |                        |                 |             |<br>|        waitingForAdd             heartbeat        nextReadyAt     stopCh<br>|             |                        |                 |             |<br>|    +------------------+              |                 |             |<br>|    | insert into pq   |              |                 |             |<br>|    | or change val    |              |                 |             |<br>|    | in pq by loop    |              |                 |             |<br>|    +------------------+              |                 |             | break!<br>|             |                        |                 |             |<br>|             +------------------------+-----------------+             |<br>|                                      |                               |<br>+--------------------------------------+                               v<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>而误解的heartbeat，实际上是工程上的保险，时间隔为10s(maxWait)，其注释写道：</p><blockquote><p>// maxWait keeps a max bound on the wait time. It’s <strong>just insurance against weird things happening</strong>.  Checking the queue every 10 seconds <strong>isn’t expensive</strong> and we know that we’ll never end up with an expired item sitting for more than 10 seconds.</p></blockquote></li><li><p>队列元素的修改，重排，Go可以使用Fix，这也太实诚了。虽然大家都是通过数组实现的优先队列，但是学院派一点，都说自己不保证底层的实现方式，你只能用push和pop接口，不支持修改，支持修改的应该是额外的数据结构。Python里面没有对应的接口，但是可以用内部函数冒充一下，而Rust中也有siftup等，但是私有方法用不了</p></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heapfix</span>(<span class="hljs-params">heap, idx</span>):</span><br>    <span class="hljs-keyword">if</span> idx &gt;= <span class="hljs-built_in">len</span>(heap):<br>        <span class="hljs-keyword">raise</span> IndexError<br>    heapq._siftdown(heap, <span class="hljs-number">0</span>, idx)  <span class="hljs-comment"># try swimming to tree top</span><br>    heapq._siftup(heap, idx)       <span class="hljs-comment"># try sinking to tree leaf</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_fix</span>():</span><br>    heap = [randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>)]<br>    heapify(heap)<br>    idx, val = randint(<span class="hljs-number">0</span>,<span class="hljs-number">49</span>), randint(-<span class="hljs-number">20</span>, <span class="hljs-number">120</span>)<br>    heap[idx] = val<br>    heapfix(heap, idx)<br>    pop_order = [heappop(heap) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(heap))]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(x &lt;= y <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pop_order, pop_order[<span class="hljs-number">1</span>:]))<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Go</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go工作队列学习(一) - 普通队列</title>
    <link href="/2020/03/20/work-queue-normal/"/>
    <url>/2020/03/20/work-queue-normal/</url>
    
    <content type="html"><![CDATA[<p>第一篇，普通队列: 影分身的忍者队列，换个马甲照样认识你</p><a id="more"></a><p>队列作为解耦上下游强依赖关系的常见工具，为应对不同的场景，也诞生了不同的定制化。</p><p>K8s中client-go中的工作队列有三种：普通队列、延时队列、限速队列。分层依赖的关系。</p><p>每个队列我都会用单独的一篇文章记录。这个系列的主要参考是<a href="https://blog.csdn.net/weixin_42663840/article/details/81482553">大佬的博客</a>，会加上我自己的一些理解和补充。这些理解甚至包括，学习过程中我自己对一些设计的猜测，这些猜测甚至是错误的🙃，小心阅读。</p><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><p>先看普通的队列的接口</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// client-go/util/workqueue/queue.go</span><br><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>  Add(item <span class="hljs-keyword">interface</span>&#123;&#125;)       <span class="hljs-comment">// 向队列中添加一个元素，interface&#123;&#125;类型，说明可以添加任何类型的元素</span><br>  Len() <span class="hljs-keyword">int</span>                   <span class="hljs-comment">// 元素的个数</span><br>  Get() (item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-keyword">bool</span>) <span class="hljs-comment">// 从队列中获取一个元素，第二个返回值告知队列是否已经关闭</span><br>  Done(item <span class="hljs-keyword">interface</span>&#123;&#125;)         <span class="hljs-comment">// 告知队列该元素已经处理完了</span><br>  ShutDown()                    <span class="hljs-comment">// 关闭队列</span><br>  ShuttingDown() <span class="hljs-keyword">bool</span>           <span class="hljs-comment">// 查询队列是否正在关闭</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>和传统的队列有一个不同，传统队列的接口时是push and pop，但这里pop换成了Get，Get时并不会从队列中删除该元素，而是要显示调用Done之后，才从队列中删除。</p><p>我猜这是给处理失败留下了空间。如果直接弹出，而线程处理崩溃，这个任务就永远消失了。所以要让处理逻辑显示通知队列删除该任务。</p><p>因此：</p><ol><li>一个任务被处理逻辑认领处理，而未commit时，应该将该项任务做标记，避免其他逻辑前来认领。</li><li>还有记录超时的结构，让久未确认的任务重新回到队列。</li></ol><p>然后看队列实现时用了什么字段：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// client-go/util/workqueue/queue.go</span><br><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>  queue []t       <span class="hljs-comment">// 元素数组</span><br>  dirty set       <span class="hljs-comment">// dirty的元素集合</span><br>  processing set     <span class="hljs-comment">// 正在处理的元素集合</span><br>  cond *sync.Cond    <span class="hljs-comment">// 自带互斥锁的条件变量</span><br>  shuttingDown <span class="hljs-keyword">bool</span>   <span class="hljs-comment">// 关闭标记</span><br>  metrics queueMetrics  <span class="hljs-comment">// prometheus的metrics概念相同*</span><br>&#125;<br><br><span class="hljs-comment">// 以下的这些类型定义为了用map凹出一个set类型，等用于python的set和Rust的HashSet</span><br><span class="hljs-keyword">type</span> empty <span class="hljs-keyword">struct</span>&#123;&#125;    <span class="hljs-comment">// 空类型，因为sizeof(struct&#123;&#125;)=0</span><br><span class="hljs-keyword">type</span> t <span class="hljs-keyword">interface</span>&#123;&#125;     <span class="hljs-comment">// 任意元素类型</span><br><span class="hljs-keyword">type</span> set <span class="hljs-keyword">map</span>[t]empty   <span class="hljs-comment">// 用map实现的set</span><br><br></code></pre></div></td></tr></table></figure><blockquote><p>现去看了看 Prometheus 的 metrics 概念。<br>metrics 是时间序列数值，单点的数据模型是:<br><code>&lt;metric_name&gt;&#123;label1: A, label2: B&#125;=3.1415926 &amp; timestamp=123443242352</code><br>可以根据 label 新建分析维度。按照时间序列上的属性变动，可以分为单调递增的 Counter，任意波动的 Gauge，按时间段统计的 Hist，Summary 等等。<br>所以这里的 metrics 应该是某种统计类型，调用接口来生成一个单点数据，供 Prometheus 拉取。</p></blockquote><p>看这个结构，猜一下实现：</p><ul><li><p>queue保证出入顺序</p></li><li><p>processing是被认领但未提交的任务</p></li><li><p>条件变量来维持线程同步，比如队列为空时阻塞消费线程</p></li><li><p>shuttingdown标记，ShutDown将该标记值为True，之后不再接受新任务，但是可以继续被消费。</p></li></ul><p>可是dirty是什么呢？没有维护超时的结构吗？</p><p>再看具体实现：<br><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span> <span class="hljs-title">Add</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>  <span class="hljs-comment">// 条件变量自带了与之搭配的互斥锁，L</span><br>  q.cond.L.Lock()<br><br>  <span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><br>  <span class="hljs-comment">// 队列正在关闭，拒绝一切新输入</span><br>  <span class="hljs-keyword">if</span> q.shuttingDown &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 去重，dirty为queue的set，正在queue中还未处理，就丢弃</span><br>  <span class="hljs-keyword">if</span> q.dirty.has(item) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 告知metrics添加了元素</span><br>  q.metrics.add(item)<br><br>  <span class="hljs-comment">// 添加到脏数据集合中</span><br>  q.dirty.insert(item)<br><br>  <span class="hljs-comment">// 元素刚被拿走处理，那就直接返回</span><br>  <span class="hljs-keyword">if</span> q.processing.has(item) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 追加到元素数组的尾部，没有大小限制，是无界队列</span><br>  q.queue = <span class="hljs-built_in">append</span>(q.queue, item)<br><br>  <span class="hljs-comment">// 通知有新元素到了，此时有协程阻塞就会被唤醒</span><br>  q.cond.Signal()<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><p>反正我是看蒙了，为什么相同元素就不入队列？每个新元素都会先进入dirty，然后用dirty来去重？</p><p>感觉这里要把自己以前的认识打碎，现在这个队列是面向应用场景的队列，需要从业务层面判断是否重复，比如这里就是K8s的的api对象。书本上的队列，都是没有业务概念的，每个push的对象都看作不同。</p><p>dirty大多数情况下，是queue的set版本，但是注意<code>dirty.insert</code>和<code>queue.append</code>并不是完全同步，中间被检查processing隔断：当对象正在被处理，期间又Add相同的对象，只会进入dirty而不会进入queue，多的这一份，会在Done时，检查dirty，补充加入queue。<strong>这个处理方式，保证的是正在处理的对象，一定不会出现在queue中。换句话说，同一个对象，不会被被两个逻辑流同时处理</strong>。普通实现这个保证，只要把dirty完全做成queue的set版本就可以，也就是把Add中的检查processing提前到dirty insert之前。这样，处理期间到来的对象会被拒绝，只有处理完成后，才能接受该对象的新版本。而当前实现，凡是在开始处理后加入的相同对象，就会被记录，并在处理完成后立即加入queue。窗口变大了，但是不知道为什么要这么做？</p><p>一个典型的过程描述如下：</p><table><thead><tr><th>命令</th><th>dirty</th><th>processing</th><th>queue</th><th>备注</th></tr></thead><tbody><tr><td>Add 1</td><td>{1}</td><td>{}</td><td>[1]</td><td></td></tr><tr><td>Add 2</td><td>{1, 2}</td><td>{}</td><td>[1, 2]</td><td></td></tr><tr><td>Add 1</td><td>{1, 2}</td><td>{}</td><td>[1, 2]</td><td></td></tr><tr><td>GET</td><td>{2}</td><td>{1}</td><td>[2]</td><td></td></tr><tr><td>Add 1</td><td>{1, 2}</td><td>{1}</td><td>[2]</td><td>dirty中的1就是处理期间到来的新版本</td></tr><tr><td>Done 1</td><td>{1, 2}</td><td>{}</td><td>[2, 1]</td><td>从dirty中拿出处理期间得到的新对象</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span> <span class="hljs-title">Done</span><span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>  q.cond.L.Lock()<br>  <span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><br>  q.metrics.done(item)<br>  q.processing.<span class="hljs-built_in">delete</span>(item)<br><br>  <span class="hljs-comment">// 此处判断脏元素集合，看看处理期间是不是又被添加，如果是那就在放到队列中</span><br>  <span class="hljs-keyword">if</span> q.dirty.has(item) &#123;<br>    q.queue = <span class="hljs-built_in">append</span>(q.queue, item)<br>    q.cond.Signal()<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-params">(item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>  q.cond.L.Lock()<br>  <span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><br>  <span class="hljs-comment">// 没有数据，阻塞协程</span><br>  <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.queue) == <span class="hljs-number">0</span> &amp;&amp; !q.shuttingDown &#123;<br>    q.cond.Wait()<br>  &#125;<br><br>  <span class="hljs-comment">// 协程被激活但还没有数据，说明队列被关闭了</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.queue) == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span><br>  &#125;<br> <br>  <span class="hljs-comment">// 弹出第一个元素</span><br>  item, q.queue = q.queue[<span class="hljs-number">0</span>], q.queue[<span class="hljs-number">1</span>:]<br>  q.metrics.get(item)<br><br>  <span class="hljs-comment">// 从dirty集合中移除，加入到processing集合</span><br>  q.processing.insert(item)<br>  q.dirty.<span class="hljs-built_in">delete</span>(item)<br>  <span class="hljs-keyword">return</span> item, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span> <span class="hljs-title">ShutDown</span><span class="hljs-params">()</span></span> &#123;<br>  q.cond.L.Lock()<br>  <span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><br>  q.shuttingDown = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// 关闭时通知全部可能阻塞的携程，起来后发现queue为0就自己退出</span><br>  q.cond.Broadcast()<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul><li>无界队列，条件变量阻塞消费者</li><li><strong>队列元素有对象身份的概念</strong>，在一个时间，<strong>同一个对象只能被一个消费者处理</strong>，一个对象，要么在processing中，要么在queue中，这个这个队列的独特性质。</li><li>通过dirty和queue的差异，提前记录处理过程中出现的相同对象，处理完成后加入queue，此时processing和dirty中有重复对象</li><li>最后也没有出现超时的处理。所以Get+Done的作用应该不是像我猜的那样，为了消费者崩溃，自动超时并重入队列，而就要是维持第二点的性质——如果没有调用Done，对象就一直存在于processing集合中，这个队列不会再分配其他对象。否则，没有processing的状态，就可能把相同对象分配到另外的消费者里。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Go</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的垃圾回收梗概</title>
    <link href="/2020/02/05/pygc/"/>
    <url>/2020/02/05/pygc/</url>
    
    <content type="html"><![CDATA[<p>If there’s no one left in the living world to remember you, you disappear from this world.</p><p>​                                                                        ——Moive <em>Coco</em></p><a id="more"></a><h1 id="REFCNT"><a href="#REFCNT" class="headerlink" title="REFCNT"></a>REFCNT</h1><p>引用计数基于一个朴素的想法，一块内存，如果没有引用指向它，就不可达，不能再被访问，因此可以被释放回收。</p><p>有什么优势？</p><p>实时性。不用等到某个特殊的时刻，内存对象一旦引用为0就销毁。相对于一些集中进行垃圾检测、并回收的方案，引用计数把内存管理的花费分摊到运行时，程序更平稳一些。</p><p>有什么劣势？</p><ol><li>额外的时间和空间的开销。伴随内存对象的创建，都需要维护的refcnt字段，并作相应的加减判断运算。一个有意思的场景是，对一些大量快速创建并自毁的对象来说，如果其生存周期处在非实时gc方案的两次收集之间，gc根本就不曾知道这些对象存在过，没有多余的开销；但对实时的引用计数，每个对象都得管理其引用计数。Python内部为了提高内存对象创建的效率，采用了建立对象池的方案。int、str、dict、list都建立相应的对象池。</li><li>不可达的循环引用。存在循环引用的对象，即使外部已经不存在对它的引用，无法访问到，它还是会因为引用计数大于0而无法回收。这是引用计数无解的死穴，必须通过其他方法来消除。</li></ol><p>以整型42为例：</p><p>引用何处增加？</p><ul><li>被赋值，a = 42，+1</li><li>添加新引用，b = a，+1</li><li>当作参数传入函数<code>is_anwser(candidate=a)</code>，+2(candidate一次新引用，frame的栈上一次)</li><li>加入容器，<code>answers.apend(a)</code> ，+1</li></ul><p>引用何处减少？</p><ul><li>del语句，<code>del a</code>，显示切断名字a和内存对象42的引用联系</li><li>出离作用域。is_answer函数调用完成后，42的引用个数会减2。实际上，大部分内存回收都因为这个</li><li>从容器删除，<code>answers.pop()</code></li></ul><h1 id="分代标记-清除"><a href="#分代标记-清除" class="headerlink" title="分代标记-清除"></a>分代标记-清除</h1><p>分代的标记-清除，就是用来消除循环引用问题的。</p><p>因此，先明确分代标记-清除的定位，它是引用计数方案的补充，专门用于清除存在不可达的循环引用对象。</p><p>行为上，分代标记-清除，在特定时刻被调用，首先探测不可达的循环引用对象，然后将这些对象的refcnt强行置为0，引发引用计数方案的回收动作，从而释放内存</p><p>所以核心问题，怎么探测到不可达的循环引用对象？</p><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>想要构成循环引用，只能是容器，list、dict、instance、tuple之类的，所以python用双向链表来组织运行过程中建立的容器对象</p><p>如下图，黑色表示实际的引用关系，黄色双向箭头表示双向链表组织。希望标记出链表末尾的不可达循环引用对象，一个做法是，遍历元素，把元素的指向的子元素的refcnt减1，形成<strong>有效计数</strong>，因为如果有效计数还大于1，说明它是存在外部引用的可达对象，即root object，那么他们的子元素也是可达对象。</p><p><img src="https://s2.ax1x.com/2019/02/14/kB0eLq.png" alt="kB0eLq.png"></p><p>首先先做一个refcnt的备份，然后在备份上计算出有效计数</p><p><img src="https://s2.ax1x.com/2019/02/14/kB00YD.png" alt="kB00YD.png"></p><p>然后根据有效计数将链表分为reachable和unreachable两个链表。既然这里已经求出有效计数， 引用还大于0的，就是引用入口，最直观的做法就是从它开始dfs，设置标志，没有访问到的则是需要清理的不可达的对象。</p><!--但是CPython的实现形式稍有不同，具体细节参见在[源码](https://github.com/python/cpython/blob/3.7/Modules/gcmodule.c#L354)， 大致的流程是这样：<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 遍历列表元素，如果有效计数为0，可能是不可达的，也可能引用它的容器在链表后面，</span><br><span class="hljs-comment"># 此时暂时标记为tentatively-unreachable，放入unreachable链表；</span><br><span class="hljs-comment"># 如果有效计数大于0，说明是一个可达对象，不需要回收，遍历它的子元素，</span><br><span class="hljs-comment">#   子元素如果为0，gc_refs设为1，表明可达身份，</span><br><span class="hljs-comment">#   如果发现被标注了tentatively-unreachable，gc_refs设为1，并且从unreachable链表中拿出。</span><br><br>gc = young.<span class="hljs-built_in">next</span><br><span class="hljs-keyword">while</span> gc != young:<br>    <span class="hljs-keyword">if</span> obj.gc_refs == <span class="hljs-number">0</span>:<br>        obj.gc_refs = -<span class="hljs-number">4</span> <span class="hljs-comment"># &quot;tentatively_unreachable&quot;</span><br>        put_to(obj, unreachable)<br>    <span class="hljs-keyword">elif</span> obj.gc_refs &gt; <span class="hljs-number">0</span>:<br>        obj.gc_refs = -<span class="hljs-number">3</span> <span class="hljs-comment"># &quot;reachable&quot;</span><br>        <span class="hljs-keyword">for</span> inner_obj <span class="hljs-keyword">in</span> obj.refs:<br>            <span class="hljs-keyword">if</span> inner_obj.gc_refs == <span class="hljs-number">0</span>:<br>                inner_obj.gc_refs = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> inner_obj.gc_refs == -<span class="hljs-number">4</span>:<br>                inner_obj.gc_refs = <span class="hljs-number">1</span><br>                put_to(inner_obj, linked_list)<br> gc = gc.<span class="hljs-built_in">next</span><br></code></pre></div></td></tr></table></figure><p>–&gt;</p><h2 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h2><p>没有经过更精细的处理时，标记操作和容器对象数量成正比。但是统计发现，程序运行也存在马太效应，存活得久的对象，越有可能一直存在，被释放回收的概率更低。因此分了0，1，2三代，代数越高，表示对象获得更长，活得长的对象就可以减少扫描标记的次数。</p><p>因此，在标记-清除的原理之上，现在维护三个双向链表。每新建一个容器，添加到0代链表，当0代链表添加动作超过700，触发一次垃圾回收。但是并不是每次垃圾收集都是从0代发起的，这样就没办法扫描1代或2代中的内容了。因此触发动作一次开始会从最高代开始查看，是否超过其触发阈值(2代1代均为10次)，如果超过，就从超过阈值的最高代发起垃圾回收，具体的标识工作开始前，还会把更年轻代的链表合并到发起收集的这代链表上。标记完成后，把可达对象链表合并到发起收集链表的更高一代。</p><h1 id="关于PEP442：-del-陷阱"><a href="#关于PEP442：-del-陷阱" class="headerlink" title="关于PEP442：__del__陷阱"></a>关于PEP442：__del__陷阱</h1><p>在完成可达和不可达对象的标识之后，就应该按照unreachable一个个进行真正的销毁：减少他们的ob_refcnt，触发引用计数为0造成的内存回收。</p><p>但是，这其中有一个特殊的，就是具有__del__的instance。当引用计数销毁他们时，会主动调用__del__，那么如果引用、循环引用等本来就发生在del中，错误的销毁就会造成一些问题。3.4之前，Python就非常保守地选择了不销毁这些特殊容器，单独放到gc模块的garbage中，由用户自己控制。</p><p>在3.4里，<a href="https://www.python.org/dev/peps/pep-0442/">PEP442</a>提出了一个方案，不要等着引用计数为0来触发__del__，可以先进行__del__的调用，然后再检查一遍unreachable，如果发生了resurrection，就中止这次回收</p> <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><span class="hljs-keyword">import</span> time<br>global_list = []<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfCycle</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>self.p = self<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>print(<span class="hljs-string">&quot;resurrect&quot;</span>)<br>global_list.append(self) <span class="hljs-comment"># 在del中把自己变成了可达对象，所以发生了resurrection</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfCycleI</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>self.p = self<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>print(<span class="hljs-string">&quot;del from I&quot;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfCycleII</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>self.p = self<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>print(<span class="hljs-string">&quot;del from II&quot;</span>)<br><br>gc.set_debug(gc.DEBUG_SAVEALL)<br>SelfCycle()<br>SelfCycleI()<br>SelfCycleII()<br>gc.collect()      <span class="hljs-comment"># 打印resurrect    del from I    del from II</span><br><span class="hljs-comment"># 这次收集时发生了resurrection，所以garbage为空</span><br>print([obj <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> gc.garbage <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;SelfCycle&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(obj)]) <br>gc.collect()<br><span class="hljs-comment"># 这次收集没有resurrection，所以garbage出现了SelfCycleI和SelfCycleII</span><br>print([obj <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> gc.garbage <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;SelfCycle&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(obj)])<br><br><span class="hljs-keyword">del</span> global_list<br>gc.collect()<br><span class="hljs-comment"># 连SelfCycle都出现了，说明del没有被调用，直接销毁</span><br>print([obj <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> gc.garbage <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;SelfCycle&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(obj)])<br>time.sleep(<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># -----output-------</span><br>resurrect<br><span class="hljs-keyword">del</span> <span class="hljs-keyword">from</span> I<br><span class="hljs-keyword">del</span> <span class="hljs-keyword">from</span> II<br>[]<br>[&lt;__main__.SelfCycleI <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691240</span>&gt;, &#123;<span class="hljs-string">&#x27;p&#x27;</span>: &lt;__main__.SelfCycleI <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691240</span>&gt;&#125;, &lt;__main__.SelfCycleII <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691278</span>&gt;, &#123;<span class="hljs-string">&#x27;p&#x27;</span>: &lt;__main__.SelfCycleII <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691278</span>&gt;&#125;]<br>[&lt;__main__.SelfCycleI <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691240</span>&gt;, &#123;<span class="hljs-string">&#x27;p&#x27;</span>: &lt;__main__.SelfCycleI <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691240</span>&gt;&#125;, &lt;__main__.SelfCycleII <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691278</span>&gt;, &#123;<span class="hljs-string">&#x27;p&#x27;</span>: &lt;__main__.SelfCycleII <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691278</span>&gt;&#125;, &lt;__main__.SelfCycle <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691208</span>&gt;, &#123;<span class="hljs-string">&#x27;p&#x27;</span>: &lt;__main__.SelfCycle <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000002AB0B691208</span>&gt;&#125;]<br><br></code></pre></div></td></tr></table></figure><p>关于这里的东西，需要联系<a href="https://docs.python.org/3/reference/datamodel.html#object.__del__">data modal文档</a>和这篇<a href="https://code.activestate.com/lists/python-dev/137698/">邮件通讯</a>来看更能理解</p><p>文档有三个点值得注意：</p><ol><li>del语法只是摘除名字对内存对象的引用，并不一定调用__del__</li><li>一个鲜活的循环引用的例子，捕获异常( A common cause of reference cycles is when an exception has been caught in a local variable. The frame’s locals then reference the exception, which references its own traceback, which references the locals of all frames caught in the traceback.)</li><li>Cpython的实现保证__del__只调用一次</li></ol><p>第一点是正视听，<code>__del__</code>只有回收发生时才会调用。</p><p>第二点注意是因为之前看过一个观点，为了性能可以关闭gc，但要小心写代码不要产生循环依赖，看了第二点，我觉得这个说法非常不现实，不如说成手动调用gc且不故意引入循环依赖。关闭gc后，普通的，不经意的循环引用很容易出现，每个都要甄别，你还不如把瓶颈功能换其他语言重写算了。</p><p>第三点是和邮件通讯中的一个问题呼应——</p><p>通讯有两个点值得注意：</p><ol><li>保留tp-del新增tp-finalize是为了向后兼容</li><li><code>__del__</code>只调用一次(exactly once)只对被gc监控的对象有效。最后的结论是文档并不严谨</li></ol><p>第一点说明，3.4之后绝大多数情况下gc.garbage都是空的，因为__del__会被赋予一个新的tp_finalizer标识从而被新的逻辑处理回收掉。除非使用C-Python混合编程创建了tp_del不为空的对象</p><p>第二点，对于del的只调用一次的保证，在3.4代码里，调用del过程中可以看到</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!_PyGCHead_FINALIZED(gc) &amp;&amp;<br>        PyType_HasFeature(Py_TYPE(op), Py_TPFLAGS_HAVE_FINALIZE) &amp;&amp;<br>        (finalize = Py_TYPE(op)-&gt;tp_finalize) != <span class="hljs-literal">NULL</span>) &#123;<br>    _PyGCHead_SET_FINALIZED(gc, <span class="hljs-number">1</span>); <span class="hljs-comment">/*[1]*/</span><br>    Py_INCREF(op);<br>    finalize(op);<br>    Py_DECREF(op);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>[1]处会在调用时设置FINALIZED标志位，这样下次销毁就不会再调用。结合那个邮件列表来看，可以推测引用计数为0引发的销毁也会检查这个标志来确定是否需要调用__del__，由于只有gc会设置这个标志位，所以不被gc跟踪的__del__可以被调用多次。</p><h1 id="一些工具和方法"><a href="#一些工具和方法" class="headerlink" title="一些工具和方法"></a>一些工具和方法</h1><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><table><thead><tr><th>工具名</th><th>适用情景</th></tr></thead><tbody><tr><td>gc</td><td>查看gc过程，设置开闭、执行阈值</td></tr><tr><td>tracemalloc</td><td>可通过快照对比内存的使用情况，可以定位到问题代码的具体位置，debug首选</td></tr><tr><td>pympler</td><td>Python2中tracemalloc的替代品，开销更大</td></tr><tr><td>objgraph</td><td>绘制对象引用图，如果存在复杂的三方库，结果会很乱。适合小范围的展示工作，对真正的debug帮助有限。</td></tr></tbody></table><p>关于内存泄漏的工具，这篇以tracemalloc为切入点的<a href="https://blog.louie.lu/2017/08/04/tracemalloc-python-standard-library-09/">文章</a>不错，看最后的discussion</p><h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><p>查看进程的线程数量<code>ps -o nlwp &lt;pid&gt;</code></p><p>根据对象的id/address动态获取对象<code>obj = ctypes.cast(&lt;addr_or_id&gt;, ctypes.py_object).value</code></p><p>对象销毁的回调函数<code>weakref.finalize(obj, callback)</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Q: 什么情况下会内存泄漏，怎么处理？</p><p>A:  据我所知，在python3.4之前，常见的内存泄露方式有三种：</p><ol><li>因为第三方库，不需要跟踪的对象被一些隐秘的长生命周期的变量强引用</li><li>gc被关闭，并且代码中出现了循环引用</li><li>含有__del__魔法方法类实例</li></ol><p>第三条已经在python3.4中被修复</p><p>第二条排查起来比较容易，检查gc是否开启</p><p>因此，如果Python3发生内存泄漏，问题基本出现在全局变量持有的隐秘强引用上，(其实感觉严格意义上说，这种情况好像不叫内存泄漏，无论如何你都是可以访问到引用的)</p><p>看过别人记录的，一个这种类型的内存泄漏的例子，关于常用的logging库</p><p>代码过程是为每一个tcp连接新建Connection对象，并且在这个对象里以内存地址为name，维护了一个logger，logger添加syslogHandler，向514端口发送日志。</p><p>上线一段时间后syslog的UDP连接达到了8W。syslogHandler的emit函数就是使用socket和514建立UDP连接。这说明即使connection对象不再有引用，其内部的syslogHandler依然没有释放</p><p>作者发现logging模块在manager里维护了一个全局的loggerDict字典，以name为key，logger对象为value。所以即使connnect实例被销毁，内部的logger依然存在引用，无法回收</p><p>于是作者在connection关闭时，把loggerDict字典中的对应logger移除，就可以释放所以slogHandler了</p><p>整个事件看完，我的感受是需要弄明白logger的定位，这是一个大方向。</p><p>一方面，如果对每个对象新建logger是合理的，那么可以调整的有两个地方：</p><ol><li><p>connection关闭时，应当调用sysloghandler的close方法，保证不会出现大量连接</p></li><li><p>loggerDict中维护的所有logger的做法有待商榷。创建的loggger的所有权我个人认为不应该属于logging模块，所以这里的loggerDict更适合使用WeakValueDictionary。而且loggerDict目的就是cache，weakref用在cache的场景是非常合适的[fluent python p.236]</p></li></ol><p>另一方面，如果不合理，就应该明确logger的地位，全局变量，所有权在logging。个性化的logger可以通过加入不同的信息来实现，比如使用LoggerAdapter，保证全局logger的精简</p><p>此外关于内存泄漏的排查过程，对于Python3，首先确定gc是否打开，如果问题依然存在，使用内置的tracemalloc的快照对比功能来定位发生泄漏的代码位置，一般来说会发现一段将泄露对象添加到一个或多个全局容器的代码，针对问题代码给出解决方案。事后总结展示的时候可以添加objgraph画出的局部引用图，给其他人一个直观的理解。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>有一个直观的图表：<a href="https://blog.csdn.net/m345376054/article/details/79214382">https://blog.csdn.net/m345376054/article/details/79214382</a></p><p>有排错的过程，提到PEP442问题：<a href="https://www.jianshu.com/p/2d06a1a01cc3">https://www.jianshu.com/p/2d06a1a01cc3</a></p><p>一个清晰的整体梳理：<a href="https://rushter.com/blog/python-garbage-collector/">https://rushter.com/blog/python-garbage-collector/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust线程池源码拆解及实现</title>
    <link href="/2020/02/01/threadpool-impl/"/>
    <url>/2020/02/01/threadpool-impl/</url>
    
    <content type="html"><![CDATA[<p>看了rust的threadpool crate，照虎画猫！</p><a id="more"></a><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>基本模型是，存在一个任务channel，发送头在<code>ThreadPool</code>里，通过<code>execute</code>方法发送任务闭包，已初始化的若干个工作线程一直处在loop里，行为是从任务通道里取任务，执行，取任务……这样循环。因为有loop，所以线程就一直没退出，免去了回收、再创建的消耗。</p><p><img src="https://s2.ax1x.com/2020/02/01/1JFENj.png" alt="threadpool.png"></p><p>任务闭包签名为<code>FnOnce() + Send + &#39;static</code>，没有参数，没有返回值，所以需要对真实的调用函数做适配，捕获参数，构造闭包，如果有返回值就直接用共享的变量收集，比如下面这样，每个任务是产生输入参数的平方数，结果收集到<code>Vec</code>里</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something</span></span>(i: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    thread::sleep(Duration::from_micros(<span class="hljs-number">50</span> * i <span class="hljs-keyword">as</span> <span class="hljs-built_in">u64</span>));<br>    i * i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> pool = ThreadPool::new(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">let</span> ans = Arc::new(Mutex::new(<span class="hljs-built_in">Vec</span>::&lt;<span class="hljs-built_in">usize</span>&gt;::new()));<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> ans = ans.clone();<br>        <span class="hljs-keyword">let</span> job = <span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> result = do_something(i);<br>            (*ans.lock().unwrap()).push(result);<br>        &#125;;<br>        pool.execute(job)<br>    &#125;<br>    pool.join();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">285usize</span>, (*ans.lock().unwrap()).iter().sum());<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="搭建骨架"><a href="#搭建骨架" class="headerlink" title="搭建骨架"></a>搭建骨架</h2><p>任务闭包用Box装箱来传指针，动态查找虽然有性能损耗，但是闭包结构的复制消耗也相对固定，免得有个什么大闭包结构被莫名复制到线程栈上。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Job</span></span> = <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;;<br></code></pre></div></td></tr></table></figure><p>初始化一个工作线程，就是把一个channel的接收端加锁，传给线程，同步地从channel中拿出任务来执行。<code>Mutex</code>加锁，<code>Arc</code>创建共享所有权。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn_in_pool</span></span>(receiver: Arc&lt;Mutex&lt;Receiver&lt;Job&gt;&gt;&gt;) &#123;<br>    thread::spawn(<span class="hljs-keyword">move</span> || <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">let</span> recv_result = &#123;<br>            <span class="hljs-comment">// 以最少时间占用锁</span><br>            receiver.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock channel receiver&quot;</span>).recv()<br>        &#125;;<br><br>        <span class="hljs-keyword">let</span> job_fn = <span class="hljs-keyword">match</span> recv_result &#123;<br>            <span class="hljs-literal">Ok</span>(job) =&gt; job,<br>            <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-keyword">break</span>, <span class="hljs-comment">// 这个错误说明另一端已经drop，退出该线程就可以</span><br>        &#125;;<br>        job_fn();<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ThreadPool</code>现在只要一个channel的传输入口，用于任务发送。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadPool</span></span> &#123;<br>    sender: Sender&lt;Job&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> ThreadPool &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">execute</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>    &#123;<br>        <span class="hljs-keyword">self</span>.sender.send(<span class="hljs-built_in">Box</span>::new(f)).unwrap();<br>    &#125;<br>    ...    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化工作自然就是要建立起任务channel，然后调用<code>spawn_in_pool</code>，初始化要求个数的工作线程</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> ThreadPool &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(threads_num: <span class="hljs-built_in">usize</span>) -&gt; ThreadPool &#123;<br>        <span class="hljs-keyword">let</span> (tx, rx) = channel::&lt;Job&gt;(); <span class="hljs-comment">// 建channel</span><br>        <span class="hljs-keyword">let</span> receiver = Arc::new(Mutex::new(rx)); <span class="hljs-comment">// 初始化工作线程</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..threads_num &#123;<br>            <span class="hljs-keyword">let</span> receiver = receiver.clone();<br>            spawn_in_pool(receiver);<br>        &#125;<br>        ThreadPool &#123; sender: tx &#125;  <span class="hljs-comment">// 返回pool</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>join</code>作用就等待工作线程完成全部任务，这个事情下阶段来做，这里先随便<code>sleep</code>替代一下，能通过测试用例就可以。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> ThreadPool &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">join</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>        thread::sleep(Duration::from_secs(<span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>很好，测试通过！🎉🎉🎉🎉线程池写完了！膨胀得先去吃个烧烤庆祝一下！</p><h2 id="正确地join"><a href="#正确地join" class="headerlink" title="正确地join"></a>正确地join</h2><p>什么时候说明任务执行完了？</p><ul><li>任务队列任务计数为0，记为<code>queue_cnt == 0</code></li><li>没有正在执行任务的线程，记为<code>active_cnt == 0</code></li></ul><p>所以我们需要共享这两个变量给所有工作线程。工作线程取出一个任务，<code>queue_cnt -= 1</code>，执行任务前<code>active_cnt += 1</code>，完成后<code>active_cnt -= 1</code>。显然<code>ThreadPool</code>也需要共享这两个变量，<code>execute</code>时<code>queue_cnt += 1</code>。</p><p><code>join</code>时，可以简单粗暴地轮询这些两个变量判断。但是这种通知的同步场景，使用条件变量来挂起等待线程，有事件时重启线程更高效。</p><p>谁在等待？<code>join</code>方法，使用条件变量的<code>wait</code>挂起线程，等待事件发生。</p><p>谁来通知？工作线程，当完成一个任务后，检查任务是否全部完成，如果是，就<code>notify_all</code>（因为<code>ThreadPool</code>也可以在多个线程里并发地发送任务）。</p><p>所以现在要共享的变量又多了4个，只能单独写一个结构来封装他们，然后共享给工作线程。对于<code>queue_cnt</code>，<code>active_cnt</code>这种基本类型，有<code>AtomicXxx</code>等原子类型供选择，但是内存顺序暂时还没看懂，先用<code>Mutex</code>代替吧，性能低点就低。为了方便，直接把判断和通知的方法实现在这个<code>SharedData</code>里。</p><p>条件变量和互斥锁配套使用，互斥锁的基本作用是，对条件变量的操作，无论是<code>wait</code>、<code>notify_*</code>，都是互斥进行的，保证条件变量在增加、移除暂停线程时的安全性，另外互斥锁本身也可以携带信息，作为条件判断的对象。但是这个里的<code>cond_guard</code>只起第一个作用，条件的判断由<code>queue_cnt</code>和<code>active_cnt</code>承担。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharedData</span></span> &#123;<br>    receiver: Mutex&lt;Receiver&lt;Job&gt;&gt;,<br>    queue_cnt: Mutex&lt;<span class="hljs-built_in">usize</span>&gt;,<br>    active_cnt: Mutex&lt;<span class="hljs-built_in">usize</span>&gt;,<br>    cond_guard: Mutex&lt;()&gt;,<br>    cond: Condvar,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SharedData &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">has_task</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> &#123;<br>        *<span class="hljs-keyword">self</span>.queue_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock queue_cnt&quot;</span>) &gt; <span class="hljs-number">0</span><br>            || *<span class="hljs-keyword">self</span>.active_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock active_cnt&quot;</span>) &gt; <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify_when_no_tasks</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.has_task() &#123;<br>            *<span class="hljs-keyword">self</span>.cond_guard.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock cond_guard&quot;</span>);<br>            <span class="hljs-keyword">self</span>.cond.notify_all(); <span class="hljs-comment">// 独占地通知</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来就是围绕这个新的中间结构，改造之前的骨架就可以，比如<code>spawn_in_pool</code>的要改签名，增加变量维护的逻辑。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn_in_pool</span></span>(data: Arc&lt;SharedData&gt;) &#123;<br>    <span class="hljs-comment">// ...取出任务</span><br>    &#123;<br>         *data.queue_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock queue_cnt&quot;</span>) -= <span class="hljs-number">1</span>;<br>    &#125;<br>    &#123;<br>        *data.active_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock queue_cnt&quot;</span>) += <span class="hljs-number">1</span>;<br>    &#125;<br>    job_fn();<br>    &#123;<br>        *data.active_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock queue_cnt&quot;</span>) -= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    data.notify_when_no_tasks();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ThreadPool</code>本身也多了一个<code>data</code>字段，方便<code>join</code>、<code>execute</code>时使用</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadPool</span></span> &#123;<br>    sender: Sender&lt;Job&gt;,<br>    data: Arc&lt;SharedData&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> ThreadPool &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(threads_num: <span class="hljs-built_in">usize</span>) -&gt; ThreadPool &#123;<br>        <span class="hljs-keyword">let</span> (tx, rx) = channel::&lt;Job&gt;();<br>        <span class="hljs-keyword">let</span> data = Arc::new(SharedData &#123;<br>            receiver: Mutex::new(rx),<br>            queue_cnt: Mutex::new(<span class="hljs-number">0</span>),<br>            active_cnt: Mutex::new(<span class="hljs-number">0</span>),<br>            cond_guard: Mutex::new(()),<br>            cond: Condvar::new(),<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..threads_num &#123;<br>            <span class="hljs-keyword">let</span> data = data.clone();<br>            spawn_in_pool(data);<br>        &#125;<br>        ThreadPool &#123;<br>            sender: tx,<br>            data: data,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">execute</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>    &#123;<br>        &#123;<br>            *<span class="hljs-keyword">self</span>.data.queue_cnt.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock queue_cnt&quot;</span>) += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">self</span>.sender.send(<span class="hljs-built_in">Box</span>::new(f)).unwrap();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">join</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.data.has_task() &#123; <span class="hljs-comment">// 一个小优化，有机会避免一次cond_guard的加锁</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> guard = <span class="hljs-keyword">self</span>.data.cond_guard.lock().expect(<span class="hljs-string">&quot;can&#x27;t lock cond guard&quot;</span>);<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.data.has_task() &#123;<br>            guard = <span class="hljs-keyword">self</span>.data.cond.wait(guard).unwrap();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>🐮🍺，测试通过！🎉🎉🎉🎉阶段性成果！成功完成了正常工作的<code>join</code></p><h2 id="动态设置工作线程数"><a href="#动态设置工作线程数" class="headerlink" title="动态设置工作线程数"></a>动态设置工作线程数</h2><p>线程池创建之后，如果想要动态增加或者减少线程数量可咋搞？分两种情况来考虑。</p><ol><li>工作线程数增加，差多少个，就调用多少次<code>spawn_in_pool</code>，补齐差距。</li><li>工作线程减少，那就要让一些工作线程自动地break，退出后自动被回收。怎么让这些多余的线程知道自己被下岗了呢？现在正在执行任务的线程不能动，那些执行完，再次循环去工作队列里拿任务前，就可以检查多少线程正在工作<code>active_cnt</code>，如果大于设定的最大工作线程数，那么自己就主动退出。</li></ol><p>所以思路就是</p><ul><li>在<code>SharedData</code>里增加一个<code>max_threads_cnt</code>字段；</li><li>给<code>ThreadPool</code>实现<code>set_threads_num</code>方法，如果是增加，就调用<code>spawn_in_pool</code>补齐；</li><li>工作线程的每次取任务前都检查一下<code>active_cnt</code>是否大于<code>max_threads_cnt</code>，是就break；</li></ul><p>后两点变动的代码是</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> ThreadPool &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_threads_num</span></span>(&amp;<span class="hljs-keyword">self</span>, size: <span class="hljs-built_in">usize</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> prev_cnt = size;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> p_thread_cnt = <span class="hljs-keyword">self</span><br>                .data<br>                .max_threads_cnt<br>                .lock()<br>                .expect(<span class="hljs-string">&quot;can&#x27;t lock max_threads_cnt&quot;</span>);<br>            prev_cnt = *p_thread_cnt;<br>            *p_thread_cnt = size;<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(n) = size.checked_sub(prev_cnt) &#123;<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n &#123;<br>                <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">self</span>.data.clone();<br>                spawn_in_pool(data);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn_in_pool</span></span>(data: Arc&lt;SharedData&gt;) &#123;<br>    &#123;<br>        <span class="hljs-keyword">if</span> *data.active_cnt.lock().unwrap() &gt;= *data.max_threads_cnt.lock().unwrap() &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>&#125;<br>    <span class="hljs-comment">// ...取出任务</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="工作线程panic怎么办"><a href="#工作线程panic怎么办" class="headerlink" title="工作线程panic怎么办"></a>工作线程panic怎么办</h2><p>如果任务闭包<code>job_fn</code>执行产生了panic，那么会产生什么影响？首先是线程退出</p><ul><li>线程退出，工作线程不等于当初设定的线程数</li><li><code>job_fn</code>后面的代码没有执行：<code>active_cnt</code>没有减一、没有通知<code>join</code></li></ul><p>所以因panic退出时，得执行被跳过的逻辑，并且重启线程。</p><p>panic退出时还要执行代码？这咋办呢，只能是某个结构实现<code>Drop</code>trait，在<code>drop</code>方法中执行没有执行完的逻辑。下面是源码中<code>Sentinel</code>哨兵的实现。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Sentinel&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 在工作线程进入loop前，new一个新鲜的sentinel</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(shared_data: &amp;<span class="hljs-symbol">&#x27;a</span> Arc&lt;ThreadPoolSharedData&gt;) -&gt; Sentinel&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>        Sentinel &#123;<br>            shared_data: shared_data,<br>            active: <span class="hljs-literal">true</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/// loop正常break出来，执行cancel.</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cancel</span></span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.active = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Sentinel&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.active &#123; <span class="hljs-comment">// 说明不是break正常退出</span><br>            <span class="hljs-keyword">self</span>.shared_data.active_count.fetch_sub(<span class="hljs-number">1</span>, Ordering::SeqCst);<br>            <span class="hljs-keyword">if</span> thread::panicking() &#123; <br>                <span class="hljs-keyword">self</span>.shared_data.panic_count.fetch_add(<span class="hljs-number">1</span>, Ordering::SeqCst);<br>            &#125;<br>            <span class="hljs-keyword">self</span>.shared_data.no_work_notify_all();<br>            spawn_in_pool(<span class="hljs-keyword">self</span>.shared_data.clone())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我的疑问是：为什么会有哨兵的<code>active</code>字段和<code>thread::panicking()</code>的双重检查？非正常退出除了panic还有其他的情况？如果是其他情况，为什么进入active分支后直接对<code>active_cnt</code>进行减1操作，这个操作的潜在假设是逻辑流一定中止于闭包调用呀，那么除了<code>job_fn</code>本身panic，还能有什么可能满足这个假设呢？我还试过了，源代码实现中，如果获取获取工作队列锁失败，<code>expect</code>产生的panic也会进入<code>drop</code>方法，造成<code>active_count</code>减1后溢出，行为完全失控。</p><p>我个人看法，正确的解决办法，应该是<code>drop</code>只应对一种情况，就是任务闭包panic，这是唯一不可控的代码，其他情况如果出现error，就地处理，比如工作队列获取锁，如果失败，标记sentinel的<code>drop</code>不要处理，主动<code>spand_in_pool</code>挽救。像我这里没有使用<code>AtomicXxx</code>，获取状态字段时出错，那么就是严重的运行时问题，已经无法维持线程池的正确状态，也是标记<code>drop</code>不要处理，同时标记线程池停止工作，抛出panic。</p><h2 id="还有什么可以做的吗？"><a href="#还有什么可以做的吗？" class="headerlink" title="还有什么可以做的吗？"></a>还有什么可以做的吗？</h2><ul><li>现在异常只会计数，是不是可以给每个任务增加名字，join之后可以重新执行失败的任务？</li><li>任务超时怎么办？<code>ThreadPool</code>结构就得主动杀死线程，所以还得共享一个&lt;线程id-状态&gt;的映射？</li><li>把工作队列的性质也做成初始化参数？用户可以选择使用有界队列和无界队列？</li><li>工作线程panic的问题，还待确认解决方案。</li><li>源代码中的<code>test_threads_num_decreasing</code>测试用例有误，第二次<code>execute</code>的数量应该多于<code>new_threads_num</code></li></ul><p>OK，线程池的源码解析就到这里吧，挺有收获的</p><ol><li>终于明白了线程池的模型，原来是队列+多个loop线程👏</li><li>熟悉了rust中的线程同步工具。算是对<a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html"><code>Unique+Share</code></a>角度的复习，这个角度思考真的非常有用！<code>Arc</code>、<code>Mutex</code>啥的看得更清楚了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - 实践篇 - serialize</title>
    <link href="/2020/01/12/serde-what-are-you-doing-practice-resp-ser/"/>
    <url>/2020/01/12/serde-what-are-you-doing-practice-resp-ser/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | 用Redis Simple Protocol做练习 Serialize篇</p><a id="more"></a><h2 id="基础结构和接口"><a href="#基础结构和接口" class="headerlink" title="基础结构和接口"></a>基础结构和接口</h2><p>根据之前假定的<code>to_bytes</code>接口，现在来填充基本内容。首先需要一个结构体来实现<code>Serializer</code> trait，干脆名字也叫<code>Serializer</code>，拥有一个<code>output</code>字段，这就是写作文的作文本。<code>to_bytes</code>内部，初始化一个<code>serializer</code>，交给目标类型的<code>serialize</code>带领，参观目标类型，参观回来，直接把写好的作文返回。</p><p>在简化版的实现中，序列化结果中只有array和bulk string两种类型，所以为<code>serializer</code>提供一个添加bulk string的快捷方式，<code>append_elemet</code>，接受<code>u8</code>序列，统计长度后统一添加length和分隔符。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Serializer</span></span> &#123;<br>    output: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-comment">// Redis Simple Protocol规定，发往服务端的信息，是bulk string，这里用bytes来表示</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_bytes</span></span>&lt;T&gt;(value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt;<br><span class="hljs-keyword">where</span><br>    T: Serialize,<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> serializer = Serializer &#123; output: <span class="hljs-built_in">vec!</span>[] &#125;;<br>    value.serialize(&amp;<span class="hljs-keyword">mut</span> serializer)?;<br>    <span class="hljs-literal">Ok</span>(serializer.output)<br>&#125;<br><br><span class="hljs-keyword">impl</span> Serializer &#123;<br>    <span class="hljs-comment">// Serializer添加bulk String的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">append_element</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, element: &amp;[<span class="hljs-built_in">u8</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.output<br>            .extend_from_slice(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;$&#123;&#125;\r\n&quot;</span>, element.len()).as_bytes());<br>        <span class="hljs-keyword">self</span>.output.extend_from_slice(element);<br>        <span class="hljs-keyword">self</span>.output.push(<span class="hljs-string">b&#x27;\r&#x27;</span>);<br>        <span class="hljs-keyword">self</span>.output.push(<span class="hljs-string">b&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体实现<code>Serializer</code> trait时，是为<code>&amp;mut Serializer</code>实现，因为<code>serializer</code>被以可变借用的形式交给Serialize接口。</p><p>一些associated type设置如下</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ser::Serializer <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Serializer &#123;<br>    <span class="hljs-comment">// 直接往output里塞东西，一般设置为()就可以</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Ok</span></span> = ();<br>    <span class="hljs-comment">// 序列化过程中发生的错误，因为我们是写入Vec&lt;u8&gt;，出错可能性很小，这里暂时不做过多考虑，</span><br>    <span class="hljs-comment">// 放到反序列过程是再提</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br>    <br>    <span class="hljs-comment">// 支持有状态序列化的一些结构，但是当前实现不需要额外维护一些信息，所以直接沿用Serializer结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeSeq</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeTuple</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeTupleStruct</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeTupleVariant</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeMap</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeStruct</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">SerializeStructVariant</span></span> = <span class="hljs-keyword">Self</span>;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="实现Serializer-trait"><a href="#实现Serializer-trait" class="headerlink" title="实现Serializer trait"></a>实现<code>Serializer</code> trait</h2><h3 id="primitive-type"><a href="#primitive-type" class="headerlink" title="primitive type"></a>primitive type</h3><p>先从简单的入手，对于数值基本类型，全部格式化为String后<code>as_bytes</code>，然后作为以项bulk string插入结果。低精度把实现委托给高精度的实现。这种模式适用于<code>i8, i16, i32, i64, u8, u16, u32, u64</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_i8</span></span>(<span class="hljs-keyword">self</span>, v: <span class="hljs-built_in">i8</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_i64(<span class="hljs-built_in">i64</span>::from(v))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_i64</span></span>(<span class="hljs-keyword">self</span>, v: <span class="hljs-built_in">i64</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.append_element(&amp;v.to_string().as_bytes());<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;    <br></code></pre></div></td></tr></table></figure><p><code>f32, f64</code>暂时不支持，因为浮点数的反序列化比较麻烦，没计划做，所以序列化时就直接拒绝。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_f32</span></span>(<span class="hljs-keyword">self</span>, _v: <span class="hljs-built_in">f32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-literal">Err</span>(Error::Message(<span class="hljs-string">&quot;float is not supported&quot;</span>.to_owned()))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_f64</span></span>(<span class="hljs-keyword">self</span>, _v: <span class="hljs-built_in">f64</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-literal">Err</span>(Error::Message(<span class="hljs-string">&quot;float is not supported&quot;</span>.to_owned()))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>bool类型本来应该用整形来表示，但是依然已经简化为全员bulk string，就用<code>true/false</code>增加一下可读性。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_bool</span></span>(<span class="hljs-keyword">self</span>, v: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.append_element(<span class="hljs-keyword">if</span> v &#123; <span class="hljs-string">b&quot;true&quot;</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-string">b&quot;false&quot;</span> &#125;);<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面一些其他基本类型的实现，说明都很短，就直接在注释中写了</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 单个字符也被当做字符串</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_char</span></span>(<span class="hljs-keyword">self</span>, v: <span class="hljs-built_in">char</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_str(&amp;v.to_string())<br>&#125;<br><br><span class="hljs-comment">// 直接把字符串转为bytes，没有转义</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_str</span></span>(<span class="hljs-keyword">self</span>, v: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_bytes(v.as_bytes())<br>&#125;<br><br><span class="hljs-comment">// bytes当作列表元素</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_bytes</span></span>(<span class="hljs-keyword">self</span>, v: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.append_element(v);<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br><br><span class="hljs-comment">// 空值(), bulk string $-1\r\n表示</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_unit</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.output.extend_from_slice(<span class="hljs-string">b&quot;$-1\r\n&quot;</span>);<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br><br><span class="hljs-comment">// None 等效于 ()</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_none</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_unit()<br>&#125;<br><br><span class="hljs-comment">// Some(value) 在Serialize实现中会直接告诉serializer value，</span><br><span class="hljs-comment">// 所以Some(())在resp中会和None一样，被序列化为$-1\r\n，无法准确表达信息。</span><br><span class="hljs-comment">// 但是如果客户端、服务端都用同一套数据结构，就可以这一公认的额外信息进行准确推断了。</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_some</span></span>&lt;T&gt;(<span class="hljs-keyword">self</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br><span class="hljs-keyword">where</span><br>T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>&#123;<br>    value.serialize(<span class="hljs-keyword">self</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="集合类型-seq"><a href="#集合类型-seq" class="headerlink" title="集合类型 - seq"></a>集合类型 - seq</h3><p>一个列表型的数据，默认第一个元素为“命令”，剩下的元素为“参数”</p><p>因此，<code>serialize_seq</code>会用 传入的长度参数，构建array的开头，<code>*</code>号引导</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_seq</span></span>(<span class="hljs-keyword">self</span>, _len: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeSeq&gt; &#123;<br>    <span class="hljs-keyword">match</span> _len &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">Err</span>(Error::Message(<br>            <span class="hljs-string">&quot;length of sequence can&#x27;t be determined&quot;</span>.to_owned(),<br>        )),<br>        <span class="hljs-literal">Some</span>(l) =&gt; &#123;<br>            <span class="hljs-keyword">self</span>.output<br>            .extend_from_slice(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;*&#123;&#125;\r\n&quot;</span>, l).as_bytes());<br>            <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">self</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>构建完成后，把<code>Self</code>返回，因为在associated type一节，确定了会为<code>Serializer</code>实现<code>SerializeSeq</code> trait。实现非常简单，每次<code>serialize_element</code>就是直接把元素序列化，自然会追加到array中。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ser::SerializeSeq <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Serializer &#123;<br>    <span class="hljs-comment">// 和 the serializer 的Ok类型一致.</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Ok</span></span> = ();<br>    <span class="hljs-comment">// 和 the serializer 的Error类型一致.</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_element</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br>    <span class="hljs-keyword">where</span><br>        T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>    &#123;<br>        <span class="hljs-comment">// resp 格式，直接往后添加就可以了</span><br>        value.serialize(&amp;<span class="hljs-keyword">mut</span> **<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 长度前置，关闭时什么都不用做</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">end</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>相同的逻辑对tuple适用，序列化方法沿用<code>serialize_seq</code>，<code>SerializeTuple</code>的实现和<code>SerializeSeq</code> 相同</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// tuples和列表基本相同，但是它的长度是确定的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_tuple</span></span>(<span class="hljs-keyword">self</span>, len: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeTuple&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_seq(<span class="hljs-literal">Some</span>(len))<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="集合类型-struct"><a href="#集合类型-struct" class="headerlink" title="集合类型 - struct"></a>集合类型 - struct</h3><p>对于结构体struct，其名称就是”命令”，字段就是“参数”。总共有四种struct，依次说。</p><p>最简单的struct类型，<code>unit_struct</code>，形如<code>struct Foo;</code>，可以看成无参数命令，所以先写入array开头，长度为1，然后写入命令名称。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_unit_struct</span></span>(<span class="hljs-keyword">self</span>, name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.output.extend_from_slice(<span class="hljs-string">b&quot;*1\r\n&quot;</span>);<br>    <span class="hljs-keyword">self</span>.serialize_str(name)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>newtype_struct</code>，形如<code>struct Foo(i32);</code>，单一参数命令，类似地，写入长度为2的array开头，写入命令名称，再把唯一的参数序列化。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_newtype_struct</span></span>&lt;T&gt;(<span class="hljs-keyword">self</span>, name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br><span class="hljs-keyword">where</span><br>T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>&#123;<br>    <span class="hljs-keyword">self</span>.output.extend_from_slice(<span class="hljs-string">b&quot;*2\r\n&quot;</span>);<br>    <span class="hljs-keyword">self</span>.serialize_str(name)?;<br>    value.serialize(<span class="hljs-keyword">self</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>tuple_struct</code>，形如<code>struct Foo(i32, i32, i32);</code>，多参数命令，总长度为参数长度+1，这里先调用<code>serialize_seq</code>，启动array的构造，写入array头部，返回的<code>Serialzier</code>，也就是变量<code>tuple</code>，也实现了<code>SerializeTupleStruct</code>，交给<code>Serialize</code>调用，一项项地把参数序列化，但是在交出去之前呢，需要先写入命令名称，所以调用<code>serialize_str</code>直接写。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// tuple_struct，多参数命令，array长度是tuple长度+1，比如 struct Foo(i32, i32, i32);</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_tuple_struct</span></span>(<br>    <span class="hljs-keyword">self</span>,<br>    name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>,<br>    len: <span class="hljs-built_in">usize</span>,<br>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeTupleStruct&gt; &#123;<br>    <span class="hljs-keyword">let</span> tuple = <span class="hljs-keyword">self</span>.serialize_seq(<span class="hljs-literal">Some</span>(len + <span class="hljs-number">1</span>))?;<br>    tuple.serialize_str(name)?;<br>    <span class="hljs-literal">Ok</span>(tuple)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现<code>SerializeTupleStruct</code> trait 和Seq一样，每一项field，直接调用<code>Serialize</code>trait就完事儿了。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ser::SerializeTupleStruct <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Serializer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Ok</span></span> = ();<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_field</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br>    <span class="hljs-keyword">where</span><br>        T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>    &#123;<br>        value.serialize(&amp;<span class="hljs-keyword">mut</span> **<span class="hljs-keyword">self</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">end</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后还有一种常规struct，形如<code>struct Foo &#123;key: i32, val:i32&#125;</code>，因为我们不关心字段名，比如<code>key</code>、<code>val</code>，只在意<code>i32</code>具体是哪个数，所以抛弃字段名后(<code>serialize_field</code>时忽略了<code>_key</code>参数)，和<code>tuple_struct</code>没什么两样，所以直接利用已有实现就好了。返回的<code>SerializeStruct</code>也是<code>Serializer</code>，无缝衔接。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_struct</span></span>(<span class="hljs-keyword">self</span>, _name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>, len: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeStruct&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_tuple_struct(_name, len)<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ser::SerializeStruct <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Serializer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Ok</span></span> = ();<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_field</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, _key: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br>    <span class="hljs-keyword">where</span><br>        T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>    &#123;<br>        value.serialize(&amp;<span class="hljs-keyword">mut</span> **<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">end</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="集合类型-enum"><a href="#集合类型-enum" class="headerlink" title="集合类型 - enum"></a>集合类型 - enum</h3><p>然后处理enum类型，实际上也有四种variant，和struct对等，都可以沿用struct的处理。并且使用到的<code>SerializeTupleVariant</code>、<code>SerializeStructVariant</code> trait 实现也没有区别</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_unit_variant</span></span>(...) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_unit_struct(variant)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_newtype_variant</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span> + Serialize&gt;(...) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_newtype_struct(variant, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_tuple_variant</span></span>(...) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeTupleVariant&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_tuple_struct(variant, len)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_struct_variant</span></span>(...) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeStructVariant&gt; &#123;<br>    <span class="hljs-keyword">self</span>.serialize_tuple_struct(variant, len)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="集合类型-map"><a href="#集合类型-map" class="headerlink" title="集合类型 - map"></a>集合类型 - map</h3><p>整个过程中，都没有实现<code>serialize_map</code>，因为我们向服务器端传递的是命令，存在执行的先后顺序，但是map类型的无序性，无法保证序列化顺序，因此并不支持这样的结构</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_map</span></span>(<span class="hljs-keyword">self</span>, _len: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeMap&gt; &#123;<br>    <span class="hljs-built_in">unimplemented!</span>(<span class="hljs-string">&quot;map type is not supported&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里序列化的前提，是站在客户端的角度，全部序列化为bulk of string。</p><p>如果一定要支持自描述的序列化，也就是站在服务端的角度，除了<code>* $</code>的提示符，还要增加<code>- + :</code>的提示，有什么思路呢？基本的struct、enum转变为array的大方向不变，基础类型序列化时，<code>bytes</code>对应<code>$</code>，<code>str</code>对应<code>+</code>，整形对应<code>:</code>，都好办，但是这个<code>-</code>怎么添加？rust中的Error就是普通的struct或者enum，<code>data model</code>中没有专门的接口，直接套用<code>bytes</code>，<code>str</code>的方案不太行。最开始的想法是自定义<code>Serialize</code>接口，用一些怪手段来添加<code>-</code>，比如调用<code>serialize_struct</code>时，传入的<code>name</code>，就是添加<code>-</code>之后的identifier。但是又注意到，这其实这和struct、enum的序列化为array的基本方向冲突。重新看resp中对错误类型的描述，定位好像就是<code>String</code>，没有什么结构信息，所以更粗暴的做法，可能将错误类型display之后，用<code>serialize_str</code>去序列化。那更粗暴的，display的工作都可以不交给serde，在构建给客户端的Response时，match一下，如果是error，display，添加<code>-</code>，然后直接序列化这个字符串。这个流程还可以用宏来简化，比自定义<code>Serialize</code>就简单多了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - 实践篇</title>
    <link href="/2020/01/10/serde-what-are-you-doing-practice-resp/"/>
    <url>/2020/01/10/serde-what-are-you-doing-practice-resp/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | 用Redis Simple Protocol做练习</p><a id="more"></a><p><code>serde你在干什么</code>的实践篇。基于serde框架，我们来写一个redis协议的deserializer和serializer</p><h2 id="Redis-Protocol"><a href="#Redis-Protocol" class="headerlink" title="Redis Protocol"></a>Redis Protocol</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p>redis 客户端和服务端通信的序列化标准</p><p>优点(哪都有这三个)：</p><ul><li>Simple to implement.</li><li>Fast to parse.</li><li>Human readable.</li></ul><p>特点：</p><ul><li>对bulk数据，前置数据长度，binary safe，不需要考虑处理转义的事情。</li><li>为Error专门设置了一个类型，方便客户端的错误处理。</li></ul><h3 id="序列化规范"><a href="#序列化规范" class="headerlink" title="序列化规范"></a>序列化规范</h3><p>可以序列化的类型：</p><ul><li>For <strong>Simple Strings</strong> the first byte of the reply is “+”</li><li>For <strong>Errors</strong> the first byte of the reply is “-“</li><li>For <strong>Integers</strong> the first byte of the reply is “:”</li><li>For <strong>Bulk Strings</strong> the first byte of the reply is “$” ，等效于&amp;[u8]</li><li>For <strong>Arrays</strong> the first byte of the reply is “<code>*</code>“，即Vec</li></ul><p>Simple Strings</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">&quot;+OK\r\n&quot;<br></code></pre></div></td></tr></table></figure><p>​    </p><p>Errors</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-string">&quot;-Error message<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span><br></code></pre></div></td></tr></table></figure><p>​    和Simple Strings基本相同，但是添加一个错误类型段</p><p>Integers</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">&quot;:1000\r\n&quot;<br></code></pre></div></td></tr></table></figure><p>​    bool值也使用0、1整型表示</p><p>Bulk Strings</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">&quot;$6\r\nfoobar\r\n&quot;  [u8; 6]<br>&quot;$-1\r\n&quot;  () None<br></code></pre></div></td></tr></table></figure><p>Arrays</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">&quot;*2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>foo<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>bar<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>&quot;  [b&quot;foo&quot;, b&quot;bar&quot;]<br>&quot;*3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>:1<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>:2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>:3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>&quot;  [1, 2, 3]<br>&quot;*0<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>&quot; []<br><br>*2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>*3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>:1<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>:2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>:3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>*2<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>+Foo<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>-Bar<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>  [[1, 2, 3], [&quot;Foo&quot;, Err(Bar)]]<br><br>*3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>foo<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>$-1<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>bar<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>  [&quot;foo&quot;,nil,&quot;bar&quot;]<br></code></pre></div></td></tr></table></figure><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>使用上，客户端发送 用 <strong>Array of Bulk Strings</strong> 的形式给服务器端发送 <strong>命令及参数</strong> 作为 Request；服务器端给客户端发送 任意的类型(组合) 作为 Response。</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">C: *2\r\n$3\r\nget\r\n$4\r\nkey1\r\n   get key1<br>S: $3\r\n101\rn  101<br></code></pre></div></td></tr></table></figure><p>redis 支持多个command的提交，一次性运行，提升单位时间的执行数量。成为<a href="https://redis.io/topics/pipelining">piplining</a></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;*2\r\n$3\r\nget\r\n$1\r\nA\r\n*2\r\n$3\r\nget\r\n$1\r\nA\r\n&#x27;</span> | nc localhost 6379</span><br><span class="hljs-meta">$</span><span class="bash">3</span><br>101<br><span class="hljs-meta">$</span><span class="bash">3</span><br>101<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;get A\n get A\n&#x27;</span> | nc localhost 6379</span><br><span class="hljs-meta">$</span><span class="bash">3</span><br>101<br><span class="hljs-meta">$</span><span class="bash">3</span><br>101<br></code></pre></div></td></tr></table></figure><h2 id="serde实现"><a href="#serde实现" class="headerlink" title="serde实现"></a>serde实现</h2><p>如前所述，正常情况下，客户端 –&gt; 服务端， 得用 <strong>Array of Bulk Strings</strong> 的格式告知 <strong>命令及参数</strong>；但是服务端反馈结果给客户端时，可以使用<strong>任意的格式组合</strong>。这其实表示了有两套序列化和反序列化的接口：</p><ol><li>客户端的序列化，服务端的反序列化，以 <strong>Array of Bulk Strings</strong> 为中介</li><li>服务端的序列化，客户端的反序列化，以 <strong>任意的格式组合</strong> 为中介</li></ol><p>当前实践篇，主要目的还是学习，简化一下，暂时忽略第二种，姑且认为服务端给客户端发送的也是<strong>Array of Bulk Strings</strong>，类型由rust本身的类型系统进行约束。</p><p>因此，我们希望客户端和服务端都有一套<strong>共同的Request/Response类型</strong>。还是以<code>Get</code>、<code>Set</code>、<code>Remove</code>三兄弟为例来设计。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Request</span></span> &#123;<br>    Get &#123; key: <span class="hljs-built_in">String</span> &#125;,<br>    Set &#123; key: <span class="hljs-built_in">String</span>, value: <span class="hljs-built_in">String</span> &#125;,<br>    Remove &#123; key: <span class="hljs-built_in">String</span> &#125;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">GetResponse</span></span> &#123;<br>    <span class="hljs-literal">Ok</span>(<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt;),<br>    <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SetResponse</span></span> &#123;<br>    <span class="hljs-literal">Ok</span>(()),<br>    <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RemoveResponse</span></span> &#123;<br>    <span class="hljs-literal">Ok</span>(()),<br>    <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>),<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据协议要求，服务端接受的一定是 <strong>Array of Bulk Strings</strong>，用<code>u8</code>序列表示，所以，假定序列化接口为</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>&lt;T: Serialize&gt; to_bytes(value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt;<br></code></pre></div></td></tr></table></figure><p>序列化过程可以通过如下的测试：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_ser</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> get = Request::Get &#123;<br>        key: <span class="hljs-string">&quot;key1&quot;</span>.to_owned(),<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        to_bytes(&amp;get).unwrap(),<br>        <span class="hljs-string">b&quot;*2\r\n$3\r\nGet\r\n$4\r\nkey1\r\n&quot;</span><br>    );<br>    <span class="hljs-keyword">let</span> set = Request::Set &#123;<br>        key: <span class="hljs-string">&quot;key1&quot;</span>.to_owned(),<br>        value: <span class="hljs-string">&quot;value1&quot;</span>.to_owned(),<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        to_bytes(&amp;set).unwrap(),<br>        <span class="hljs-string">&quot;*3\r\n$3\r\nSet\r\n$4\r\nkey1\r\n$6\r\nvalue1\r\n&quot;</span>.as_bytes()<br>    );<br>    <span class="hljs-keyword">let</span> rm = Request::Remove &#123;<br>        key: <span class="hljs-string">&quot;key1&quot;</span>.to_owned(),<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        to_bytes(&amp;rm).unwrap(),<br>        <span class="hljs-string">b&quot;*2\r\n$6\r\nRemove\r\n$4\r\nkey1\r\n&quot;</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个过程中，enum的名字不重要，每个variant的名字才是”命令”，所以放入array的第一项，variant的数据字段，追加到array中作为命令的参数。</p><p>影响序列化的关键一点是，不管”参数”是什么类型，最后都会以bulk string的形式作为array的元素。即使数据本身是int型，比如42，也会序列化为<code>$2\r\n\42\r\n</code>，而不是<code>:42\r\n</code>。</p><p>在服务端一侧，数据是从网络连接中读取的，因此我们假定反序列化接口为，</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_reader</span></span>(r: R) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>R: io:Read,<br>T: DeserializeOwned<br></code></pre></div></td></tr></table></figure><p>反序列化过程可以通过如下的测试：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><br><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_de</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> get = <span class="hljs-string">&quot;*2\r\n$3\r\nGet\r\n$4\r\nkey1\r\n&quot;</span>.as_bytes();<br>    <span class="hljs-keyword">match</span> from_reader::&lt;_, Request&gt;(get).unwrap() &#123;<br>        Request::Get &#123; key &#125; =&gt; <span class="hljs-built_in">assert_eq!</span>(key, <span class="hljs-string">&quot;key1&quot;</span>.to_owned()),<br>        _ =&gt; <span class="hljs-built_in">assert!</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;fail to deserialize into `Get`&quot;</span>),<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> set = <span class="hljs-string">&quot;*3\r\n$3\r\nSet\r\n$4\r\nkey1\r\n$6\r\nvalue1\r\n&quot;</span>.as_bytes();<br>    <span class="hljs-keyword">match</span> from_reader::&lt;_, Request&gt;(set).unwrap() &#123;<br>        Request::Set &#123; key, value &#125; =&gt; &#123;<br>            <span class="hljs-built_in">assert_eq!</span>(key, <span class="hljs-string">&quot;key1&quot;</span>.to_owned());<br>            <span class="hljs-built_in">assert_eq!</span>(value, <span class="hljs-string">&quot;value1&quot;</span>.to_owned());<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">assert!</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;fail to deserialize into `Set`&quot;</span>),<br>    &#125;<br>    <span class="hljs-comment">// Remove 略</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于<code>GetResponse</code>等结构，也是基本相同的过程，只不过由服务端序列化后，交给客户端去反序列化。</p><p>有了基本的测试用例，就可以着手具体实现了，还是分为Serialize和Deserialize两个过程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - deserialize - II</title>
    <link href="/2020/01/08/serde-what-are-you-doing-de-part2/"/>
    <url>/2020/01/08/serde-what-are-you-doing-de-part2/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | Deserialization篇 第二部分</p><a id="more"></a><p>上篇，已经把反序列化的总体过程描述了一遍，也留下了几个问题，<code>DeserializeSeed</code>和<code>PhantomData</code>是什么，<code>EnumAccess</code>中的<code>variant</code>方法被<code>visit_enum</code>调用后，为什么能产生一个<code>__Field</code>实例呢？</p><h2 id="DeserializeSeed"><a href="#DeserializeSeed" class="headerlink" title="DeserializeSeed"></a><a href="https://docs.serde.rs/serde/de/trait.DeserializeSeed.html">DeserializeSeed</a></h2><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DeserializeSeed</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt;: <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;D&gt;(<span class="hljs-keyword">self</span>, deserializer: D) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, D::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        D: Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Deserialize</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt;: <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;D&gt;(deserializer: D) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, D::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        D: Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>和<code>Deserialize</code>的区别，就在于用<code>DeserializeSeed</code>自定义了输出的类型，不必和实现类型一致。</p><p>也就是说，对一个<code>DeserializeSeed-thing</code>调用它的<code>deserialize</code>去消费一个<code>deserializer</code>提供的数据，可以返回的是自定义的Value类型。</p><p>回忆通常情况下，对<code>Deserialize</code>的使用，是利用泛型参数，由<code>Result&lt;T&gt;</code>推断出具体的T类型，再调用对应的<code>deserialze</code>方法，返回一个T类型的实例，这个过程只有类型参与，属于无状态的反序列化，比如下面的<code>T::deserialize()</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>    T: Deserialize&lt;<span class="hljs-symbol">&#x27;a</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> deserializer = Deserializer::from_str(s);<br>    <span class="hljs-keyword">let</span> t = T::deserialize(&amp;<span class="hljs-keyword">mut</span> deserializer)?;<br>   <span class="hljs-literal">Ok</span>(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是对于实现了<code>DeserializeSeed</code>的类型，使用上有所不同，通常是初始化成为一个实例，可以拥有自己的数据，常被当作参数<code>seed</code>传入一个形如<code></code>fn *_seed()<code>的方法，由它调用</code>seed<code>上的反序列化方法，比如下面的</code>seed.deserialize()<code>，这个deserialize过程则允许</code>seed`自身数据参与，所以是个有状态的反序列化过程。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant_seed</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, seed: V) -&gt; <span class="hljs-built_in">Result</span>&lt;(V::Value, Self::Variant)&gt;<br><span class="hljs-keyword">where</span><br>V: DeserializeSeed&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">let</span> val = seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de)?;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.next_char()? == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br>        <span class="hljs-literal">Ok</span>((val, <span class="hljs-keyword">self</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">Err</span>(Error::ExpectedMapColon)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不妨再来看看，哪些地方存在这样的<code>fn *_seed()</code>:</p><ul><li><p><code>SeqAccess</code>中的<code>next_element_seed</code></p></li><li><p><code>MapAccess</code>中的<code>next_key_seed</code>、<code>next_value_seed</code>、<code>next_entry_seed</code></p></li><li><p><code>EnumAccess</code>中的<code>variant_seed</code></p></li><li><p><code>VariantAcess</code>中的<code>newtype_variant_seed</code></p></li></ul><p>这些方法出现在<code>deserializer</code>为<code>visitor</code>提供的集合数据类型中。一个<code>visitor</code>，只有在实现了<code>visit_seq</code>、<code>visit_map</code>、<code>visit_enum</code>这类方法的前提下，才有机会使用有状态的反序列化。</p><p>但在实际工作中，大多数情况的反序列化，都是无状态的，所以给这些<code>fn *_seed()</code>方法传递的<code>DeserializeSeed-thing</code>，也就是参数<code>seed</code>，自然可以没有自己的数据，仅仅把某种类型信息给传递进去。像这种有类型、却没有实际数据的东西，标准库里专门有个类型叫<code>PhantomData</code>，幽灵数据来表示，编译器不会给他分配内存空间，只用来做类型的推断和方法的关联。</p><p>Serde已经为<code>PhantomData</code>实现<code>DeserializeSeed</code>，使其成为<code>DeserializeSeed-thing</code>，直接把<code>PhantomData</code>传入<code>fn *_seed()</code>里，就等效于无状态<code>Deserialize</code>的过程，只有类型参与。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>, T&gt; DeserializeSeed&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> PhantomData&lt;T&gt;<br><span class="hljs-keyword">where</span><br>    T: Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = T;<br><br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;D&gt;(<span class="hljs-keyword">self</span>, deserializer: D) -&gt; <span class="hljs-built_in">Result</span>&lt;T, D::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        D: Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-comment">// 方法调用PhantomData的deserialize，最后落脚到这里，等于绕了一圈确定T类型</span><br>        T::deserialize(deserializer)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>甚至，因为无状态反序列化太普遍，Serde提供了一种快捷方式，比如<code>next_element_seed</code>的无状态化版本是<code>next_element</code>，就直接帮你传入了<code>PhantomData</code>，使用<code>next_element</code>时，T就通过表达式左值的类型来推断就OK了。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_element</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Option</span>&lt;T&gt;, Self::Error&gt;<br><span class="hljs-keyword">where</span><br>T: Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">self</span>.next_element_seed(PhantomData)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>有了这样的基础，再看<code>visit_enum</code>就清楚了，中间调用<code>match _serde::de::EnumAccess::variant(__data)</code>时，推断出T的类型是<code>__Field</code>，也就是使用的<code>variant</code>版本如下：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant</span></span>&lt;__Field&gt;(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(__Field, Self::Variant), Self::Error&gt;<br><span class="hljs-keyword">where</span><br>__Field: Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">self</span>.variant_seed(PhantomData)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此<code>PhantomData</code>是<code>PhantomData&lt;__Field&gt;</code>的一个“实例”，实现了<code>DeserializeSeed</code>，传到<code>variant_seed</code>中叫做<code>seed</code>，根据<code>PhantomData</code>默认的<code>DeserializeSeed</code>的实现，<code>variant_seed</code>中语句<code>seed.deserialize(deserializer)</code>的本质就是<code>__Field::deserialize(deserializer)</code>，于是产生了具体的<code>__Field</code>值。</p><h2 id="嵌套之路"><a href="#嵌套之路" class="headerlink" title="嵌套之路"></a>嵌套之路</h2><p>清楚了<code>__Field</code>的来历之后，不妨再关注一下tuple中的第二项，<code>VariantAccess-thing</code>，它包含着四个必须实现的方法，概括了可能出现的枚举形态</p><ul><li><code>unit_variant</code>，比如对应<code>Command::Quit</code></li><li><code>newtype_variant</code>，比如对应<code>Command::Rm</code></li><li><code>tuple_variant</code>，比如对应<code>Command::SomeCmd(a, b, c)</code>这种</li><li><code>struct_variant</code>，比如对应<code>Command::&#123;Get, Set&#125;</code></li></ul><p>一个<code>VariantAccess</code>可以看做特定领域的<code>deserializer</code>，这个四个方法和通用的<code>deserialize_*</code>方法的作用类似，由上层调用，提示接下来的数据应该可以按照什么样的规则去解析。所以这里的<code>Visitor</code>和<code>VariantAccess</code>功能上如同一对<code>Deserialize</code>和<code>Deserializer</code>，这不就是一层嵌套吗？</p><p>举两个例子，这两个简单的match分支，<code>Command::Quit</code>和<code>Command::Rm</code> ，就分别提示接下来按照<code>unit_variat</code>和<code>newtype_variant</code>的规则解析数据。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// derive_de.rs</span><br>(__Field::__field2, __variant) =&gt; &#123;<br>    _serde::export::<span class="hljs-built_in">Result</span>::map(_serde::de::VariantAccess::newtype_variant::&lt;<span class="hljs-built_in">String</span>&gt;(__variant), Command::Rm)<br>&#125;<br>(__Field::__field3, __variant) =&gt; &#123;<br>    <span class="hljs-keyword">match</span> _serde::de::VariantAccess::unit_variant(__variant) &#123;<br>        _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>        _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>            <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>        &#125;<br>    &#125;;<br>    _serde::export::<span class="hljs-literal">Ok</span>(Command::Quit)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是复杂一点的<code>Command::Set</code>，它调用的是<code>struct_variant</code>，表明接下来期待的是结构性的枚举。到这里，更明显的嵌套出现了，又新建一个<code>__Field</code>类型，用来保存<code>Command::Get</code>中的<code>Key</code>和<code>Value</code>的标识符信息。然后派出一个<code>visitor</code>，可以从<code>SeqAccess</code>或者<code>MapAccess</code>类型的数据来构建<code>Command::Get</code>的实例。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// derive_de.rs</span><br><br><span class="hljs-meta">#[allow(non_camel_case_types)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">__Field</span></span> &#123; __field0, __field1, __ignore, &#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__FieldVisitor</span></span>;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __FieldVisitor &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = __Field;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter)<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_u64</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: <span class="hljs-built_in">u64</span>) <br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_str</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: &amp;<span class="hljs-built_in">str</span>) <br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_bytes</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: &amp;[<span class="hljs-built_in">u8</span>])<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Field &#123; ... &#125;<br><br><span class="hljs-comment">// 再造一个Command::Set的visitor           </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__Visitor</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    marker: _serde::export::PhantomData&lt;Command&gt;,<br>    lifetime: _serde::export::PhantomData&lt;&amp;<span class="hljs-symbol">&#x27;de</span> ()&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = Command;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter) -&gt; _serde::export::fmt::<span class="hljs-built_in">Result</span> &#123;<br>        _serde::export::Formatter::write_str(__formatter, <span class="hljs-string">&quot;struct variant Command::Set&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// Set由Seq生成</span><br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_seq</span></span>&lt;__A&gt;(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> __seq: __A) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __A::Error&gt;<br>    <span class="hljs-keyword">where</span><br>    __A: _serde::de::SeqAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-comment">// 反序列化两个字段，类型为String，由最后的构建函数推断</span><br>        <span class="hljs-keyword">let</span> __field0 = <span class="hljs-keyword">match</span> <span class="hljs-keyword">match</span> _serde::de::SeqAccess::next_element::&lt;<span class="hljs-built_in">String</span>&gt;(&amp;<span class="hljs-keyword">mut</span> __seq) &#123;<br>            _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>            _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>                <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>            &#125;<br>        &#125; &#123;<br>            _serde::export::<span class="hljs-literal">Some</span>(__value) =&gt; __value,<br>            _serde::export::<span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(_serde::de::Error::invalid_length(<br>                    <span class="hljs-number">0usize</span>,<br>                    &amp;<span class="hljs-string">&quot;struct variant Command::Set with 2 elements&quot;</span>,<br>                ));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">let</span> __field1 = <span class="hljs-keyword">match</span> <span class="hljs-keyword">match</span> _serde::de::SeqAccess::next_element::&lt;<span class="hljs-built_in">String</span>&gt;(&amp;<span class="hljs-keyword">mut</span> __seq) &#123;<br>            _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>            _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>                <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>            &#125;<br>        &#125; &#123;<br>            _serde::export::<span class="hljs-literal">Some</span>(__value) =&gt; __value,<br>            _serde::export::<span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(_serde::de::Error::invalid_length(<br>                    <span class="hljs-number">1usize</span>,<br>                    &amp;<span class="hljs-string">&quot;struct variant Command::Set with 2 elements&quot;</span>,<br>                ));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 一个Set成功返回</span><br>        _serde::export::<span class="hljs-literal">Ok</span>(Command::Set &#123;<br>            key: __field0,<br>            value: __field1,<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 还可以从map生成，省略</span><br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_map</span></span>&lt;__A&gt;(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> __map: __A)<br>&#125;<br><span class="hljs-comment">// 使用struct_variant提示，尝试解析出一个struct的枚举，也就是Set</span><br><span class="hljs-keyword">const</span> FIELDS: &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>] = &amp;[<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>];<br>_serde::de::VariantAccess::struct_variant(<br>    __variant,<br>    FIELDS,<br>    __Visitor &#123;<br>        marker: _serde::export::PhantomData::&lt;Command&gt;,<br>        lifetime: _serde::export::PhantomData,<br>    &#125;,<br>)<br></code></pre></div></td></tr></table></figure><p>因为json中<code>struct</code>和字典表达形式相同，并且key值都包含在序列化数据中，所以不必使用提供的<code>_fields</code>参数，直接交给<code>deserialize_map</code>就足够。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// de.rs</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">struct_variant</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, _fields: &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>], visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;<br><span class="hljs-keyword">where</span><br>V: Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    de::Deserializer::deserialize_map(<span class="hljs-keyword">self</span>.de, visitor)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>deserialize_map</code>自然检查map的开闭标识，然后给予一个实现了<code>MapAccess</code>的结构。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_map</span></span>&lt;V&gt;(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;<br><span class="hljs-keyword">where</span><br>V: Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-comment">// 字典由&#123;开启</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&#x27;&#123;&#x27;</span> &#123;<br>        <span class="hljs-comment">// 调用 visit_map，所以给一个MapAccess，由CommaSeparated实现</span><br>        <span class="hljs-keyword">let</span> value = visitor.visit_map(CommaSeparated::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>))?;<br>        <span class="hljs-comment">// 字典由&#125;结束</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&#x27;&#125;&#x27;</span> &#123;<br>            <span class="hljs-literal">Ok</span>(value)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">Err</span>(Error::ExpectedMapEnd)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">Err</span>(Error::ExpectedMap)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>后面的事情，就是<code>CommaSeparated</code>和<code>visit_map</code>相互配合产生<code>Command::Get</code>了，过程类似<code>Enum</code>和<code>visit_enum</code>的交互，这里就不再详细一步步跟踪了。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>我们用两章的篇幅介绍了反序列化过程。</p><p>第一个关键点，明确角色</p><ul><li><code>Deserialize</code>观察目标类型，制作<code>Visitor</code>，调用<code>Deserializer</code>，交付<code>Visitor</code></li><li><code>Deserialzier</code>和被序列化数据打交道，根据<code>Deserialize</code>的提示，把序列化数据解析成恰当的基础数据结构，交给<code>Visitor</code></li><li><code>Visitor</code>根据<code>Deserializer</code>给的基础数据类型，按既定规则生成目标类型</li></ul><p>第二个关键点，集合类型的反序列化</p><p>当<code>Deserializer</code>被提示接下来的数据可能是由集合类型序列化而来时，所谓的恰当的基础数据结构，就是实现了<code>*Access</code>系列 trait 的结构，代表着某一种特定结构的<code>Deserializer</code>。其实也就只有四个。</p><table><thead><tr><th>Trait</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.serde.rs/serde/de/trait.EnumAccess.html">EnumAccess</a></td><td>重要方法是<code>variant</code>，一次性调用，返回(T, VariantAccess)，判断数据属于哪种枚举</td></tr><tr><td><a href="https://docs.serde.rs/serde/de/trait.VariantAccess.html">VariantAccess</a></td><td>四个必须方法，一次性调用，解析具体的某种枚举</td></tr><tr><td><a href="https://docs.serde.rs/serde/de/trait.MapAccess.html">MapAccess</a></td><td>按照map的风格访问处理已序列化数据，<code>next_key</code>，<code>next_value</code>等</td></tr><tr><td><a href="https://docs.serde.rs/serde/de/trait.SeqAccess.html">SeqAccess</a></td><td>按照seq的风格访问处理已序列化数据，<code>next_element</code></td></tr></tbody></table><p>他们统一的风格就是都使用了<code>fn *_seed()</code>的模式，通过<code>DeserializerSeed</code>，提供有状态反序列化的能力。普通的反序列化场景，往往不需要有状态，因此传入<code>PhantomData</code>，直接使用无状态反序列化。</p><p>Ok，反序列化也介绍到这里吧。如果想要进一步巩固serde，自己写一个data format的<code>Deserializer</code>和<code>Serializer</code>吧。下一篇，我们为redis协议写一个基础的序列化工具。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - deserialize - I</title>
    <link href="/2020/01/06/serde-what-are-you-doing-de-part1/"/>
    <url>/2020/01/06/serde-what-are-you-doing-de-part1/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | Deserialization篇 第一部分</p><a id="more"></a><p>有了serialize的基础，知道了<code>serde data model</code>大概的定位，也知道了访问者模式的应用，接着理解deserialize会更容易一些。</p><p>以<code>serde data model</code>为基础，<code>Serialize</code>是引导者的角色，引导<code>Serde::ser::Serilaizer</code>的实现者<code>serializer</code>去参观内存中的数据，帮助<code>serializer</code>完成序列化。</p><p>现在反序列化，角色关系更加复杂一层。除了<code>Serde::Deserialize</code>，<code>Serde::de::Deserializer</code>，还多一个<code>Serde::de::Visitor</code>。<code>Serde::Deserialize</code>依然是最高级引导者，提示<code>Serde::de::Deserializer</code>去认识已被序列化的数据，并且交给它一个<code>Serde::de::Visitor</code>，随后<code>Serde::de::Deserializer</code>则利用得到的<code>Serde::de::Visitor</code>，为其提供数据，帮助它在内存中构建各种数据结构。</p><p>有了这个大方向，让我们开始瞅瞅反序列化的过程。</p><h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>也从反序列化的源头开始，也就是<code>from_str</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// de.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>    T: Deserialize&lt;<span class="hljs-symbol">&#x27;a</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> deserializer = Deserializer::from_str(s);<br>    <span class="hljs-keyword">let</span> t = T::deserialize(&amp;<span class="hljs-keyword">mut</span> deserializer)?;<br>    <span class="hljs-keyword">if</span> deserializer.input.is_empty() &#123;<br>        <span class="hljs-literal">Ok</span>(t)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">Err</span>(Error::TrailingCharacters)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>from_str</code>首先初始化了叫<code>crate::de::Deserializer</code>的结构，该结构实现了<code>serde::de::Deserializer</code> trait，初始化方法是<code>from_str</code>。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Deserializer</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    input: &amp;<span class="hljs-symbol">&#x27;de</span> <span class="hljs-built_in">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>(input: &amp;<span class="hljs-symbol">&#x27;de</span> <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Deserializer &#123; input &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从这里我们能得出两个结论：</p><ol><li><del>“本直播间允许套娃”</del></li><li><code>deserializer</code>拥有反序列化的数据(或数据引用)</li></ol><p>然后就将创建的<code>deserializer</code>传给一个<code>Deserialize-thing</code>（<code>-thing</code>的写法表示实现某个trait的实例），也就是T，而T在我们编写下列语句时，就已经被推断为<code>Command</code>。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> de_cmd: Command = from_str(&amp;ser_cmd).unwrap();<br></code></pre></div></td></tr></table></figure><p>所以魔法发生在语句<code>let t = T::deserialize(&amp;mut deserializer)?;</code>里面。</p><p>至此我们知道，给<code>T::deserialize</code>一个合适的<code>deserializer</code>，它就会返回一个T类型的实例。</p><h2 id="谁才是工具人？"><a href="#谁才是工具人？" class="headerlink" title="谁才是工具人？"></a>谁才是工具人？</h2><p>一般来讲，被当作参数传入的，很大可能是工具人，就像序列化过程中写作文的<code>serializer</code>。类比一下，<code>deserializer</code>差不多也是个工具人，供<code>serde::Deserialize</code>差遣。不过，<code>deserializer</code>并不是反序列化中最底层的工具人。最终在内存中复现数据结构的，是一个叫做<code>visitor</code>的工具人，被<code>serde::Deserialize</code>构造，然后交给<code>deserializer</code>使用。</p><p>具体一点，<code>T::deserialize</code>要干的事情：</p><ol><li>根据T自身的类型，参照<a href="https://serde.rs/data-model.html">Serde data model</a>，调用<code>deserializer</code>的某个<code>deserialize_*</code>方法，提示<code>deserializer</code>接下来的数据可能是由哪种<code>serde data model</code>序列化而来，你视情况对input做相关的parsing工作，形成一些基础的数据类型。</li><li>调用时，提供一个<code>Visitor-thing</code>，<code>deserializer</code>则调用该<code>visitor</code>的某个<code>visit_*</code>方法，传入经过提示后解析出来的数据，让<code>visitor</code>完成数据结构在内存中的重现。</li></ol><p>要明白这个过程，不妨先看<a href="https://docs.serde.rs/serde/de/trait.Visitor.html">Visitor</a> trait的定义，一个<code>visitor</code>，从诞生起，命运就和<code>Value</code>类型绑定在一起，终其一生，都是个不折不扣的工具人，每个方法，都是一条操作规则，比如，如果放一个<code>bool</code>值到<code>visitor</code>眼前，他就如此这般，产生一个<code>Value</code>；如果放一个<code>SeqAccess</code>结构到<code>visitor</code>眼前， 他就这样那样，产生一个<code>Value</code>。<code>Visitor</code> trait的每个规则的默认实现，是抛出Error::invalid_type，表明<code>Value</code>不能由眼前的数据转换而来。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Visitor</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt;: <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, formatter: &amp;<span class="hljs-keyword">mut</span> Formatter) -&gt; <span class="hljs-built_in">Result</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_bool</span></span>&lt;E&gt;(<span class="hljs-keyword">self</span>, v: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, E&gt;<br>    <span class="hljs-keyword">where</span><br>        E: Error,<br>    &#123; ... &#125;<br>   ...<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_str</span></span>&lt;E&gt;(<span class="hljs-keyword">self</span>, v: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, E&gt;<br>    <span class="hljs-keyword">where</span><br>        E: Error,<br>    &#123; ... &#125;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_seq</span></span>&lt;A&gt;(<span class="hljs-keyword">self</span>, seq: A) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, A::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        A: SeqAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_map</span></span>&lt;A&gt;(<span class="hljs-keyword">self</span>, map: A) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, A::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        A: MapAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_enum</span></span>&lt;A&gt;(<span class="hljs-keyword">self</span>, data: A) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::Value, A::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        A: EnumAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123; ... &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了更好理解<code>visitor</code>，来看<code>derive_de.rs</code>文件，一部分代码如下，作用是根据数据生成具体的枚举标志符，表示<code>get, set, rm, quit</code>中的哪一个(这么做是为了避免复制为String，提高效率)。这里训练了一个叫做<code>__FieldVisitor</code>的工具人，专门产生<code>__Field</code>类型。一个<code>__Field</code>可以来自于u64、str、bytes，转换逻辑都很直白，match就完事儿了</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[allow(non_camel_case_types)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">__Field</span></span> &#123;<br>    __field0,<br>    __field1,<br>    __field2,<br>    __field3,<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__FieldVisitor</span></span>;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __FieldVisitor &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = __Field;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(<br>        &amp;<span class="hljs-keyword">self</span>,<br>        __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter,<br>    ) -&gt; _serde::export::fmt::<span class="hljs-built_in">Result</span> &#123;<br>        _serde::export::Formatter::write_str(__formatter, <span class="hljs-string">&quot;variant identifier&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_u64</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: <span class="hljs-built_in">u64</span>) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __E&gt;<br>    <span class="hljs-keyword">where</span><br>    __E: _serde::de::Error,<br>    &#123;<br>        <span class="hljs-keyword">match</span> __value &#123;<br>            <span class="hljs-number">0u64</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field0),<br>            <span class="hljs-number">1u64</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field1),<br>            <span class="hljs-number">2u64</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field2),<br>            <span class="hljs-number">3u64</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field3),<br>            _ =&gt; _serde::export::<span class="hljs-literal">Err</span>(_serde::de::Error::invalid_value(<br>                _serde::de::Unexpected::Unsigned(__value),<br>                &amp;<span class="hljs-string">&quot;variant index 0 &lt;= i &lt; 4&quot;</span>,<br>            )),<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_str</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: &amp;<span class="hljs-built_in">str</span>) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __E&gt;<br>    <span class="hljs-keyword">where</span><br>    __E: _serde::de::Error,<br>    &#123;<br>        <span class="hljs-keyword">match</span> __value &#123;<br>            <span class="hljs-string">&quot;Set&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field0),<br>            <span class="hljs-string">&quot;Get&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field1),<br>            <span class="hljs-string">&quot;Rm&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field2),<br>            <span class="hljs-string">&quot;Quit&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field3),<br>            _ =&gt; _serde::export::<span class="hljs-literal">Err</span>(_serde::de::Error::unknown_variant(<br>                __value, VARIANTS,<br>            )),<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_bytes</span></span>&lt;__E&gt;(<br>        <span class="hljs-keyword">self</span>,<br>        __value: &amp;[<span class="hljs-built_in">u8</span>],<br>    ) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __E&gt;<br>    <span class="hljs-keyword">where</span><br>    __E: _serde::de::Error,<br>    &#123;<br>        <span class="hljs-keyword">match</span> __value &#123;<br>            <span class="hljs-string">b&quot;Set&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field0),<br>            <span class="hljs-string">b&quot;Get&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field1),<br>            <span class="hljs-string">b&quot;Rm&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field2),<br>            <span class="hljs-string">b&quot;Quit&quot;</span> =&gt; _serde::export::<span class="hljs-literal">Ok</span>(__Field::__field3),<br>            _ =&gt; &#123;<br>                <span class="hljs-keyword">let</span> __value = &amp;_serde::export::from_utf8_lossy(__value);<br>                _serde::export::<span class="hljs-literal">Err</span>(_serde::de::Error::unknown_variant(<br>                    __value, VARIANTS,<br>                ))<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>余下的未实现的<code>visit_*</code>就保持默认实现，抛出错误，表明无法完成转换。</p><p>现在有了这个工具人，自然就可以为<code>__Field</code>实现<code>Deserialize</code> trait，派出工具人去执行任务，所以上面的代码，紧接着的就是<code>Deserialize</code>  trait的实现：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Field &#123;<br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;__D&gt;(__deserializer: __D) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, __D::Error&gt;<br>    <span class="hljs-keyword">where</span><br>    __D: _serde::Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>故事开始时，我们知道，给<code>T::deserialize</code>一个合适的<code>deserializer</code>，它就会返回一个T类型的实例。所以为<code>__Field</code>实现<code>Deserialize</code>  trait的意思就是，给<code>__Field</code>写一个<code>deserialize</code>方法，保证调用<code>__Field::deserialze(&amp;mut deserializer)</code>之后，会返回一个<code>__Field::__field0</code>或者<code>__filed1</code>等等。</p><p>我们发现，具体的实现其实非常简单，就是调用传入的<code>deserializer</code>的 <code>deserialize_identifier</code>方法，并且为其提供刚才构造的<code>__FieldVisitor</code>。</p><p><code>deserialize_identifier</code>在这儿被使用，因为我们知道<code>__Field</code>的实质，是结构体字段、枚举的标识。所以我们<strong>提示</strong><code>deserializer</code>我们需要的是一个标识，具体<code>deserializer</code>怎么处理，不同的数据格式都有自己的说法。比如这里的json知道，哦，标识啊，当初序列化时就直接把它当成字符串对待了，所以接下来的input数据，应该会以字符串开头，所以<code>deserializer</code>直接交给字符串的反序列化去处理。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_identifier</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;<br><span class="hljs-keyword">where</span><br>V: Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">self</span>.deserialize_str(visitor)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而<code>deserialize_str</code>的实现中，主要做了两个工作：</p><ol><li>把接下来的input数据解析出一个字符串，也就是期待input以引号开头，<code>&quot;xxx&quot;</code>，解析出<code>xxx</code>，如果顺利，<code>xxx</code>应该是<code>Set、Get、Rm、Quit</code>中的一个。</li><li>既然解析出了&amp;str类型的数据，那么就应该期待，<code>visitor</code>可以拿这个&amp;str去构建一个<code>__Field</code>实例。所以<code>deserializer_str</code>就会使用之前<code>__FieldVisitor</code>的<code>visit_str</code>方法，让工具人自己去处理。这里实际调用的<code>visit_borrowed_str</code>，其<a href="https://docs.serde.rs/src/serde/de/mod.rs.html#1484-1490">默认实现</a>就是调用<code>visit_str</code>。分得如此细，和生命周期、性能等有关，这里暂不关注。<code>visit_str</code>方法自然会根据<code>xxx</code>返回相应的<code>__Field::__fieldx</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_str</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, visitor: V) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;<br><span class="hljs-keyword">where</span><br>V: Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    visitor.visit_borrowed_str(<span class="hljs-keyword">self</span>.parse_string()?)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到这里其实已经看到了一个局部相对完整的序列化过程，但也只反序列化了一个标识符。下面会再看我们<code>Command</code>到底是怎么构建的，过程的骨架其实也就这样了。</p><p>有个题外话，注意这里从数据中解析出str的函数，<code>parse_string</code>，也由<code>deserializer</code>实现，但是官方有提醒，<strong>Serde框架内，实际上并不包含解析</strong>，更有效率的方式是使用专门的解析库来帮助实现<code>deserializer</code></p><blockquote><p>// SERDE IS NOT A PARSING LIBRARY. This impl block defines a few basic parsing<br>// functions from scratch. More complicated formats may wish to use a dedicated<br>// parsing library to help implement their Serde deserializer</p></blockquote><h2 id="Command的反序列化"><a href="#Command的反序列化" class="headerlink" title="Command的反序列化"></a>Command的反序列化</h2><p>因为我们想要反序列化<code>Command</code>，所以给<code>Command</code>也要整一个visitor，其结构为被命名为<code>__Visitor</code>。看上去这个visitor有两个字段，<code>marker</code>和<code>lifetime</code>，<code>PhantomData</code>类型，看上去就很厉害，但是我没找到使用这个两个字段的代码，应该对我们理解总体逻辑没有太多阻碍，所以这里暂时跳过吧。（实际上我至今还是没有理解这个marker的作用是啥，<a href="https://docs.rs/crate/serde_derive/1.0.103/source/src/de.rs">源码</a>中也没有相关的注释）</p><p>为<code>__Visitor</code>实现<code>Visitor</code> trait 的这一段代码看上去很长，有点唬人，但其实是一个match+嵌套，所以先撇开嵌套的内容，看主体的match。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__Visitor</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    marker: _serde::export::PhantomData&lt;Command&gt;,<br>    lifetime: _serde::export::PhantomData&lt;&amp;<span class="hljs-symbol">&#x27;de</span> ()&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = Command;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter) -&gt; _serde::export::fmt::<span class="hljs-built_in">Result</span> &#123;<br>        _serde::export::Formatter::write_str(__formatter, <span class="hljs-string">&quot;enum Command&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// Command由“代表枚举的数据”转换而来</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_enum</span></span>&lt;__A&gt;(<span class="hljs-keyword">self</span>, __data: __A) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __A::Error&gt;<br>    <span class="hljs-keyword">where</span><br>    __A: _serde::de::EnumAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-comment">// 重点步骤，这里解析出数据具体是哪个枚举，后文会再回顾这里的操作</span><br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">match</span> _serde::de::EnumAccess::variant(__data) &#123;<br>            _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>            _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>                <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>            &#125;<br>        &#125; &#123;<br>            (__Field::__field0, __variant) =&gt; &#123;<br>                <span class="hljs-comment">// 开始嵌套，如果是Set类型，就再利用Field模式，解析Key、Value的identifier</span><br>                <span class="hljs-comment">// 然后再新造一个Set的visitor，利用后续的数据构建Command::Set</span><br>            &#125;<br>            (__Field::__field1, __variant) =&gt; &#123; <span class="hljs-comment">// Get基本步骤同Set &#125;</span><br>            (__Field::__field2, __variant) =&gt; &#123;...&#125;              <br>            (__Field::__field3, __variant) =&gt; &#123;...&#125;   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以<code>Command</code>的<code>visitor</code>的透露的大体信息是，<code>deserializer</code>只有给我提供一个<code>EnumAccess&lt;&#39;de&gt;-thing</code>这种数据，我才能构建一个<code>Command</code>，具体的做法，就是利用之前的<code>__Field</code>相关结构，判断是具体哪种<code>Command</code>后，再采用不同的策略构建。这里先不深究细节，我们接着走流程。</p><p><code>Command</code>的<code>visitor</code>整好了，也有相似的入口来使用，<code>Command</code>通过<code>deserialize_enum</code>提示<code>deserializer</code>，接下来的数据应该是为enum准备，你看着办，顺便告诉你，这个enum的名字是<code>&quot;Command”</code>，枚举的项目是<code>Set、Get、Rm、Quit</code>四种。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[automatically_derived]</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> Command &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;__D&gt;(__deserializer: __D) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, __D::Error&gt;<br>    <span class="hljs-keyword">where</span><br>    __D: _serde::Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-keyword">const</span> VARIANTS: &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>] = &amp;[<span class="hljs-string">&quot;Set&quot;</span>, <span class="hljs-string">&quot;Get&quot;</span>, <span class="hljs-string">&quot;Rm&quot;</span>, <span class="hljs-string">&quot;Quit&quot;</span>];<br>        _serde::Deserializer::deserialize_enum(<br>            __deserializer,<br>            <span class="hljs-string">&quot;Command&quot;</span>,<br>            VARIANTS,<br>            __Visitor &#123;<br>                marker: _serde::export::PhantomData::&lt;Command&gt;,<br>                lifetime: _serde::export::PhantomData,<br>            &#125;,<br>        )<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>deserialize_enum</code>是怎么实现的呢？json格式的<code>deserializer</code>被提示接下来的数据是为enum准备的之后，立刻明白，一个enum，经过合法序列化后，只能由<code>&quot;</code>或者<code>&#123;</code>开头，所以分两种情况，围绕自己的input数据，为<code>visitor</code>的创建提供基础材料。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize_enum</span></span>&lt;V&gt;(<br>        <span class="hljs-keyword">self</span>,<br>        _name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>,<br>        _variants: &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>],<br>        visitor: V,<br>    ) -&gt; <span class="hljs-built_in">Result</span>&lt;V::Value&gt;<br>    <span class="hljs-keyword">where</span><br>        V: Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.peek_char()? == <span class="hljs-string">&#x27;&quot;&#x27;</span> &#123;<br>            <span class="hljs-comment">// Visit a unit variant.</span><br>            visitor.visit_enum(<span class="hljs-keyword">self</span>.parse_string()?.into_deserializer())<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&#x27;&#123;&#x27;</span> &#123;<br>            <span class="hljs-comment">// Visit a newtype variant, tuple variant, or struct variant.</span><br>            <span class="hljs-keyword">let</span> value = visitor.visit_enum(Enum::new(<span class="hljs-keyword">self</span>))?;<br>            <span class="hljs-comment">// Parse the matching close brace.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.next_char()? == <span class="hljs-string">&#x27;&#125;&#x27;</span> &#123;<br>                <span class="hljs-literal">Ok</span>(value)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-literal">Err</span>(Error::ExpectedMapEnd)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">Err</span>(Error::ExpectedEnum)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>提供什么样的材料呢？这要看<code>deserializer</code>具体选用<code>visitor</code>的哪个方法。这里使用的<code>visit_enum</code>方法(当然<code>__Visitor</code>也只实现了<code>visit_enum</code>方法)，所以按照其签名，应该为其提供一个实现<code>EnumAccess</code> trait的东西。</p><ul><li><p><code>self.parse_string()?.into_deserializer()</code>提供的流程是，分析出<code>str</code>，经过<code>into_deserializer()</code>变为<a href="https://docs.rs/serde/1.0.104/serde/de/value/struct.StrDeserializer.html">StrDeserializer</a>，而一个<code>StrDeserializer</code><a href="https://docs.rs/serde/1.0.104/src/serde/de/value.rs.html#405-418">默认实现</a>了<code>EnumAccess</code>。</p></li><li><p><code>Enum::new(self)</code>提供的流程就很直接，自定义了一个实现<code>EnumAccess</code>的结构叫做<code>Enum</code></p></li></ul><p>所以到这里，上一节分析的”工具人套工具人”的骨架就分析完了。复习一下， 总体过程是，<code>Command::deserialize</code>通过调用<code>deserialize_enum</code>方法提示<code>deserializer</code>，接下来的序列化数据是为enum准备的，并且为<code>deserializer</code>提供一个实现了<code>visit_enum</code>(接受<code>EnumAccess-thing</code>，返还<code>Command</code>)的<code>visitor</code>。于是<code>deserializer</code>根据json的规则知道，接下的序列化数据应该会是<code>&quot;</code>或者<code>&#123;</code>开头，分为两种情况，制作出一个<code>EnumAccess-thing</code>，然后交给<code>visit_enum</code>去构建<code>Command</code>。</p><p>这时，我们更详细地去看这个过程，<code>visit_enum</code>是怎么做的，<code>EnumAccess-thing</code>又是如何与它配合的。</p><h2 id="visit-enum里"><a href="#visit-enum里" class="headerlink" title="visit_enum里"></a>visit_enum里</h2><p>为了方便叙述，把<code>visit_enum</code>再抄到这里</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_enum</span></span>&lt;__A&gt;(<span class="hljs-keyword">self</span>, __data: __A) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __A::Error&gt;<br><span class="hljs-keyword">where</span><br>__A: _serde::de::EnumAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-keyword">match</span> _serde::de::EnumAccess::variant(__data) &#123;<br>        _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>        _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>            <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>        &#125;<br>    &#125; &#123;<br>        (__Field::__field0, __variant) =&gt; &#123;...&#125;,<br>        (__Field::__field1, __variant) =&gt; &#123;...&#125;,<br>        (__Field::__field2, __variant) =&gt; &#123;...&#125;,<br>        (__Field::__field3, __variant) =&gt; &#123;...&#125;,<br>    &#125;<br>&#125;<br>           <br></code></pre></div></td></tr></table></figure><p>同时也附上<code>EnumAccess</code> trait的定义</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// https://docs.serde.rs/serde/de/trait.EnumAccess.html</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">EnumAccess</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt;: <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span>: Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Variant</span></span>: VariantAccess&lt;<span class="hljs-symbol">&#x27;de</span>, Error = Self::Error&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant_seed</span></span>&lt;V&gt;(<br>        <span class="hljs-keyword">self</span>, <br>        seed: V<br>    ) -&gt; <span class="hljs-built_in">Result</span>&lt;(V::Value, Self::Variant), Self::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        V: DeserializeSeed&lt;<span class="hljs-symbol">&#x27;de</span>&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(V, Self::Variant), Self::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        V: Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-comment">// 默认实现</span><br>        <span class="hljs-keyword">self</span>.variant_seed(PhantomData)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一开始，对<code>EnumAccess-thing</code>调用<code>variant</code>方法，它返回一个tuple，从后续match分支可以推断，第一项是之前定义的<code>__Field</code>，第二项，从<code>variant</code>方法的签名可知，是<code>VariantAccess-thing</code>。自然地，通过匹配<code>__Field</code>，就可以知道数据本身是Set、Get、Rm、Quit中的哪一个，然后继续利用产生的<code>VariantAccess-thing</code>做继续的处理……但是，等一等，这是怎么办到的？什么时候利用数据反序列化出了一个<code>__Field</code>？<code>__Field::deserialize</code>在哪儿被偷偷摸摸地调用的了？</p><p>要解决这个疑问，自然要看<code>variant</code>的内部，所以自然要看具体的<code>EnumAccess</code>实现</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// de.rs</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Enum</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;de</span>: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    de: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;de</span>&gt; Enum&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(de: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Enum &#123; de &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>, <span class="hljs-symbol">&#x27;a</span>&gt; EnumAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> Enum&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Variant</span></span> = <span class="hljs-keyword">Self</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">variant_seed</span></span>&lt;V&gt;(<span class="hljs-keyword">self</span>, seed: V) -&gt; <span class="hljs-built_in">Result</span>&lt;(V::Value, Self::Variant)&gt;<br>    <span class="hljs-keyword">where</span><br>        V: DeserializeSeed&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>    &#123;<br>        <span class="hljs-keyword">let</span> val = seed.deserialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.de)?;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.de.next_char()? == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br>            <span class="hljs-literal">Ok</span>((val, <span class="hljs-keyword">self</span>))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">Err</span>(Error::ExpectedMapColon)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我的第一反应，自然是找<code>__Field::deserialize</code>方法。但是只找到一个<code>seed.deserialize</code>，那么不负责任地一猜，这个seed应该是<code>__Field</code>的一个实例，但是被当场打脸，因为由<code>variant</code>传入的，又是个<code>PhantomData</code>，所以这个东西是铁定绕不过了？还有那个<code>variant_seed</code>方法中要求的<code>DeserializeSeed</code>又是什么东西？这个过程到底怎么回事？</p><p>为了控制一下篇幅，这些疑问下一篇继续解答。</p><p>到这里，我们其实已经收获颇丰，知道了visitor的存在，也大概清楚了三种角色的交互逻辑。后续的问题，实际上是反序列化一些集合类型时的所需要的细节。继续之前，先休息一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - serialize</title>
    <link href="/2020/01/01/serde-what-are-you-doing-ser/"/>
    <url>/2020/01/01/serde-what-are-you-doing-ser/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | Serialization篇</p><a id="more"></a><p>关于serialize的过程，文章 <a href="https://www.joshmcguigan.com/blog/understanding-serde/">understanding serde</a> 讲得非常详细、非常好，用的例子还是真实的源码。推荐。</p><p>这篇文章最大的价值，是解释清楚了什么是所谓的<a href="https://serde.rs/data-model.html">serde data model</a>。</p><p>它本身并不是一种中间的数据结构，而是一种纯粹的概念上的分类。</p><p>通常，对于序列化和反序列化，一个自然的想法，是建立一个中间抽象层，把Rust中的数据结构映射成中间的抽象层，然后再基于这个统一的抽象层，比如一个大的enum，然后对enum中的项目，则可以采用不同的翻译方式，转化成json、yaml等格式。</p><p>有了这个想法，再看 <code>Serialize</code> 和 <code>Serializer</code> trait的名字，望文生义都觉得没什么不妥。<code>Serialize</code>负责将Rust的数据结构转换到中间层，<code>Serializer</code>再负责把中间层翻译成具体的json、yaml。而中间层就是<code>serde data model</code>。这个模式其实很常见，连rust的编译都没逃过，想想Rustc、LLVM、MIR，是不是呼应上了？都呼应上了。</p><p>但是事情并不是这样的。</p><p>带着好奇，不妨来看代码。接下来用的，是在准备篇中介绍的简化版 serde_json。</p><h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>序列化的开始是在<code>bin/inpsect.rs</code>调用了<code>serde_example::to_string</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// inspect.rs</span><br><span class="hljs-keyword">let</span> ser_cmd = to_string(&amp;cmd).unwrap();<br></code></pre></div></td></tr></table></figure><p><code>to_string</code> 构建了一个<code>crate::ser::Serializer</code>类型的实例<code>serialzer</code>，包含一个字段<code>output</code>，类型为<code>String</code>，可以猜到，接下来的序列化，就是<code>serialzer</code>的一场”看图作文”练习，根据内存中的数据，按照对应的格式，写到<code>self.output</code>中。</p><p>这个动作开始于<code>value.serialize(&amp;mut serializer)?;</code>，魔法的开始之地，其中<code>value</code>是传入的<code>Command</code>实例。<code>Command</code>的<code>serialze</code>方法，由derive自动生成，所以接下来要看<code>derive_ser.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// ser.rs</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Serializer</span></span> &#123;<br>    output: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_string</span></span>&lt;T&gt;(value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>&gt;<br><span class="hljs-keyword">where</span><br>    T: Serialize,<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> serializer = Serializer &#123;<br>        output: <span class="hljs-built_in">String</span>::new(),<br>    &#125;;<br>    value.serialize(&amp;<span class="hljs-keyword">mut</span> serializer)?;<br>    <span class="hljs-literal">Ok</span>(serializer.output)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="从serde-Serialize的角度"><a href="#从serde-Serialize的角度" class="headerlink" title="从serde::Serialize的角度"></a>从serde::Serialize的角度</h2><p>之前我们猜，<code>serde::Serialize</code>负责将Rust的原生类型整合为一个中间类型。现在就可以看到实际发生的，和猜想的有什么不同。<code>serialize</code>方法一进，劈头盖脸就是一个<code>match</code>，结构一目了然，四个枚举项，就问你们谁要序列化？</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> _IMPL_SERIALIZE_FOR_Command: () = &#123;<br>    <span class="hljs-meta">#[allow(unknown_lints)]</span><br>    <span class="hljs-meta">#[allow(rust_2018_idioms)]</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> serde <span class="hljs-keyword">as</span> _serde;<br>    <span class="hljs-meta">#[automatically_derived]</span><br>    <span class="hljs-keyword">impl</span> _serde::Serialize <span class="hljs-keyword">for</span> Command &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize</span></span>&lt;__S&gt;(<br>            &amp;<span class="hljs-keyword">self</span>,<br>            __serializer: __S,<br>        ) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;__S::<span class="hljs-literal">Ok</span>, __S::Error&gt;<br>        <span class="hljs-keyword">where</span><br>            __S: _serde::Serializer,<br>        &#123;<br>            <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> &#123;<br>                Command::Set &#123; <span class="hljs-keyword">ref</span> key, <span class="hljs-keyword">ref</span> value &#125; =&gt; ...<br>                Command::Get &#123; <span class="hljs-keyword">ref</span> key &#125; =&gt; ...<br>                Command::Rm(<span class="hljs-keyword">ref</span> __field0) =&gt; ...<br>                Command::Quit =&gt; ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>比如<code>Command::Set</code>需要序列化，主体结构也非常明晰，给需要写作文的<code>serializer</code>安排四个步骤：</p><ol><li><code>serialize_struct_variant</code>，现在要序列化一个结构型的枚举项，告诉你几个关键信息好吧，枚举类型名称叫<code>&quot;Command&quot;</code>，当前枚举项排行第一，名字叫<code>&quot;Set”</code>，共有两个字段。好了，写去吧。写好了？过程中没什么意外发生吧，我检查检查，em……，Ok，在此基础上给你第二个任务 (这里的返回类型是<code>SerializeStructVariant</code>，之后再谈)；</li><li><code>serialize_field</code>，接着序列化结构中的字段，字段名为”key”，实际内容也给你，写去吧。写好了？我检查检查，em……，Ok，在此基础上给你第三个任务；</li><li><code>serialize_field</code>，还是序列化结构中的字段，字段名为”value”，实际内容也给你，写去吧。写好了？我检查检查，em……，Ok，在此基础上给你第四个任务；</li><li><code>end</code>，结束了，没什么数据给你了，你最后收拾收拾，给小作文润色润色吧。</li></ol><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// ... </span><br><span class="hljs-comment">// after Command::Set was matched</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> __serde_state = <span class="hljs-keyword">match</span> _serde::Serializer::serialize_struct_variant(<br>    __serializer,<br>    <span class="hljs-string">&quot;Command&quot;</span>,<br>    <span class="hljs-number">0u32</span>,<br>    <span class="hljs-string">&quot;Set&quot;</span>,<br>    <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>,<br>) &#123;<br>    _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>    _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">match</span> _serde::ser::SerializeStructVariant::serialize_field(<br>    &amp;<span class="hljs-keyword">mut</span> __serde_state,<br>    <span class="hljs-string">&quot;key&quot;</span>,<br>    key,<br>) &#123;<br>    _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>    _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">match</span> _serde::ser::SerializeStructVariant::serialize_field(<br>    &amp;<span class="hljs-keyword">mut</span> __serde_state,<br>    <span class="hljs-string">&quot;value&quot;</span>,<br>    value,<br>) &#123;<br>    _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>    _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>    &#125;<br>&#125;;<br>_serde::ser::SerializeStructVariant::end(__serde_state);<br></code></pre></div></td></tr></table></figure><p>我们看到，<code>serde::Serialize</code>没有想我们预想中的那样，在内存中新开辟空间来存放”中间类型”数据，而是把中间类型体现在对<code>serializer</code>的使用上，<code>Serialize</code>看出来，当前数据属于<code>struct_variant</code>，所以直接调用<code>serialize</code>中对应的方法。同理，对<code>Command::Rm</code>，调用的是<code>newtype_variant</code>，对<code>Command::Quit</code>调用的是<code>unit_variant</code>。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">Command::Rm(<span class="hljs-keyword">ref</span> __field0) =&gt; &#123;<br>    _serde::Serializer::serialize_newtype_variant(<br>        __serializer,<br>        <span class="hljs-string">&quot;Command&quot;</span>,<br>        <span class="hljs-number">2u32</span>,<br>        <span class="hljs-string">&quot;Rm&quot;</span>,<br>        __field0,<br>    )<br>&#125;<br><br>Command::Quit =&gt; _serde::Serializer::serialize_unit_variant(<br>    __serializer,<br>    <span class="hljs-string">&quot;Command&quot;</span>,<br>    <span class="hljs-number">3u32</span>,<br>    <span class="hljs-string">&quot;Quit&quot;</span>,<br>)<br></code></pre></div></td></tr></table></figure><p>所以，<code>serde data model</code>是<code>serde::Serialize</code>和<code>serde::ser::Serializer</code>共同承认的一套概念。<code>serde::ser::Serializer</code>用方法的形式，明确自己对某个<code>data model</code>的处理方式。而<code>serde::Serialize</code>则负责观察数据，将其分类，告知、提示<code>serde::ser::Serializer</code>该怎么做，即调用它的方法。这个过程中，数据只有一份。所以，如果对设计模式熟悉，这可以看成是访问者模式的一种应用。</p><h2 id="从serde-ser-Serializer的角度"><a href="#从serde-ser-Serializer的角度" class="headerlink" title="从serde::ser::Serializer的角度"></a>从serde::ser::Serializer的角度</h2><p>到这里，我们该看<code>serialzier</code>具体是怎么写作文的了。</p><p>第一个任务，<code>serialize_struct_variant</code>。根据json，<code>Command::Set&#123; key: &quot;A&quot;, val: &quot;42&quot; &#125;</code>表现为<code>&#123;&quot;Set&quot;:&#123;&quot;key&quot;:&quot;A&quot;,&quot;value&quot;:&quot;42&quot;&#125;&#125;</code>，所以忽略名称<code>&quot;Command&quot;</code> 以及枚举项的位置。作文起手，单走一个<code>&#123;</code>，接一手字符串&amp;str<code>“Set”</code>的序列化小作文。关于字符串的<code>serde::Serialize</code>已经在<a href="https://docs.serde.rs/src/serde/ser/impls.rs.html#43-51">Serde crate内部实现</a>，其实也很容易猜到，实现调用给定<code>serializer</code>的<code>serialze_str</code>方法，为字符传类型添加引号。到这里，<code>self.output</code>的值为<code>&#123;&quot;Set&quot;</code>，最后再接一个<code>&quot;:&#123;&quot;</code>形成 <code>&#123;&quot;Set&quot;:&#123;</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// ser.rs</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_struct_variant</span></span>(<br>    <span class="hljs-keyword">self</span>,<br>    _name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>,<br>    _variant_index: <span class="hljs-built_in">u32</span>,<br>    variant: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>,<br>    _len: <span class="hljs-built_in">usize</span>,<br>) -&gt; <span class="hljs-built_in">Result</span>&lt;Self::SerializeStructVariant&gt; &#123;<br>    <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;&#123;&quot;</span>;<br>    variant.serialize(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>)?;<br>    <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;:&#123;&quot;</span>;<br>    <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">self</span>)<br>&#125;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_str</span></span>(<span class="hljs-keyword">self</span>, v: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;\&quot;&quot;</span>;<br>    <span class="hljs-keyword">self</span>.output += v;<br>    <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;\&quot;&quot;</span>;<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如前所说，<code>serialize_struct_variant</code>返回的应该是一个<code>SerializeStructVariant</code>类型，这其实是一个trait，<code>ser.rs</code>为当前的<code>serializer</code>实现了该trait，所以返回的是<code>Ok(self)</code></p><p>和<code>SerializeStructVariant</code>类似的，有下面这些，定义在<a href="https://docs.serde.rs/serde/ser/index.html#traits">Serde中ser模组</a>：</p><table><thead><tr><th>Trait</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeMap.html">SerializeMap</a></td><td>Returned from <code>Serializer::serialize_map</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeSeq.html">SerializeSeq</a></td><td>Returned from <code>Serializer::serialize_seq</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeStruct.html">SerializeStruct</a></td><td>Returned from <code>Serializer::serialize_struct</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeStructVariant.html">SerializeStructVariant</a></td><td>Returned from <code>Serializer::serialize_struct_variant</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeTuple.html">SerializeTuple</a></td><td>Returned from <code>Serializer::serialize_tuple</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeTupleStruct.html">SerializeTupleStruct</a></td><td>Returned from <code>Serializer::serialize_tuple_struct</code>.</td></tr><tr><td><a href="https://docs.serde.rs/serde/ser/trait.SerializeTupleVariant.html">SerializeTupleVariant</a></td><td>Returned from <code>Serializer::serialize_tuple_variant</code>.</td></tr></tbody></table><p>他们共同的特点，返回自一些序列化集合类型时所用的方法。目的是支持有状态的序列化，比如你可以在返回的结构里记录接下来是否是处理集合的第一项，以此来控制序列化中分隔符的使用。</p><p>再聚焦到我们使用到的<code>SerializeStructVariant</code>上，必须的两个方法是<code>serialize_field</code>，<code>end</code>，这两个方法被<code>serde::Serialize</code>调用过，用于安排作文写作的2、3、4步。</p><p>在<code>serialize_field</code>中，实际上并没有记录状态，因为当前简化版只支持紧密的json格式，所以可以通过看前一个字符是不是<code>&#123;</code>来判断，是否在处理集合的第一项内容，进而决定要不要加<code>,</code>分割。</p><p><code>end</code>就更简单了，小作文用<code>&#125;&#125;</code>收尾搞定。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ser::SerializeStructVariant <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Serializer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Ok</span></span> = ();<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = Error;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize_field</span></span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, key: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>, value: &amp;T) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;<br>    <span class="hljs-keyword">where</span><br>        T: ?<span class="hljs-built_in">Sized</span> + Serialize,<br>    &#123;<br>        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.output.ends_with(<span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>            <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;,&quot;</span>;<br>        &#125;<br>        key.serialize(&amp;<span class="hljs-keyword">mut</span> **<span class="hljs-keyword">self</span>)?;<br>        <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;:&quot;</span>;<br>        value.serialize(&amp;<span class="hljs-keyword">mut</span> **<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">end</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">self</span>.output += <span class="hljs-string">&quot;&#125;&#125;&quot;</span>;<br>        <span class="hljs-literal">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此，<code>serialzer.output</code>已经变成我们想要的样子。<code>&#123;&quot;Set&quot;:&#123;&quot;key&quot;:&quot;A&quot;,&quot;value&quot;:&quot;42&quot;&#125;&#125;</code></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>起点，有一个，Rust的数据据结构。终点，有很多，json、yaml、toml、etc。</p><p>面对这个一对多的关系，通常都会想给Rust的数据结构做一个外层包装，然后各个下游的格式处理器，只和有限的数据结构做对接。这样逻辑上没有问题，但是在做包装的过程中，可能产生很多的内存分配、销毁、数据复制。</p><p>仔细想想，我们包装的目的，实际上就是对数据做分类，所以直接把这些类别用函数的形式固定，避免在内存中再造数据结构的计算开销。<code>serde data model</code>把Rust的数据类型分为29种，对应到<code>Serializer::serialze_*()</code>系列方法，搭配访问者模式，保证数据只在一个地方，然后用<code>Serialize</code>去驱动，帮助<code>serializer</code>完成对数据的序列化。</p><p>通过Serialize过程的观察，我们可以得到这样一条脉络，因为关注性能，所以要保证尽量减少新数据的产生，所以用访问者模式，由<code>serde::Serialize</code>带领<code>serializer</code>对原始数据参观一圈，一边走，一遍告诉<code>serializer</code>，这是A，这是B，然后小作家、小画家<code>serializer</code>就据此构建自己的作品。参观完，<code>serialzer</code>的作品也大功告成。</p><p>好了，Serialize就讲到这里。下期Deserialize再见。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serde你在干什么 - 环境准备</title>
    <link href="/2019/12/29/serde-what-are-you-doing-prepare/"/>
    <url>/2019/12/29/serde-what-are-you-doing-prepare/</url>
    
    <content type="html"><![CDATA[<p>serde 源码解析 | 准备篇</p><a id="more"></a><p>最近做一个练习项目，要求利用serde，为Redis Simple Protocol写一个序列化、反序列化工具。</p><p>理解Redis Simple Protocol倒是不难，可是这个serde，人都给我看蒙了。尤其在看反序列化过程的时候，心态一度爆炸，写下了这样的感想：</p><blockquote><p>太复杂了</p><p>太TM复杂了</p><p>想吼想哭想闹</p><p>想吃垃圾食品</p><p>想一瞬间变成天上乌漆嘛黑的冰雹云</p><p>轰他娘的山本联队</p></blockquote><p>最后总算硬着头皮写出了一版。记录下这个过程。</p><p>要了解serde，光看文档难度还是太高了，像是读词典小说，文学上想想《哈扎尔辞典》，游戏上想想宫崎英高养起来的大批”魂学家”，就是那种支离破碎的感觉。所以还原为时间顺序，一步步理解起来更容易。官网给出了一个简化的json样例，叫<a href="https://github.com/serde-rs/example-format">serde-example</a>，我的学习就是基于这份代码。按照下面的步骤，不妨先把环境搭建起来。</p><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>将仓库克隆到本地，修改<code>cargo.toml、ser.rs、de.rs</code>三个文件，支持edition-2018，也随意升级一下serde版本，没什么关系。这个时候<code>cargo check</code>应该可以通过了。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// cargo.toml</span><br>[package]<br>name = <span class="hljs-string">&quot;serde-example&quot;</span><br>edition = <span class="hljs-string">&quot;2018&quot;</span>  <span class="hljs-comment">// 新增edition，使用2018的标准</span><br>version = <span class="hljs-string">&quot;0.1.0&quot;</span><br>authors = [<span class="hljs-string">&quot;David Tolnay &lt;dtolnay@gmail.com&gt;&quot;</span>]<br>license = <span class="hljs-string">&quot;MIT OR Apache-2.0&quot;</span><br>description = <span class="hljs-string">&quot;An example Serializer and Deserializer data format for Serde&quot;</span><br>repository = <span class="hljs-string">&quot;https://github.com/serde-rs/example-format&quot;</span><br>documentation = <span class="hljs-string">&quot;https://serde.rs/data-format.html&quot;</span><br>keywords = [<span class="hljs-string">&quot;serde&quot;</span>]<br>categories = [<span class="hljs-string">&quot;encoding&quot;</span>]<br>publish = <span class="hljs-literal">false</span><br><br>[dependencies]<br>serde = &#123; version = <span class="hljs-string">&quot;1.0.103&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;  <span class="hljs-comment">// 修改</span><br><br></code></pre></div></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// ser.rs &amp; de.rs</span><br><span class="hljs-keyword">use</span> crate::error::&#123;Error, <span class="hljs-built_in">Result</span>&#125;; <span class="hljs-comment">// 增加crate</span><br></code></pre></div></td></tr></table></figure><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>添加<code>src/bin/inspect.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// src/bin/inspect.rs</span><br><span class="hljs-keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;<br><span class="hljs-keyword">use</span> serde_example::&#123;from_str, to_string&#125;;<br><br><span class="hljs-meta">#[derive(Debug, Serialize, Deserialize)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Command</span></span> &#123;<br>    Set &#123; key: <span class="hljs-built_in">String</span>, value: <span class="hljs-built_in">String</span> &#125;,<br>    Get &#123; key: <span class="hljs-built_in">String</span> &#125;,<br>    Rm(<span class="hljs-built_in">String</span>),<br>    Quit,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> cmd = Command::Set &#123;<br>        key: <span class="hljs-string">&quot;A&quot;</span>.to_owned(),<br>        value: <span class="hljs-string">&quot;42&quot;</span>.to_owned(),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> ser_cmd = to_string(&amp;cmd).unwrap();<br>    <span class="hljs-keyword">let</span> de_cmd: Command = from_str(&amp;ser_cmd).unwrap();<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;origin: &#123;:?&#125;\nserialized: &#123;&#125;\ndeserialized: &#123;:?&#125;&quot;</span>,<br>        cmd, ser_cmd, de_cmd<br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行<code>cargo run --bin inspect</code>就会输出</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">origin: Set &#123; key: &quot;A&quot;, value: &quot;42&quot; &#125;<br>serialized: &#123;&quot;Set&quot;:&#123;&quot;key&quot;:&quot;A&quot;,&quot;value&quot;:&quot;42&quot;&#125;&#125;<br>deserialized: Set &#123; key: &quot;A&quot;, value: &quot;42&quot; &#125;<br></code></pre></div></td></tr></table></figure><h2 id="expand-derive"><a href="#expand-derive" class="headerlink" title="expand derive"></a>expand derive</h2><p>还有一份关键的代码，藏在<code>#[derive(Debug, Serialize, Deserialize)]</code>里，这条语句自动生成一些(很多!)代码，为<code>Command</code>实现关键的两个序列化trait。</p><p>这要借助<a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a>工具，如果没有先装一下，一般下面两个命令搞定</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustup toolchain install nightly  <span class="hljs-comment"># 如果只使用过stable版本，需要先装nightly</span></span><br><span class="hljs-meta">$</span><span class="bash"> cargo install cargo-expand</span><br></code></pre></div></td></tr></table></figure><p>运行<code>cargo expand --bin inspect</code>，终端输出生成代码。</p><p>其中一段类似下面这样，实现的是<code>Serialize</code>，把它复制到<code>derive_ser.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> _IMPL_SERIALIZE_FOR_Command: () = &#123;<br>    <span class="hljs-meta">#[allow(unknown_lints)]</span><br>    <span class="hljs-meta">#[allow(rust_2018_idioms)]</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> serde <span class="hljs-keyword">as</span> _serde;<br>    <span class="hljs-meta">#[automatically_derived]</span><br>    <span class="hljs-keyword">impl</span> _serde::Serialize <span class="hljs-keyword">for</span> Command &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize</span></span>&lt;__S&gt;(&amp;<span class="hljs-keyword">self</span>, __serializer: __S) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;__S::<span class="hljs-literal">Ok</span>, __S::Error&gt;<br>        <span class="hljs-keyword">where</span><br>            __S: _serde::Serializer,<br>        &#123;<br>            <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> &#123;<br>                Command::Set &#123; <span class="hljs-keyword">ref</span> key, <span class="hljs-keyword">ref</span> value &#125; =&gt; &#123;<br>                    ...<br>                    _serde::ser::SerializeStructVariant::end(__serde_state)<br>                &#125;<br>                Command::Get &#123; <span class="hljs-keyword">ref</span> key &#125; =&gt; &#123;<br>                    ...<br>                    _serde::ser::SerializeStructVariant::end(__serde_state)<br>                &#125;<br>                Command::Rm(<span class="hljs-keyword">ref</span> __field0) =&gt; _serde::Serializer::serialize_newtype_variant(<br>                    __serializer,<br>                    <span class="hljs-string">&quot;Command&quot;</span>,<br>                    <span class="hljs-number">2u32</span>,<br>                    <span class="hljs-string">&quot;Rm&quot;</span>,<br>                    __field0,<br>                ),<br>                Command::Quit =&gt; _serde::Serializer::serialize_unit_variant(<br>                    __serializer,<br>                    <span class="hljs-string">&quot;Command&quot;</span>,<br>                    <span class="hljs-number">3u32</span>,<br>                    <span class="hljs-string">&quot;Quit&quot;</span>,<br>                ),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>另一段结构像这样，实现的是<code>Deserialize</code>，把它复制到<code>derive_de.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> _IMPL_DESERIALIZE_FOR_Command: () = &#123;<br>    <span class="hljs-meta">#[allow(unknown_lints)]</span><br>    <span class="hljs-meta">#[allow(rust_2018_idioms)]</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> serde <span class="hljs-keyword">as</span> _serde;<br>    <span class="hljs-meta">#[automatically_derived]</span><br>    <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> Command &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;__D&gt;(__deserializer: __D) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, __D::Error&gt;<br>        <span class="hljs-keyword">where</span><br>            __D: _serde::Deserializer&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>        &#123;<br>            <span class="hljs-meta">#[allow(non_camel_case_types)]</span><br>            <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">__Field</span></span> &#123; __field0, __field1, __field2,  __field3, &#125;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__FieldVisitor</span></span>;<br>            <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __FieldVisitor &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = __Field;<br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter) ... &#123;&#125; <br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_u64</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: <span class="hljs-built_in">u64</span>) ... &#123;&#125;        <br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_str</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: &amp;<span class="hljs-built_in">str</span>) ... &#123;&#125;<br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_bytes</span></span>&lt;__E&gt;(<span class="hljs-keyword">self</span>, __value: &amp;[<span class="hljs-built_in">u8</span>]) ... &#123;&#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::Deserialize&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Field &#123;<br>                <span class="hljs-meta">#[inline]</span><br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deserialize</span></span>&lt;__D&gt;(__deserializer: __D) ... &#123;&#125;<br>            &#125;<br><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">__Visitor</span></span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123; <br>                marker: _serde::export::PhantomData&lt;Command&gt;,<br>                lifetime: _serde::export::PhantomData&lt;&amp;<span class="hljs-symbol">&#x27;de</span> ()&gt;,<br>            &#125;<br>            <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;de</span>&gt; _serde::de::Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; <span class="hljs-keyword">for</span> __Visitor&lt;<span class="hljs-symbol">&#x27;de</span>&gt; &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Value</span></span> = Command;<br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expecting</span></span>(&amp;<span class="hljs-keyword">self</span>, __formatter: &amp;<span class="hljs-keyword">mut</span> _serde::export::Formatter)<br>                <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">visit_enum</span></span>&lt;__A&gt;(<span class="hljs-keyword">self</span>, __data: __A) -&gt; _serde::export::<span class="hljs-built_in">Result</span>&lt;Self::Value, __A::Error&gt;<br>                <span class="hljs-keyword">where</span><br>                    __A: _serde::de::EnumAccess&lt;<span class="hljs-symbol">&#x27;de</span>&gt;,<br>                &#123;<br>                    <span class="hljs-keyword">match</span> <span class="hljs-keyword">match</span> _serde::de::EnumAccess::variant(__data) &#123;<br>                        _serde::export::<span class="hljs-literal">Ok</span>(__val) =&gt; __val,<br>                        _serde::export::<span class="hljs-literal">Err</span>(__err) =&gt; &#123;<br>                            <span class="hljs-keyword">return</span> _serde::export::<span class="hljs-literal">Err</span>(__err);<br>                        &#125;<br>                    &#125; &#123;<br>                        (__Field::__field0, __variant) =&gt; &#123;...&#125;                       <br>                        (__Field::__field1, __variant) =&gt; &#123;...&#125; <br>                        (__Field::__field2, __variant) =&gt; &#123;...&#125; <br>                        (__Field::__field3, __variant) =&gt; &#123;...&#125; <br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">const</span> VARIANTS: &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>] = &amp;[<span class="hljs-string">&quot;Set&quot;</span>, <span class="hljs-string">&quot;Get&quot;</span>, <span class="hljs-string">&quot;Rm&quot;</span>, <span class="hljs-string">&quot;Quit&quot;</span>];<br>            _serde::Deserializer::deserialize_enum(<br>                __deserializer,<br>                <span class="hljs-string">&quot;Command&quot;</span>,<br>                VARIANTS,<br>                __Visitor &#123;<br>                    marker: _serde::export::PhantomData::&lt;Command&gt;,<br>                    lifetime: _serde::export::PhantomData,<br>                &#125;,<br>            )<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>好了，准备工作就这么多。开始受苦吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Serde你在干什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题阶段性回顾-II</title>
    <link href="/2019/11/07/reflection-43/"/>
    <url>/2019/11/07/reflection-43/</url>
    
    <content type="html"><![CDATA[<blockquote><p>距离上次总结，过去了三个月，发生了什么？</p></blockquote><a id="more"></a><p>上次总结是8月份，现在是11月，这三个月，在刷题方面的变化有:</p><ul><li>数量上，多做了160题左右</li><li>方式上，前一个月基本看完花花的题解，后两个月变为打周赛，应用</li><li>能力上，有提升，工具箱，模板库有丰富</li><li>心态上，反而更慌了</li></ul><p>一项项说吧</p><h2 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h2><p><img src="https://s2.ax1x.com/2019/11/07/MEkSJI.png" alt="progress"></p><p>总共数量为429题，medium: 58%, easy: 28%, hard: 14%</p><p>新题的主要来源是周赛和好评率好的题目。Top100的题目集中在小题号，所以分布图上开头比较密集。</p><p><img src="https://s2.ax1x.com/2019/11/07/MA9eqs.png" alt="distribution"></p><p>题目每天都有看，即使不做新题，也会复习旧题，用Rust重写，到国服的LeetCode上提交</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>上次总结刚看到花花的DP章节，之后一个月时间基本看完了花花的分类。</p><p>9月初抱着尝试的心态参加了第一次周赛，出道即颠峰，激励着接下来的两个月继续参加周赛。</p><p>期间也继续总结相关题型，进一步完善花花的特定分类，比如增加dp的题目，也增加了诸如单调栈、双指针的特殊类别</p><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p><img src="https://s2.ax1x.com/2019/11/07/MEkr0e.png" alt="rank"></p><p>11场比赛，应该有8、9场进了前100。这个成绩对我来说，已经不算差了。</p><p>思维上也有了一些倾向，比如构建极端用例，比如寻找子问题，简化问题。</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>比赛的前几场，还能带着新鲜感，有一种初生牛犊不怕虎的感觉。</p><p>后面渐渐感觉不太好，不稳定，觉得每次进入前100名不是一件十拿九稳的事。如果这样，就谈不上争取更好的成绩。</p><!--现在就是那种被推到了一个高的位置，但是能力好像又没有完全跟上，容易焦虑，害怕失去，甚至有点不想再比赛了。--><p>想来不能十拿九稳的原因，主要来自两个方面：</p><ol><li>medium的题目基本上可以解，但是速度不够</li><li>hard题目又基本上解不了，除了第一点造成的比赛时间不够，还有平时hard题目本来就练得少</li></ol><p>虽然说的是两点，但是根本问题还是做题不够快，找到思路的速度不够。</p><p>这种情况我该怎么办呢？是量不够，还是复习不够？平时做题掐着时间做有意义吗？15分钟没有思路怎么办呢？要做hard的题目吗？</p><p>具体应该从哪个方面入手呢？我现在还没个具体的思路……</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crate failure 的五种错误模式</title>
    <link href="/2019/11/05/five-error-patterns/"/>
    <url>/2019/11/05/five-error-patterns/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总结一下failure曾给出的五种错误设计模式。他们适合什么场景？现在有更好的选择吗？</p></blockquote><a id="more"></a><h2 id="五种模式解析"><a href="#五种模式解析" class="headerlink" title="五种模式解析"></a><a href="https://rust-lang-nursery.github.io/failure/guidance.html">五种模式</a>解析</h2><ol><li><p>String</p><p>即每个函数返回的类型为Result&lt;T, String&gt;</p><p>示意图：</p><p><img src="https://s2.ax1x.com/2019/11/02/KqkVm9.png" alt="string-err"></p><p>优点：不费脑子，基础设施代码少，方便快捷一把梭，?可以将各种错误转换为字符串</p><p>缺点：</p><ol><li>scattering：错误信息字符串散乱在代码各处，维护起来比较困难</li><li>brittle：如果调用者要针对不同的错误做特殊处理，只能靠字符串匹配，要是你改变了错误信息，下游的错误处理全部崩盘</li></ol><p>适用场景： 原型期，非lib工程，或者适用于那些十分罕见的错误，如果遇到要么写入日志，要么跳过，不会单独识别出来做特殊处理</p></li></ol><p>&nbsp;</p><ol start="2"><li><p>Using the Error type</p><p>即函数的返回类型为Result&lt;T, Error&gt;</p><p>示意图：</p><p><img src="https://s2.ax1x.com/2019/11/02/KqkNkt.png" alt="error-type"></p><p>优点</p><ol><li>不需要自定义错误类型</li><li>因为只要实现了<code>Fail</code>的都可以转换为Error类型，可以用?操作符</li><li>同时因为转换方便，面对将来新增依赖带来的新错误类型，也能不加修改地向外传递.</li></ol><p>缺点：</p><ol><li>Error要新分配内存，性能有时候没有自定义错误类型好</li><li>只有downcast才能获取原有的错误类型</li></ol><p>适用场景：错误的类型系统不是很重要，重要的是写入日志或者展示给用户。application比较适合，结构化的错误类型不是必须的，重点是能包容各方依赖的错误。其实这个看上去有点像String的升级版，不过支持downcast反向转换。</p></li></ol><p>&nbsp;</p><ol start="3"><li><p>Custom Fail type</p><p>即函数返回的类型为Result&lt;T, ProjectError&gt;, 其中ProjectError是各种错误的枚举，并且实现相关错误Trait，比如failure::Fail、std::error::Error</p><p>示意图：</p><p><img src="https://s2.ax1x.com/2019/11/02/KqcM6I.png" alt="fail-type"></p><p>优点：</p><ol><li>可以枚举可能出现的所有错误类型</li><li>完全控制每个错误类型的打印格式</li><li>调用者不用做downcast就可以获得详细的错误信息</li></ol><p>缺点：</p><ol><li>在嵌套错误时，必须显示使用#[cause]指明下层错误，便于derive实现cause。这种形式不一定保证兼容之后所有依赖的错误类型。</li><li>错误枚举选项(variants)和底层错误是一对一关系。</li></ol><p>我不是很理解这个两个缺点的意思，翻译得可能也不准确。</p><p>第二点是不是指，如果在只使用？操作符的情况下，你只能为底层错误写一个转换到ProjectError的From trait，只能转换到ProjectError的其中一个枚举，这样语义上可能达不到要求。比如io::Error可以是FileSystemError也可以是NetworkError，在lib层面做一个区分就会更有意义，而这在第4种Error and ErrorKind中能实现，因为使用显示的context来转化。</p><p>适用场景：文档说的意思是，这个模式比较适合没有底层错误的错误。如果要组合底层错误，推荐使用后面Error and ErrorKind的模式。</p></li></ol><p>&nbsp;</p><ol start="4"><li><p>An Error and ErrorKind pair</p><p>最健壮的error管理方式，当然维护起来是最麻烦的。</p><p>整体思路是2、3的整合。具体是让自定义的ProjectError，承担Error的角色，让所有错误都可以相对快捷地转换到ProjectError类型。</p><p>示意图：</p><p><img src="https://s2.ax1x.com/2019/11/02/KqAtu4.png" alt="ErrorKind"></p><p>ProjecError的主体实际上是一个Context结构，Context左手一个ErrorKind，右手一个failure。ErrorKind就是lib层面自定义的结构化错误，外部代码可以通过对ProjectError调用kind方法来确定错误类型。failure记载导致ErrorKind的下层错误。和Custom Fail Error示意图一样，我用橙色标记了错误的主体，可以看到ErrorKind版本，实际上新增了一层统一的Context抽象，把原本当主体的ErrorKind拿来当一个字段。</p><p>优点：</p><ol><li>兼容性好</li><li>可以添加信息</li><li>把底层错误转换到统一的ProjectError</li><li>不用downcast</li></ol><p>缺点：</p><ol><li>比较复杂，写很多模板代码</li><li>结构复杂，allocation比较多，不适合性能要求高的应用</li><li>[个人] 不能完全控制错误的Display的方式，Project的Display实现调用Context，Context只会打印ErrorKind的Display，在Debug Trait里则会用换行符连接ErrorKind和cause failure。你只能控制ErrorKind的展示，但是不能控制ErrorKind和cause failure在一块的展示格式。</li></ol><p>适用场景：中间层的lib，有众多依赖，且面向生产环境使用。希望提供完整的结构化错误，并且添加足量的上下文信息，可以使用这个模式。</p></li></ol><p>&nbsp;</p><ol start="5"><li><p>Strings and Custom Fail Type</p><p>本质是把ErrorKind换成String、&amp;str。</p><p>示意图：</p><p><img src="https://s2.ax1x.com/2019/11/02/KqfclQ.png" alt="string-custom"></p><p>动机说明 &amp; 优点 &amp; 适用场景：</p><ol><li>想提供除了Error之外的更具语义的ProjectError，比如例子中的EncodeError和DecodeError。同时还不想写复杂的ErrorKind，因为上下文实在太多了，并且上层调用实际上并不是很想错误处理，只想要一个友好的错误说明。</li></ol><p>缺点：</p><ol><li>Context\&lt;String>要多出allocation</li><li>[个人] string信息依然散乱在各处，不方便维护</li></ol></li></ol><p>&nbsp;</p><h2 id="还有更好的选择吗"><a href="#还有更好的选择吗" class="headerlink" title="还有更好的选择吗"></a>还有更好的选择吗</h2><p>其实看下来Custom Fail Type的结构是最简单的，Error and ErrorKind在其基础上引入Context而成。</p><p>ErrorKind模式不能完全控制展示格式，也正是因为引入的这个Context。如果想完全控制，就得把底层错误写入ErrorKind的字段里。这样就和Context的failure字段重复了，很呆。这个问题在使用context为io Error添加错误时有实际体现(见)。</p><p>既然如此，为什么不让context方法直接返回Custom Fail Type呢？这样也能规避Coustom Fail Type和底层错误一对一绑定的尴尬。这个思想就是 <a href="https://docs.rs/snafu/0.5.0/snafu/">crate snafu</a> 的实现依据</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Snafu)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Error</span></span> &#123;<br>    <span class="hljs-meta">#[snafu(display(<span class="hljs-meta-string">&quot;Could not open config from &#123;&#125;: &#123;&#125;&quot;</span>, filename.display(), source))]</span><br>    OpenConfig &#123;<br>        filename: PathBuf,<br>        source: std::io::Error,<br>    &#125;,<br>    <span class="hljs-meta">#[snafu(display(<span class="hljs-meta-string">&quot;Could not save config to &#123;&#125;: &#123;&#125;&quot;</span>, filename.display(), source))]</span><br>    SaveConfig &#123;<br>        filename: PathBuf,<br>        source: std::io::Error,<br>    &#125;,<br>    <span class="hljs-meta">#[snafu(display(<span class="hljs-meta-string">&quot;The user id &#123;&#125; is invalid&quot;</span>, user_id))]</span><br>    UserIdInvalid &#123; user_id: <span class="hljs-built_in">i32</span>, backtrace: Backtrace &#125;,<br>&#125;<br><br><span class="hljs-comment">// 理解了这个想法，使用上也挺直观的</span><br><span class="hljs-comment">// OpenConfig &#123; filename &#125; 是一个实现了IntoError的结构，由From trait调用转换为Error</span><br><span class="hljs-keyword">let</span> config = fs::read(filename).context(OpenConfig &#123; filename &#125;)?;<br>fs::write(filename, config).context(SaveConfig &#123; filename &#125;)?;<br></code></pre></div></td></tr></table></figure><p>经过一个多星期的对比，我目前觉得 snafu 的设计是挺好的，适合需要严谨设计错误的中间lib。事实上，稍微有点追求的application也可以这样搞，因为可以集中修改display的信息，虽然使用String的方案很方便，但是依然存在信息散乱，修改不方便的问题。另外，snafu依赖的也是标准库的error，之后如果有变动，迁移起来会比failure方便。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ErrorHandling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么Rust的std::io::Error不包含文件名等信息？</title>
    <link href="/2019/11/05/why-io-error-has-not-filename/"/>
    <url>/2019/11/05/why-io-error-has-not-filename/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么Rust不像Python一样，直接在io error里添加相关路径信息？<br>TLDR; 它的性能偶像包袱太重</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当处理系统io时，如果报错没有找到文件，我们总希望知道到底是哪个文件没有找到。</p><p>也就是希望相关error在使用Display trait 打印时，可以携带文件的路径信息，像这样</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">path/to/foo: No such file or directory (os error 2)<br></code></pre></div></td></tr></table></figure><p>&nbsp;</p><p>那为什么io::Error本身没有加上路径信息呢？这实际上是个争论点：</p><ul><li><p><a href="https://www.reddit.com/r/rust/comments/bsn0zs/get_which_filename_is_not_found_on_rust_file/">Get which filename is not found on rust file opening</a></p></li><li><p><a href="https://internals.rust-lang.org/t/add-filename-information-to-io-error/5120">add-filename-information-to-io-error</a></p></li></ul><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>总体的脉络是这样的：  </p><p>添加了路径信息，当然更人性化，舒服（withoutboats，kornel），但是有以下顾虑：</p><ol><li>IO错误，操作系统返回就是简单的错误码，作为标准库，似乎简单地wrap住就足够了（withoutboats）</li><li>添加了路径信息，有的人又不用，标准库要保持最大克制，不要做过多假设，决定权交给程序员，让他们决定是否要添加上下文信息(repax、troplin)</li><li>毕竟增加了字段，性能上有损耗（alex，troplin）</li></ol><p>&nbsp;</p><p>其中第二点，troplin还举了一个例子，现在是建议在io::Error里加入路径信息，那么以同样的理由，在某些情况下，还会希望HashMap.get()在没有找到key时返回错误，并且携带缺失的key信息。最后事情还可能演变成，希望每个函数，如果没有按照预期的轨迹运行，都把参数放入错误里返回，因为这样才是最有助于debug的。</p><p>所以troplin说，错误的主要目的并非日志或者debug，而是逻辑上的“错误处理”，保留最简信息就可以了。</p><p>&nbsp;</p><p>zack，作为力主添加的大佬，提出了一些看法。</p><p>首先他态度坚决地反对了第二点，从现实的角度而言，像这样的系统调用，只要在生产环境，就必须要记录足够细节的日志。这是他的血泪教训，换句话说，如果他的团队里来了新人，他一定不愿意将所谓的决定权给这些新手。</p><blockquote><blockquote><p>repax: I don’t think it’s a good idea to mandate the inclusion of data or operations when they’re not universally applicable.</p></blockquote><p>zack: I categorically reject this position. Based on many, many years of bitter experience debugging shit in production: <em>All</em> applications, no matter what they are or what environment they are in, need the ability to capture and log system call failures in full detail, <em>somehow</em>. Anyone who thinks they don’t is wrong.</p></blockquote><p>他提出了一个观点，有些信息，如果lib的作者不记录，想着交给外层调用者添加，就可能永远丢失了。而这个不记录的情况，因为人的不定因素，总会发生。</p><p>两个例子：</p><p>第一，数据库应用(十年前的SQLite)不记录上下文，如果用户无法打开数据库，错误显示“Permission Denied”，你无法知道到底是哪个文件的权限问题，是主数据库文件，日志文件，还是某个临时文件所用的目录？</p><p>第二，<code>std::fs::create_dir_all</code>，递归创建目录失败，作为调用者，你知道的上下文信息是仅仅是完整的目录，但是出问题的实际上可以是完整目录的任意前缀。</p><p>&nbsp;</p><p>我断断续续地，用一周的时间在理解他们的说法，并且试图还原错误是什么。</p><p>先说结果吧，我认为zack的说法更具价值。troplin、repax的说法更飘，理论上怎么都不会错，但不实在。</p><p>&nbsp;</p><p>首先我不认同troplin的一点是，我认为错误的作用，并不是错误处理占绝对主导。做记录，给人看，帮助使用者调整输入，规避错误，达到预期目的，也是错误很重要的一环。毕竟，错误发生，意味着输入于执行逻辑不匹配，才导致处理中断，<strong>未能完成预期目的</strong>。要强调一点，对于中间层的lib，顶层用户的输入是输入，下层依赖也可以是一种输入，比如操作系统的环境设置，他们都是用户可以修改的，这就是SQLite数据库做法有误的原因。</p><p>要完成目的，可以借助 <strong>错误处理</strong>，按照不同的错误<strong>类型</strong>，采取不同的处理策略，或重试、或换个姿势重试、或发起交互、或跳过，尝试达到目的。</p><p>如果依然无法解决问题，那么就是输入真的有大问题，此时应该 <strong>向人类求助</strong>，告知错误信息，辅助他们调整输入，规避错误。</p><p>&nbsp;</p><p>所以错误的存在，本身要满足两个特性</p><ol><li>方便区分，进行错误处理。结构化的类型就是一种有效的区分手段；</li><li>有展示的能力，并且展示的信息必须足够帮助外部人员调整输入，规避错误。也就是日志、debug的作用</li></ol><p>&nbsp;</p><p>我是怎么得到这个结论的呢？因为我假想了一种极端情况，如果说，往错误里添加额外信息没有性能损耗，troplin例子中看似荒诞的情况，就是我们真正需要的。即，如果一个函数没有按照期望执行，就在错误里报告他所知的上下文，参数，甚至局部变量。这样就等于我们无代价地监控了程序的运行状态，debug能力直接拉满，皆大欢喜。</p><p>然而现实中，因为性能原因，不允许我们这样做，于是妥协，选择放弃一部分上下文信息，只保留必要的信息。这是一种用易用性换性能的手段，而不是错误本不应该面向debug而设计。</p><p>&nbsp;</p><p>理解了错误的定位，那么就可以讨论要妥协到什么程度，以及为什么说，有的信息，lib不记录就永远丢失了。</p><p>丢失的原因，是lib的作者误判了自己的逻辑深度和抽象边界(zack)。</p><p>如果一个lib对下层依赖隔离得比较彻底，甚至没有依赖，那么把错误的上下文信息交给调用者保存，问题不大。比如文件系统，出了错，告知什么错误，这部分信息量就足够 <em>直接调用者</em> 改变自己的使用方式来规避错误。</p><!-- 再比如，json反序列化的解析器，没有依赖带来的错误，自定义错误比如`ExpectedBoolean`, `ExpectedString`等等，都只和输入相关。告知错误，由提供输入的 *直接调用层*  来添加具体的出错位置，这是OK的。注意用户并不是 *直接调用者*， 用户只提供了总体的输入，比如1000行的json文本，而json库内部还有一层抽象去分解这1000行，按某种顺序喂给特定的解析函数，所以不妨把这三层称为 user - tokenizer - parser。解析器parser在最底层，它出错的唯一可能是输入有误，所以它可以不保存tokenizer为自己提供的上下文，让tokenizer来做。tokenizer这一层就不能再让用户来保存上下文了，用户只有1000行的文本，如果tokenizer只返回一个`ExpectedBoolean`错误，而没有大概的行、列数，这就很过分，因为无法帮助用户快速调整输入，规避错误，达到目的。--><p>同理，zack举的<code>std::fs::create_dir_all</code>，就是增加了逻辑深度，但没有记录上下文。按照repax、troplin的理想状态，决定权交给程序员，那么这里的fs实际应该自己创建一个新的错误类型，添加好上下文后再传递到更上层。</p><p>但是fs没有这么做，这就是zack主张把路径放入io::Error的关键理由：不要过分信任程序员，一如rust编译器对程序员的态度。如果标准库确定要和操作系统的错误保持一致，那么每一个依赖系统调用的lib或app，都应该创建一个错误链，为io::Error添加必要的路径信息。只要生产环境，概无例外。zack用职业经验担保这一点。显然这和性能无损的监控一样不现实，连std::fs自己都没有做到。所以不如直接在io::Error里添加这样的信息。</p><p>这样做，实际上是让标准库改变自己的定位，不再是操作系统的简单包装，而是一个以操作系统为依赖，拥有内部逻辑的，面向程序员使用的中间lib。当然zack还提了一个更不太现实的方案，如果编译器能发现lib的作者没有构建自己的错误链，并且把io::Error放进去，直接报错，那也可以，就不用改io::Error了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>错误本来就应该具有 易区分 和 帮助定位问题 的 作用，因为性能原因，底层lib常常省略上下文。但是这不应成为错误的常态，中间lib，使用添加上下文的错误设计，才是为未来节省时间的良策。</li><li><p>就事论事，io::Error里要不要添加路径信息？也就是标准库作为操作系统上面的那层包装，要不要牺牲一点性能，来帮助“愚蠢的程序员”？你问我资瓷不资瓷，我当然是资瓷的。即使不改io::Error，也应该为fs添加新的错误，比如PathIOError之类的，让上层用起来更方便。</p></li><li><p>但现实就是，标准库依然定位于操作系统层的简单包装，io::Error没有路径信息。当你在考虑需不需要为io::Error增加路径上下文时，就应该增加。</p></li><li>说错误影响性能，但到底有没有人测量过，加了路径信息的错误，让性能承受了多大的损失？没有量化数据，总觉得在和空气斗智斗勇 🙂</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ErrorHandling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>果然翻车：第二场 LeetCode 周赛</title>
    <link href="/2019/10/08/weekly-contest-154/"/>
    <url>/2019/10/08/weekly-contest-154/</url>
    
    <content type="html"><![CDATA[<p>翻车。果然翻车。GG，技不如人，甘拜下风</p><a id="more"></a><h1 id="结果与过程"><a href="#结果与过程" class="headerlink" title="结果与过程"></a>结果与过程</h1><p>没有程序，直接处刑，排名从23到378。</p><p><img src="https://s2.ax1x.com/2019/09/18/nHTys1.png" alt="ranking"></p><p>问题就出在第二题。这类题我有印象，比如，<code>394-Decode String</code>，<code>726-Number of Atoms</code>。递归或者栈。如果要使用递归，先扫描找到外层括号，对剥去括号的内层字符串递归调用，对递归结果做相应处理，比如重复、反转等。总体思路，写完，提交，bug，一气呵成，被结结实实地糊了一脸。但是因为对这个题的预期时间很短，导致心态不好，没有沉下心来思考细节，用”面向实验编程”的方法，修修补补撞大运。直到40多分钟，发现错误原因，忽略了一次递归实际上可以有多个同级的括号需要剥离。AC的时候，52分钟已过。</p><p>这个时候心态基本崩盘，第二题太不应该了这种想法一直在盘旋。第三题也没有直接灵光一闪，一片混沌中迎来比赛结束……</p><p>等比赛结束了，才想到第三题的基本组件，就是上周才做的maximum subarray，一遍扫描得到k=1时的结果，并且用头尾两个maximum，来考虑大于等于2次重复时的情况，也就是加上数组的sum。最后各种情况取最优。明明能做，心态更没了……</p><h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>现在距离比赛，实际上已经过去一个月，期间又参加了四场周赛和秋季编程大赛，成绩都比这次更好，五场成绩均在50~100。</p><p>这个月，我断断续续地，在观察、沉淀、思考自己当时的心态。希望这次周赛带来的收获更深刻一些。</p><h2 id="唯结果论"><a href="#唯结果论" class="headerlink" title="唯结果论"></a>唯结果论</h2><p>这类比赛，如同考试，也应该少谈发挥、少谈心态。没做出题目，就说明对考察点没有灵活掌握。没有那么多”就是这么想的，差一点做出来的”。</p><p>这样的”唯结果论”的好处是，避免自己沉浸到”本可以做出来”的幻想中，提醒自己再学习。</p><p>这个想法强硬，有足够的推动力，因为它用简单粗暴的归因简化了问题的复杂性，直截了当地给出改进方向: 加强技巧本身的训练。</p><p>这对训练的初级、中级阶段，都很有实用价值，提醒自己，不要找借口，老老实实记忆、理解、应用。</p><p>但是这里有个潜藏的问题，唯结果论强调，不要着眼心态、发挥，忘记那个”差一点就做出来”的自己，可真的能忘掉吗？</p><p>如果忘不掉，怎么老老实实复习旧题呢？</p><p>想的可能依旧是，要做新题，要在新题上证明自己能行，那一份”差一点”就赖发挥。在征服新题的过程中才能维持对自己的某种印象。</p><p>是的，我就是那种没忘掉的人。</p><p>所以，唯结果论的推动力要起效果，前提是真正地认同它，接纳它。</p><p>而接纳它的本质，是承认现在的自己还不够好的事实，是认清自己需要提高的现状，是相信通过练习能够改善的未来。</p><p>让你忘掉心态的唯结果论，反而最依赖心态，还是有点节目效果的🙃。</p><p>其实总结下来，让唯结果论生效的心态，就是自我期望的管理，俗话说的就是，能摆正自己的位置。</p><h2 id="自我期望"><a href="#自我期望" class="headerlink" title="自我期望"></a>自我期望</h2><p>认识自己很难，体现在不能把控对自己的期望。</p><p>人的状态、经历，一定时间尺度内，是正弦波动的。高峰的时候，认不清，把高点当作自己的平均值，容易膨胀，对自己期望甚高，激进。低谷的时候，认不清，把低点当作自己的平均值，陷入自我怀疑，对周遭没了兴致，不再继续，不敢尝试。</p><p>第一次周赛做完，第23名，那时我在高峰，虽然口头说要冷静，要复习，防止下次翻车，但还是贪婪地认为，那个能做出全部4题，排名23的才是”我”，这样的”我”不应该在本周的第二题上周旋那么久。</p><p>这种因为自我期望过高而带来的弊端，还体现在平时做题的时候，遇到做不出来的题，常常过分地死磕，如果还没死磕出合理的解法，就陷入烦躁、低谷，觉得自己真的不行，笨，心态爆炸。这种低落引发的负面效果有时还会波及到周围的人。</p><p>现在想来，真正的我，实际上就是一个训练数据结构与算法刚不久的非科班，掌握的套路还不够多，能力不全面，做不出题正常，参赛排名方差大也正常。</p><p>排名20，说明状态好、有灵感的时候，尚有一战之力，之前的练习有效果。排名300，说明递归、栈的类型题没有想象中熟练，可以再复习总结。</p><p>每一次的结果并没有定义”你是谁”，而是在告诉你，如果你想要成为你想成为的人，你可以在什么地方付出时间和思考。</p><p>生活潮起潮落，一时失意，可以感慨，但尽量不要影响后续的行为。摆正自己的位置，看方差是否减小，平均值是否抬升？</p><h2 id="训练心态"><a href="#训练心态" class="headerlink" title="训练心态"></a>训练心态</h2><p>这次周赛后，我觉得，处理情绪，调整心态应该是很重要的技能，应该加以训练。</p><p>据我所知，一种可操作性比较强的调整方法，是具象化自己的情绪，把他们想象成大象、猴子、幼儿园的调皮学生，和他们对话，揭露他们的虚张声势，告知他们我的目标，他让们老老实实回到自己的座位上。如果任由他们折腾，除了过多地消耗我们的精力，并不会对事情的解决有决定性的作用</p><p>这种具象化的意义，除了使情绪可对话，还暗示了一个比较核心的概念: 这些情绪都是和我们共存的，处理他们的方式有且仅是对话，而非驱逐。这给我指了一个大概的训练方向，就是允许情绪出现，但是训练的是在更合理的时间内，站在第三方去观察情绪，和他们对话。</p><p>今后的生活中可以做两件事情：</p><div class="hljs code-wrapper"><pre><code>1. 固定一下情绪的形象，为他们写背景故事2. 如果出现了强烈的情绪波动，尤其是负面情绪，尝试记录劝导过程，并且标记处理时间</code></pre></div><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>处理好自己真的有点难。但是大多数事，经过训练，必有提升。希望自己能有一个更强健的心理处理能力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一场 LeetCode 周赛</title>
    <link href="/2019/09/08/weekly-contest-153/"/>
    <url>/2019/09/08/weekly-contest-153/</url>
    
    <content type="html"><![CDATA[<p>回顾第一次参加LeetCode周赛(中国区153场), 以及这个月的刷题总结</p><a id="more"></a><h1 id="结果与过程"><a href="#结果与过程" class="headerlink" title="结果与过程"></a>结果与过程</h1><p>首先是结果，总用时1小时36分，中国区的全国排名是23，全球排名为167。</p><p>其中全国有效的参与人数(起码做出1个题)为850人，全球范围则是4213人</p><p><img src="https://s2.ax1x.com/2019/09/08/nGd14H.png" alt="ranking"></p><p>这个结果确实是没想到，有点出道即颠峰的感觉 😀</p><p>虽然做着有点磕巴，但前三题看到题面，基本上第一直觉就是相对比较正确的思路。</p><p>做完三个题，就第一次参加，已经不错了，所以最后一个题就看看。</p><p>当时才20个人做出来，想题的时候还会开小差，就算我做不出来就不会太差吧。没想到后来还有了思路，在最后4分钟里成功提交，有一个bug是因为要求无解返回-1，我返回了False。</p><p>综合起来题目都不是那种考edge case的题目，自己状态、运气也都不错，能得这么个成绩我已经满意了。</p><h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>上个月初，对刷题做了一个总结，做了花花的90题。这个月也没有放松，前20多天继续做了花花的DP和Graph，基本上完成了花花列表的80%~90%。</p><p>后面几天就是random pick，随机一些好评率比较高的题，和刷过的题有关的话，就复习一下。还集中做了关于monotonic stack/queue的题，技巧性有点高，不怎么熟。</p><p>今天比赛的结果也给自己一些鼓励和自信吧，为了避免下一次惨烈翻车，打回原形，之后计划以复习为主，random pick为辅，再把基础夯实在一些。</p><p><img src="https://s2.ax1x.com/2019/09/08/nGgxmj.png" alt="heatmap.png"></p><p>现在回头看这两个月的练习还是点作用的吧，还要加油。</p><h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h1><blockquote><ul><li>第一题，从起点，向左右两个方向出发，取两个路程的最小值</li><li>第二题，输入的下限是1971年1月1日，为星期五，所以计算从初始日到输入日期的总天数，对7取模</li><li>第三题，最后最多删除一个数，那么就把问题分为解为，删除arr[i]所能得到的最大子数组之和，由两部分组成，以arr[i-1]结尾的最大子数组之和(记为end[i-i])，加上，以arr[i+1]开始的最大子数组之和(记为start[i+1])，如果不删除，就是(end[i] + start[i] - arr[i]), 在两种结果中取最大值，就是单独考虑arr[i]的结果，遍历全部arr元素，可以得到全局最优。start、end数组都可以在O(n)时间内得到</li><li>第四题，思路是尝试把arr1[i]换为保证arr1为严格递增的最小元素(从arr2中选择)，所谓尝试，就是在换与不换中取最小值，所以是个dp问题。之所以选择最小元素，是因为可以最大限度保证后续的元素不用更换。dp[n]表示arr1结尾数字为n时，所累积的最小操作数，对于当前数，只要能继续保持arr1递增，可以不更换，使用arr1p[i]，操作数不变，也可以从arr2中用二分查找找比n大的元素加入arr1，操作数加1。如果两条路都找不到，就返回-1</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题阶段性回顾</title>
    <link href="/2019/08/04/reflection-31/"/>
    <url>/2019/08/04/reflection-31/</url>
    
    <content type="html"><![CDATA[<p>这周新题做得少了一些，主要在复习做过的题目。顺便也简短总结一下刷题这件事。</p><a id="more"></a><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><ol start="0"><li>无意间做了advent of code 2018，觉得想要解决问题，还是得打基础</li><li>职业发展绕不过去，不论跳槽还是想深入一些核心工作。</li><li>脑子是没有别人灵光，但是也跟了我二十多年了，不能放弃人家啊，练练，选一些难的路走。</li><li>为什么是LeetCode：刷的人多，资源多</li></ol><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>我做题跟着<a href="https://zxi.mytechroad.com/blog/">花花Leetcode</a>。先数一下他的优点：</p><ol><li>有规模。题目讲解存量大，而且还稳定更新</li><li>学习方便。大部分题目有视频讲解，新手友好。独立网站有文字、代码归档，方便复习、查阅</li><li>质量高。代码质量高，兼顾效率和风格；讲解的质量也高，给总结规律和套路</li></ol><p>真的，只要你吹花花我们就是兄嘚。</p><p>花花在<a href="https://www.bilibili.com/video/av42947553">进入千题时代后该如何刷题?</a> 给出了他的题目分类列表，现在我也在按着这个做题。easy、medium、三星hard必做，四星hard做那种偏思路的部分题。</p><p>这周复习的过程中，把花花给的题目分类表重新组织了一下。目标是方便今后复习和总结。</p><p>花花提供的题目列表目前是如下图组织的：<br><img src="https://s2.ax1x.com/2019/08/04/ecPose.png" alt="huahua.png"></p><p>我重做后是这样：</p><p><a href="https://imgchr.com/i/ecKUIO"><img src="https://s2.ax1x.com/2019/08/04/ecKUIO.png" alt="ecKUIO.png"></a></p><p>我主要做了三个方面的加强：</p><ol><li><p>每个题目都显示写出题目名称，标记难度，并且增加了Digest栏，用来描述题目大意。这两个改动都是为了方便回忆题目的大概意思</p></li><li><p>增加题目讲解的连接。把在网站上能找到的连接都贴了，因为网站上会记录没有制作视频的题目，更全面一些。(B站的图标是个闪电，这个梗不晓得有没有人知道)</p></li><li><p>增加Reivew栏，写些个人看法，主要思路或者相关技巧总结</p></li></ol><h1 id="What-Now-amp-Next"><a href="#What-Now-amp-Next" class="headerlink" title="What Now &amp; Next"></a>What Now &amp; Next</h1><p>按照HuaHua的列表刷题实际上是7月中旬，到现在8月4号，基本上把花花给的Search、Recursion、Tree、BST、BinarySearch五个tag完成了一遍，大概90题左右吧。</p><p>现在的感受，从题目本身来说，Search真的是基础。Tree的路径收集、图的遍历，都是search的直接体现，后面的DP本质上可以看作是对Search的压缩。BST的中序遍历是关键。BinarySearch很容易和其他问题融合。然后就个人能力来说，现在还处在长见识的阶段，并没有达到质变的程度，轻而易举乐在其中离我太远，不求那些，但求坚持下去吧。希望自己的解题、分析能力真的有所长进。</p><p>接下来应该是做DP，仍然要做好复习。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>Life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种冷酷的爱情视角</title>
    <link href="/2019/07/24/love-and-money/"/>
    <url>/2019/07/24/love-and-money/</url>
    
    <content type="html"><![CDATA[<blockquote><p>世间模仿文学的爱情已经很多了，等着看另一种可能</p></blockquote><a id="more"></a><ol start="0"><li>爱情质量并不和持续时间成正比</li><li>你不能控制别人怎么想</li><li>爱情大部分是自我感觉。感觉到爱与被爱，所以和激素关系很大</li><li>激素分泌改变靠环境。具体到关系对方的image和行为。发掘、欣赏优点，忽略、引导不足。所以这总结为爱人的能力</li><li>金钱总能<strong>交换</strong>到时间和能力</li></ol><p>因此，以后大可以买个两周的爱情。虽然嘛，买到的是能力高你几个等级的人的向下兼容</p><p>不过，人的变数太大了，哪怕需求培养起来，供给不稳定还是不行。</p><p>所以，最终形态必然是软件的分发，《HER》中的人工智能根本轮不着文青的埋汰，买的人必不会少</p>]]></content>
    
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thoughts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中位数总结</title>
    <link href="/2019/07/14/median/"/>
    <url>/2019/07/14/median/</url>
    
    <content type="html"><![CDATA[<p>一步步梳理中位数的计算，关键时刻不要运气编程</p><a id="more"></a><h1 id="原始概念"><a href="#原始概念" class="headerlink" title="原始概念"></a>原始概念</h1><p>统计学上的中位数，的确是按照奇偶区分。<br>$$<br>for\quad x_1, x_2, …,x_n,\quad median = \left\{ \begin{array}- x_{(n+1)/2} &amp;when &amp;n &amp;odd \\ \frac{x_{n/2}+x_{n/2+1}}{2} &amp;when&amp;n&amp;even \end{array} \right.<br>$$</p><p>在此不妨再考虑一下， 这个公式是怎么来的。</p><p>首先需要知道总共有多少个元素，也就是<code>n-1+1</code>个元素，所以对n分奇偶。</p><p>再考虑奇数个元素，以中位数切割(不包含中位数)，左右两边的元素个数相等，也就是，可以找到一个索引k满足:</p><p>$(k-1) - 1 + 1 = n - (k+1) + 1 \Rightarrow k=(n+1)/2$，</p><p>再考虑偶数个元素，为了记叙方便，把两个中位数记为<strong>左、右中位数</strong>(奇数时左右中位数正好相等)，右中位数的索引更小，设为k，左中位数的索引即为k+1，再根据两边元素个数相等(包含中位数)</p><p>$k-1+1=n-(k+1)-1 \Rightarrow k=n/2$</p><h1 id="0-based-截断除法"><a href="#0-based-截断除法" class="headerlink" title="0-based + 截断除法"></a>0-based + 截断除法</h1><p>程序场景下，一般会换成0-based序列，同时考虑到，求中位数的目的经常是求索引，所以偶数个元素时，会直接用左、右中位数。利用同样的思路，本质是对<code>n+1</code>分奇偶</p><p>n为偶数时，n+1为奇数</p><p>$(k-1)-0+1=n-(k+1)+1 \Rightarrow k=n/2 $</p><p>n为奇数时，n+1为偶数</p><p>$k-0+1=n-(k+1)+1 \Rightarrow k=(n-1)/2$</p><p>所以左中位数是$(n+1)/2$</p><p>到这里，可以考虑截断除法，也就是当n为奇数时，$(n-1)/2=n/2$，n为偶数时，$(n+1)/2=n/2$，利用这两个式子，就可以统一奇偶的情况：<br>$$<br>for\quad x_0, x_1, …,x_n,\quad median = x_{n/2},\space x_{(n+1)/2}<br>$$</p><p>当n为偶数，奇数个元素，左右中位数索引相同。当n为奇数，偶数个元素，左右中位数索引各异。</p><h1 id="一般数列：公差为1"><a href="#一般数列：公差为1" class="headerlink" title="一般数列：公差为1"></a>一般数列：公差为1</h1><p>再考虑更一般的场景，$x_m, x_{m+1}, …,x_{m+n}$，这种可以简单地转换为0-based的情况，只要在最后的结果上加上m就可以了，也就是先尾部索引减去首部索引，求得n，得到0-based的左右中位数，最后加上m<br>$$<br>for\quad x_m, x_{m+1}, …,x_{m+n},\quad median = x_{\frac n2+m},\space x_{\frac{n+1}2+m}<br>$$</p><h1 id="等差数列：公差为k"><a href="#等差数列：公差为k" class="headerlink" title="等差数列：公差为k"></a>等差数列：公差为k</h1><p>场景还可以泛化成等差数列的索引，$x_{km+b},x_{k(m+1)+b},…,x_{k(m+n)+b}$，同样转换为0-based的情况，最后逆向结果。先求n，$n=(tail-head)/k$，得到0-based的左右中位数，加上m，乘k，加b。以左中位数为例，索引为$k(\frac n2+m)+b=(km+b)+k\frac n2$，首部索引加上k倍0-based的左中位数。<br>$$<br>for\quad x_{km+b},x_{k(m+1)+b},…,x_{k(m+n)+b},\quad median = x_{(km+b)+k\frac n2},\space x_{(km+b)+k\frac{n+1}2}<br>$$</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>首先是直接应用：</p><ul><li>写二分查找应该见过，说<code>mid=lo + (hi - lo) / 2</code>是为了防止溢出，实际上这也是更本质的求中位数索引的方法</li><li>希尔排序，如果使用二分查找来进行插入，数组就是以步长h为公差的等差数列，中位数索引是<code>mid = lo + h * int((hi-lo)/h/2)</code></li></ul><p>还有跟中位数有关的题目，比如复杂的004 median of two sorted array，就不是套公式，而是需要从中位数的定义入手，利用元素个数求解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种可操作性很强的二分查找思路</title>
    <link href="/2019/07/14/binary-search/"/>
    <url>/2019/07/14/binary-search/</url>
    
    <content type="html"><![CDATA[<p>今天看到HuaHua的视频，总结二分查找。觉得视角很好，于是在其基础上，再用做过的题复习一下。</p><a id="more"></a><p>标准的二分查找的核心视角是，存在一个函数g(x)，x的取值区间被分为两个部分，右侧g(x)为True，左侧g(x)为False。二分查找的目的。是在x取值区间内找到一个最小值m，使得g(m) = True</p><p><a href="https://imgchr.com/i/VLad8P"><img src="https://s2.ax1x.com/2019/06/18/VLad8P.png" alt="gx.png"></a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">right_bisect</span>(<span class="hljs-params">hay, needle</span>):</span>  <span class="hljs-comment"># upper-bound</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(hay)<br>    <span class="hljs-keyword">while</span> lo &lt; hi:  <span class="hljs-comment"># 左闭右开区间，只有严格小于时才表示搜索区间为空</span><br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> hay[mid] &gt; needle:  <span class="hljs-comment"># g(x)的意义就是找到大于needle的最小index</span><br>            hi = mid     <span class="hljs-comment"># g(x)为True，那说明在成立的一侧，最小值在左边</span><br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo  <span class="hljs-comment"># 始终没有找到使g(x)=True，返回hi</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_bisect</span>(<span class="hljs-params">hay, needle</span>):</span>  <span class="hljs-comment"># lower-bound</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(hay)<br>    <span class="hljs-keyword">while</span> lo &lt; hi:<br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> hay[mid] &gt;= needle:  <span class="hljs-comment"># g(x)的意义就是找到大于等于needle的最小index</span><br>            hi = mid<br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo<br><br><span class="hljs-comment"># 如果不存在是m使g(x)成立，返回hi</span><br></code></pre></div></td></tr></table></figure><p>除了左闭右开区间，还有就是闭区间，本质没有区别，搜索的停止条件也和闭区间的意义相符合。而且因为对称性、可以直接使用hi索引，在一些变形里用起来还更方便一些</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bisect_right</span>(<span class="hljs-params">hay, needle</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(hay)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> lo &lt;= hi:  <span class="hljs-comment"># 只有lo &gt; hi才表示搜索空间为空</span><br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> hay[mid] &gt; needle:  <span class="hljs-comment"># g(m)=True的意义是m大于needle</span><br>            hi = mid - <span class="hljs-number">1</span>      <span class="hljs-comment"># 闭区间，mid-1才能把当前这个满足条件的mid排除在外</span><br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bisect_left</span>(<span class="hljs-params">hay, needle</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(hay)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> lo &lt;= hi:  <span class="hljs-comment"># 只有lo &gt; hi才表示搜索空间为空</span><br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> hay[mid] &gt;= needle:  <span class="hljs-comment"># g(m)=True的意义是m大于等于needle</span><br>            hi = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo<br><br><span class="hljs-comment"># 如果不存在是m使g(x)成立，返回hi+1</span><br></code></pre></div></td></tr></table></figure><h1 id="378-Kth-smallest-element-in-a-sorted-matrix"><a href="#378-Kth-smallest-element-in-a-sorted-matrix" class="headerlink" title="378. Kth smallest element in a sorted matrix"></a>378. Kth smallest element in a sorted matrix</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Given a n x n matrix where each of the rows and columns are sorted in ascending order,<br>find the kth smallest element in the matrix.<br><br>Note that it is the kth smallest element in the sorted order, not the kth distinct element.<br><br>Example:<br><br>matrix = [<br>   [ 1,  5,  9],<br>   [10, 11, 13],<br>   [12, 13, 15]<br>]<br>k = 8<br>return 13.<br></code></pre></div></td></tr></table></figure><p>当时用二分查找做这个，有一个疑惑就是，最后找到的那个数为什么一定在这个二维数组里呢？</p><p>当时给自己的的解释其实也有上述视角的影子，但是总结得不够清晰易懂</p><blockquote><p>因为二分计算个数时包含等于，可以认为，如果一个数满足了个数要求，还是会继续减小这个数，直到逼近不满足的边缘，而这个边缘一定是等于的情况，也就是在数组中</p><p>在一个一维数组[0,2,6,7]中，如果要查找排名第2的数是哪一个，这个数a一定要满足，大于等于数组中的两个数(即0,2)，所以a是2，3，4，5中的一个，比如说现在通过0、7，得到a为3，满足要求，用0、3去得到下一个a为1，发现1不满足，2，3得到2，满足了，hi=2，跳出循环</p><p>所以真相就是，满足大于等于n个数的集合的左边界，一定是等于达成的，然后搜索寻找这个左边界，找到的数一定在数组中</p></blockquote><p>所谓的左边界，就是满足g(x)=True的最小值， g(x)的意义是， x是否大于等于二维数组中的k个数。</p><p>既然是这个要求，那么计算每一个行的二分查找就自然使用bisect_right，即upper_bound</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kth</span>(<span class="hljs-params">self, matrix, k</span>):</span><br>    lo, hi = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], matrix[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> lo &lt; hi:<br>        mid = (lo + hi) // <span class="hljs-number">2</span><br>        small_cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix:<br>            small_cnt += bisect_right(row, mid)<br>        <span class="hljs-keyword">if</span> small_cnt &gt;= k:<br>            hi = mid<br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo<br></code></pre></div></td></tr></table></figure><h1 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a>1011. Capacity To Ship Packages Within D Days</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">A conveyor belt has packages that must be shipped from one port to another within D days.<br><br>The i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.<br><br>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.<br><br>Example 1:<br>Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5<br>Output: 15<br>Explanation: <br>A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:<br>1st day: 1, 2, 3, 4, 5<br>2nd day: 6, 7<br>3rd day: 8<br>4th day: 9<br>5th day: 10<br><br>Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. <br><br>Note:<br>1 &lt;= D &lt;= weights.length &lt;= 50000<br>1 &lt;= weights[i] &lt;= 500<br></code></pre></div></td></tr></table></figure><p>这个也符合g(x)的要求，显然，当容量足够大，一次性运送所有货物，只要1天。所以慢慢收紧收紧容量，直到找到临界值。</p><p>因为规定按顺序装载货物，g(x)的计算自然地使用贪心。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_cap</span>(<span class="hljs-params">weights, D</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">days_needed</span>(<span class="hljs-params">cap</span>):</span><br>        k = <span class="hljs-number">1</span><br>        this_ship_weight = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> weights:      <br>            this_ship_weight += x<br>            <span class="hljs-keyword">if</span> this_ship_weight &gt; cap:<br>                this_ship_weight = x<br>                k += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> k<br>    lo, hi = <span class="hljs-built_in">max</span>(weights), <span class="hljs-built_in">sum</span>(weights)<br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = (lo + hi) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> days_needed(mid) &lt;= D:<br>            hi = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            lo = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lo<br></code></pre></div></td></tr></table></figure><h1 id="005-Longest-Palindromic-Substring"><a href="#005-Longest-Palindromic-Substring" class="headerlink" title="005. Longest Palindromic Substring"></a>005. Longest Palindromic Substring</h1><p>上面两个题的g(x)都是x大于某个值，g(x)一直为True。对应的一种变化，出现在<a href="https://aptend.github.io/2019/07/07/rabin-karp/">Longest palindromic substring的Rabin-Karp解法</a>里，即，当x小于某个值，g(x)一直为True，最后lo的意义是使得g(x)为False的最小值。</p><h1 id="004-Median-of-Two-Sorted-Arrays"><a href="#004-Median-of-Two-Sorted-Arrays" class="headerlink" title="004. Median of Two Sorted Arrays"></a>004. Median of Two Sorted Arrays</h1><p>设两个数组A, B各有$n_1, n_2$个数，左中位数的索引设为k，$k=\frac{n_1+_2-1}2$，右中位数的索引就是$k+1$。索引还有另一个意义——在总的有序数组C中，共有k个数小于等于索引为k的数。所以思路是，尝试取$n_1$中前$m_1$个数，取$n_2$前$m_2$个数，$m_2=k-m_1$，希望这k个数确实是C最小的k个数，即前k个数。</p><p><img src="https://s2.ax1x.com/2019/07/15/ZTFbqS.png" alt="ZTFbqS.png"></p><p>怎么判断？大数集合和小数集合没有交叉，满足：</p><ul><li><code>A[m1] &gt;= A[m1-1]</code></li><li><code>B[m2] &gt;= B[m2-1]</code></li><li><code>A[m1] &gt;= B[m2-1]</code></li><li><code>B[m2] &gt;= A[m1-1]</code></li></ul><p>前两个是有序数组保证的，后两个需要手动检查。</p><p>在考虑如何检查之前，已经可以观察到以m1为自变量的二分查找影子，那不妨先考虑g(x)思路，g(x)表示取出的k个数都小于等于<code>A[m1]</code>。显然当m1越大，g(m1)都为True。所以我们可以找到使g(x)为True的最小m1。</p><p>找出的m1，自然满足等式3：<code>A[m1]&gt;=B[m2-1]</code>。可以证明，因为是最小m1，等式4也满足。利用反证法，如果<code>B[m2] &lt; A[m1-1]</code>，这个不等式就可以看成是最小m1为m1-1时的等式3，即最小m1可以更小，推出矛盾。</p><p>找到C的前k个数后，中位数的备选项就在<code>A[m1]</code>，<code>B[m2]</code>，<code>A[m1+1]</code>，<code>B[m2+1]</code>四个元素中，简单的做法就是进行排序，根据奇偶，选择第一个或者前两个元素来计算中位数。</p><p>然后就是考虑边界条件了。</p><ol><li><p>两个数组都为空，返回None。</p></li><li><p>考虑二分查找时的越界：</p><ul><li>二分应该发生在元素更少的数组上。反例比如，10元素和0元素的数组，二分0元素数组就会造成0元素数组的越界</li><li>m2-1的越界。对每一轮二分的mid，g(x)会检查A[mid]和B[k-mid-1]的大小。当k=mid时，表明C的前k个元素都由A提供，因为二分发生在元素更少的数组上，所以此时A、B元素相等，A[n1-1]、B[0]是C的左右中位数。这种情况应该列入g(x)为True，保证lo是k个数的右边界</li></ul></li><li><p>考虑二分查找后，k寻找中位数的越界：</p><p>也就是考虑<code>A[m1]</code>，<code>B[m2]</code>，<code>A[m1+1]</code>，<code>B[m2+1]</code>四个索引是否越界。可以确定的B[m2]一定存在，因为即使B对k个小数没有任何贡献，A也不可能独立提供左右中位数，不然它的容量将超过B。A为空时，或者找不到g(x)为True时，<code>A[m1]</code>不存在。然后各自检查右边界，来判断是否存在<code>A[m1+1]</code>，<code>B[m2+1]</code>。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">median</span>(<span class="hljs-params">nums1, nums2</span>):</span><br>    n1, n2 = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-keyword">if</span> n1 &gt; n2:<br>            <span class="hljs-keyword">return</span> median(nums2, nums1)<br>        <span class="hljs-keyword">if</span> n2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        k = (n1+n2-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>        lo, hi = <span class="hljs-number">0</span>, n1-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> lo &lt;= hi:<br>            m1 = lo + (hi-lo) // <span class="hljs-number">2</span><br>            m2 = k - m1<br>            <span class="hljs-keyword">if</span> m2 == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums1[m1] &gt;= nums2[m2-<span class="hljs-number">1</span>]:<br>                hi = m1 - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                lo = m1 + <span class="hljs-number">1</span><br><br>        candidates = [nums2[k-lo]]<br>        <span class="hljs-keyword">if</span> n1 &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lo &lt; n1:<br>            candidates.append(nums1[lo])<br>            <span class="hljs-keyword">if</span> lo &lt; n1 - <span class="hljs-number">1</span>:<br>                candidates.append(nums1[lo+<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">if</span> k-lo &lt; n2 - <span class="hljs-number">1</span>:<br>            candidates.append(nums2[k-lo+<span class="hljs-number">1</span>])<br>        candidates.sort()<br>        <span class="hljs-keyword">if</span> (n1+n2) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> candidates[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(candidates[:<span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span><br></code></pre></div></td></tr></table></figure><p>这个版本和官方题解有区别，也AC了。不过虽然讨论这么多，也还是感觉没有讨论得足够完备。有机会在补充，可能还要再换个角度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果使用这种思路进行二分查找，前提是能找到这样一个具有二分性质的g(x)。返回值永远是lo，表明使得g(x)状态切换的边缘值。</p><p>具体的模板，我现在更倾向使用对称的那一版，即<code>while lo &lt;= hi</code>。</p><p>有一些问题，比如<a href="https://aptend.github.io/2019/06/20/rotated-array/">Rotated Array</a>的题，因为没有合适的g(x)可用，只能回归到原始的二分思想，一步步删除不包含最终解的搜索空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>LeetCode</tag>
      
      <tag>BinarySearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Rabin-Karp算法查找最长回文字符串</title>
    <link href="/2019/07/07/rabin-karp/"/>
    <url>/2019/07/07/rabin-karp/</url>
    
    <content type="html"><![CDATA[<p>利用Rabin-Karp，尝试解决LeetCode005_longest-palindromic-substring问题。Python实现，意义大于性能🙃</p><a id="more"></a><p>Rabin-Karp的基本运用是子字符串查找，因为利用hash值比较，因此也被称作<code>指纹</code>字符串查找算法。比如在文本S找查找长为M的字符串，在已知<code>S[i: i+M]</code>字符串的hash值时，Rabin-Karp可以在常数时间内计算出<code>S[i+1: i+M+1]</code>的hash值，因此可以在线性时间复杂度内，扫描S中所有长为M的子串。</p><p>回到LeetCode005_longest-palindromic-substring问题，一个回文字符串，正反的hash值一定相同，然后利用二分查找，可以找到一个最大的子字符串长度。在实现之前，先说明关于hash计算的数学基础。</p><h1 id="mod运算的一些性质"><a href="#mod运算的一些性质" class="headerlink" title="mod运算的一些性质"></a>mod运算的一些性质</h1><p>Rabin-Karp算法在计算hash值时，主要利用mod操作的几个性质来加速计算</p><h2 id="线性组合的分配律"><a href="#线性组合的分配律" class="headerlink" title="线性组合的分配律"></a>线性组合的分配律</h2><p>$$<br>(a+b)\mod n = [(a \mod n) + (b\mod n)]\mod n  \\<br>(ab)\mod n = [(a \mod n)(b\mod n)]\mod n<br>$$</p><p>简单的证明，设$a\mod n=x$， 有$a=pn+x$，同理有$b=qn+y$，所以加法等式替换为<br>$$<br> (pn+x+qn+y) \mod n = (x+y) \mod n<br>$$<br>这个就自然相等了。实际上mod分配一个还是两个都无所谓。基本的Rabin-Karp算法利用这个性质就可以了。如果要逆向计算字符串的hash值，就必须得借助下面两个性质。</p><h2 id="除法定义"><a href="#除法定义" class="headerlink" title="除法定义"></a>除法定义</h2><p>$$<br>\frac ab\mod n=(ab^{-1})\mod n<br>$$</p><p>根据分配率，求解需要$(b^{-1}\mod n)$，它的定义是，设$(b^{-1}\mod n)=I$，则有$bI\equiv1\space(\mod n)$，这里的$I$就被称为b的模反元素。也就是存在关系，$bI-1=pn$。</p><p>接下来就是证明，$\frac ab \mod n =aI\mod n$。把上述关系乘上等式左边，变为n的整数倍，余数为0，有$(aI-\frac ab)\mod n = 0$，即可证明。</p><h2 id="如何求模反元素"><a href="#如何求模反元素" class="headerlink" title="如何求模反元素"></a>如何求模反元素</h2><p>关系$bI-1=pn$换一种写法就是贝祖等式，$bI+(-p)n=1$</p><p>然后可以通过拓展欧几里得方法求得$I, p$</p><p>这里贴一个wiki上的例子</p><p><img src="https://s2.ax1x.com/2019/07/09/Z6ZnRH.png" alt="Z6ZnRH.png"></p><p>把图中的过程利用递归表达出来，就是所谓的拓展欧几里得算法：在原始的欧几里得算法递归完成后，输出当前贝祖等式的参数。<br><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exgcd</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># 1 = 1*1 + 0*0</span><br>    x, y = exgcd(b, a % b)<br>    x, y = y, x - (a//b)*y<br>    <span class="hljs-keyword">return</span> x, y<br></code></pre></div></td></tr></table></figure></p><h1 id="正反扫描的Rabin-Karp"><a href="#正反扫描的Rabin-Karp" class="headerlink" title="正反扫描的Rabin-Karp"></a>正反扫描的Rabin-Karp</h1><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabinKarp</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, text, M, R=<span class="hljs-number">128</span>, Q=<span class="hljs-number">100000037</span></span>):</span><br>        self.R = R<br>        self.M = M<br>        self.Q = Q<br>        self.text = text<br>        self.text_inv = text[::-<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><p>一些符号约定：</p><ul><li><p>R，把字符串看作R进制数。比如对于ASCII字符，不妨R=128，”abc”的hash值为:<br>$$<br>(97\times128^2+98\times128+99) \mod Q<br>$$</p></li><li><p>Q，对Q取模，Q必须为质数，保证R、Q互质，使R存在模反元素</p></li><li><p>M，子字符串长度</p></li></ul><p>实现分为正向和逆向两部分，正向就是原始的Rabin-Karp算法，逆向是为了求回文字符串做的增加。</p><h2 id="正向"><a href="#正向" class="headerlink" title="正向"></a>正向</h2><p>首先计算出起始位置上，长为M的子字符串的hash值——计算M位的R进制数对Q取模。利用mod的分配律，在每次计算时，都可以对Q取模，而不影响结果。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dummy_hash</span>(<span class="hljs-params">self, s</span>):</span> <span class="hljs-comment"># 传入text[:M]子字符串，直接计算hash值</span><br>       h = <span class="hljs-number">0</span><br>       <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>           h = (h * self.R + <span class="hljs-built_in">ord</span>(c)) % self.Q<br>       <span class="hljs-keyword">return</span> h<br></code></pre></div></td></tr></table></figure><p>记第一个子字符串<code>text[:M]</code>的hash值为：<br>$$<br>hash(text[:M])=t_0R^{M-1}+t_1R^{M-2}+…+t_{M-1} \mod Q<br>$$</p><p>第二个子字符串<code>text[1:M+1]</code>同样利用mod分配率，可以在常数时间内得到，因为由前一个R进制数，可以在常数时间内计算当前的R进制数——</p><ol><li>减去最高位</li><li>乘以R</li><li>再加上新增的末位</li></ol><p>$$<br>(t_0R^{M-1}+t_1R^{M-2}+…+t_{M-1} - t_0R^{M-1}) \times R +t_M<br>$$</p><p>考虑mod，上式等于：</p><p>$$<br>(((t_0R^{M-1}+t_1R^{M-2}+…+t_{M-1}) \mod Q-(R^{M-1} \mod Q)\times t_0)\times R+t_M) \mod Q<br>$$</p><p>第一项就是上一个字符串的hash值，第二项是最高位的取模，因为$(R^{M-1}\mod Q)$每次都会用到，所以事先计算出来保存。第三项就是多出来的末位。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, text, M, R=<span class="hljs-number">128</span>, Q=<span class="hljs-number">100000037</span></span>):</span><br>       <span class="hljs-comment"># ...</span><br>       <span class="hljs-built_in">pow</span> = <span class="hljs-number">1</span><br>       <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, M):<br>           <span class="hljs-built_in">pow</span> = (R * <span class="hljs-built_in">pow</span>) % Q<br>       self.<span class="hljs-built_in">pow</span> = <span class="hljs-built_in">pow</span>  <span class="hljs-comment"># R^(M-1) % Q</span><br></code></pre></div></td></tr></table></figure><p>然后使用生成器来返回从左往右的长为M的字符串hash值。在实际的实现中，减去最高项时使用又加上了Q，保证始终是正数，让%运算符有正确的结果。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_hash</span>(<span class="hljs-params">self</span>):</span><br>       txt, <span class="hljs-built_in">pow</span>, R, M, Q = self.text, self.<span class="hljs-built_in">pow</span>, self.R, self.M, self.Q<br>       txt_hash = self.dummy_hash(txt[:M])<br>       <span class="hljs-keyword">yield</span> txt_hash<br>       <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M, <span class="hljs-built_in">len</span>(txt)):<br>           txt_hash = (txt_hash + Q - <span class="hljs-built_in">pow</span> * <span class="hljs-built_in">ord</span>(txt[i-M]) % Q) % Q<br>           txt_hash = (txt_hash * R + <span class="hljs-built_in">ord</span>(txt[i])) % Q<br>           <span class="hljs-keyword">yield</span> txt_hash<br></code></pre></div></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>在常数时间内计算出逆序字符串的hash值，和正向的思路相似，也分三步：</p><ol><li>减去最低位</li><li>除以R</li><li>加上最高位</li></ol><p>最关键的第二步，除以R并且取模，就需要使用模反元素，把除法变为乘法，继续按照分配率的保证来分解运算。模拟元素这里使用拓展欧几里得算法获得，并在初始化中保存。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, text, M, R=<span class="hljs-number">128</span>, Q=<span class="hljs-number">100000037</span></span>):</span><br>       <span class="hljs-comment"># ...    </span><br>       self.invR, _ = self._exgcd(R, Q)<br>       <span class="hljs-keyword">if</span> self.invR &lt; <span class="hljs-number">0</span>:<br>           self.invR = self.invR % Q + Q<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_exgcd</span>(<span class="hljs-params">self, a, b</span>):</span><br>       <span class="hljs-string">&quot;&quot;&quot;omit remainder here</span><br><span class="hljs-string">       &quot;&quot;&quot;</span><br>       <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 1 = 1*1 + 0*0</span><br>       x, y = self._exgcd(b, a % b)<br>       <span class="hljs-keyword">return</span> y, x - (a//b)*y<br></code></pre></div></td></tr></table></figure><p>随后再利用生成器，对等地生成逆序子字符串的hash值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">   <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_hash_inv</span>(<span class="hljs-params">self</span>):</span><br>    txt, <span class="hljs-built_in">pow</span>, invR, M, Q = self.text_inv, self.<span class="hljs-built_in">pow</span>, self.invR, self.M, self.Q<br>    txt_hash = self.dummy_hash(txt[-M:])<br>    <span class="hljs-keyword">yield</span> txt_hash<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(txt)-M-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        txt_hash -= <span class="hljs-built_in">ord</span>(txt[i+M])<br>        txt_hash = (txt_hash * invR) % Q<br>        txt_hash += <span class="hljs-built_in">ord</span>(txt[i])*<span class="hljs-built_in">pow</span><br>        txt_hash = txt_hash % Q<br>        <span class="hljs-keyword">yield</span> txt_hash<br></code></pre></div></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>关键思想是根据回文的性质，分为奇数和偶数的情况，分开查找。</p><p>如果对于一个回文字符串长为M，只能断言，除去首尾两个字符，剩下的M-2的字符串也是回文字符串。也就是存在一个函数g(x)，返回值是True or False，表示在给定文本中，是否存在长为x的回文字符串，一个M使得g(M)为True，那么g(M-2)也为True，而g(M-1)无法确定。因此想要利用二分查找的方法，寻找使g(x)返回值切换的边界$M’$，需要分为奇数和偶数来查找。</p><p>首先定义出g(x)，用函数<code>can_solve_at(s, L)</code>来表示在文本s中，是否存在长为L的回文字符串，如果存在，返回字串起始位置，否则返回-1。当遇到hash值相同时，再用字符串比较来确定，防止$\frac 1Q$概率的hash值相同的误判。也就是拉斯维加斯算法。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_solve_at</span>(<span class="hljs-params">s, L</span>):</span><br>    rk = RabinKarp(s, L)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> h, h_inv <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(rk.gen_hash(), rk.gen_hash()):<br>        <span class="hljs-keyword">if</span> h == h_inv <span class="hljs-keyword">and</span> s[i:i+L] == <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">reversed</span>(s[i:i+L])):<br>            <span class="hljs-keyword">return</span> i<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>然后利用<code>can_solve_at</code>实现二分查找。这里的的L分为两半，左边为True，右边为False。当猜测的L=mid时为True,说明还可能存在更大的L使<code>can_solve_at</code>也为True，所以<code>lo = mid + 1</code>向右半区收缩。虽然最后并不关心搜索位置，lo的物理意义也不重要，但是也不妨分析一下，和常规的二分g(x)做比较。结果就是lo表示使得can_solve_at为False的最小值。</p><p>此外，实现中还有两点可注意：</p><ol><li><p>mid的计算使用了等差数列的二分技巧</p></li><li><p>因为求最长回文字符串，所以优先判断<code>2mid + 1</code>的结果</p></li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest_RK</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>    res = s[<span class="hljs-number">0</span>]<br>    lo, hi = <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = (lo + hi) // <span class="hljs-number">2</span><br>        idx_even = can_solve_at(s, <span class="hljs-number">2</span>*mid)<br>        idx_odd = can_solve_at(s, <span class="hljs-number">2</span>*mid+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> idx_odd &gt;= <span class="hljs-number">0</span>:<br>            idx, L = idx_odd, <span class="hljs-number">2</span>*mid+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            idx, L = idx_even, <span class="hljs-number">2</span>*mid<br>        <span class="hljs-keyword">if</span> idx &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> L &gt; <span class="hljs-built_in">len</span>(res):<br>                res = s[idx:idx+L]<br>            lo = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            hi = mid - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>Rabin-Karp的性能，应用</p><p>理论上Rabin-Karp的性能是稳定的线性级别，算上二分查找，应该也是$O(nlogn)$的解法，比常规的$O(n^2)$解法要好，但是当前实现在LeetCode仅beats 42%。当然和Python本身运行速度有关，排名意义不大。</p><p>Rabin-Karp这种用指纹的查找方法，在思路上还可以更开阔一些，比如可以在二维结构中找寻找特定模式。另外一点好处是它不需要额外的内存空间。</p></li><li><p>二分查找的变化</p><p>这里又是二分查找的一种变化，除了g(x)本身的含义改变，连搜索空间也不再是连续自然数。所以需要更灵活地认识二分查找的一些核心，还要再复习一下中位数</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>LeetCode</tag>
      
      <tag>BinarySearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础排序算法总结：从逆序对的角度</title>
    <link href="/2019/06/26/elementry-sorting/"/>
    <url>/2019/06/26/elementry-sorting/</url>
    
    <content type="html"><![CDATA[<p>从逆序对inversion的角度，重新审视基础排序算法，选择、插入、冒泡、希尔，他们到底什么关系？</p><a id="more"></a><p>首先证明：</p><p>在数组中交换一个逆序对，一定会使总的逆序对减小</p><blockquote><p>Given an array of N keys, let a[i] and a[j] be an inversion (i &lt; j but a[i] &gt; a[j]). Prove or disprove: swapping a[i] and a[j] strictly decreases the number of inversions</p></blockquote><p>处在i，j两侧的数不会因为这次交换产生逆序对的变动，只需要考虑<code>nums[i+1:j]</code>中的数，自然地，把这个区间的数根据<code>nums[i], nums[j]</code>分成三堆（忽略相等的情况，对逆序对没有影响），分别统计这三堆因为这次交换产生的逆序对变动就可以。</p><p><img src="https://s2.ax1x.com/2019/06/25/ZZgjoR.png" alt="ZZgjoR.png"></p><p>可以看到，交换一个inversion，至少减少一个inversion。当<code>j-i=1</code>，交换相邻的inversion，确定地减少一个inversion。交换不相邻的inversion，inversion的总数有可能减少得更快。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思路：选择最小元素，放入有序数组的空位。</p><p>选择方法：<code>n次比较+1次交换</code>。</p><p>特点：过程中<strong>没有利用</strong>计算产生的新信息，即有序数组。</p><p>性能：固定的$N^2/2$次比较和$N$次交换</p><p>稳定：否</p><p>使用场景：交换操作非常昂贵，逆序对比较多</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection</span>(<span class="hljs-params">nums</span>):</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        m, v = i, nums[v]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, N):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; v:<br>                m = j<br>        nums[i], nums[m] = nums[m], nums[i]<br></code></pre></div></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>思路：将一个新元素，插入进一个有序数组，原数组中所有元素插入完毕，排序结束。</p><p>插入方法： <code>比较+交换 or 比较+移动 or 二分+移动</code></p><p>特点：过程中<strong>利用了</strong>计算产生的新信息，即有序数组</p><p>性能：见下列代码中的讨论。实际上移动本质也是交换，而且也是相邻inversion的交换，所以总的交换(移动)次数等于总的逆序对个数。</p><p>稳定：是</p><p>使用场景：小规模数组，流式输入数据，逆序对较少，比如：</p><ul><li>数组中每个元素离他的最终位置都不远</li><li>一个有序的大数组接一个小数组</li><li>数组中只有几个元素位置不正确</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion</span>(<span class="hljs-params">nums</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    交换的次数就是逆序对的个数，设为V</span><br><span class="hljs-string">    如果内循环是break跳出的，那么比较次数=交换次数+1</span><br><span class="hljs-string">    如果内循环是range跳出的，那么比较次数=交换次数。比如nums[j]比nums[:i]都小</span><br><span class="hljs-string">    看最外层循环，最多有range(1, N)个break的机会</span><br><span class="hljs-string">    所以比较的次数C有V &lt;= C &lt;= V + len(nums)-1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 询问左侧每个位置，要不要交换</span><br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>]:<br>                nums[j+<span class="hljs-number">1</span>], nums[j] = nums[j], nums[j+<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_no_exchange</span>(<span class="hljs-params">nums</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    把交换操作变为移动，也就是把一个数字往后移动一格。数组访问的次数由4变为2</span><br><span class="hljs-string">    数组比较次数没有变</span><br><span class="hljs-string">    减少控制流比较的方式是使用flag, Algo4给出方案(练习)的是使用哨兵。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>        v = nums[i]<br>        use_break = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 询问每个左侧每个位置，要不要移动</span><br>            <span class="hljs-keyword">if</span> nums[j] &gt; v:<br>                nums[j+<span class="hljs-number">1</span>] = nums[j]<br>            <span class="hljs-keyword">else</span>:<br>                use_break = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> use_break:       <span class="hljs-comment"># nums[j] &lt;= v, nums[j+1] 是为 v 空出来的格子</span><br>            nums[j+<span class="hljs-number">1</span>] = v<br>        <span class="hljs-keyword">else</span>:               <span class="hljs-comment"># 每个位置都要求交换, nums[0] 就是为 v 空出来的格子</span><br>            nums[<span class="hljs-number">0</span>] = v<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_binary</span>(<span class="hljs-params">nums</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    同样数组的移动次数等于逆序对个数</span><br><span class="hljs-string">    比较次数由平均n/2减少到logn，所以O(n^2)的常数因子会变得更小一些</span><br><span class="hljs-string">    整个过程还是由移动dominant</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>        v = nums[i]<br>        lo, hi = <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> lo &lt;= hi:<br>            mid = (lo + hi) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt; v:<br>                hi = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>, lo-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            nums[j+<span class="hljs-number">1</span>] = nums[j]<br>        nums[lo] = v<br></code></pre></div></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思路：结构上同选择排序，选择最大元素，放入有序数组空位。</p><p>选择方法： <code>比较+交换</code></p><p>特点：过程中<strong>利用了</strong>计算产生的新信息，但没有利用有序数组，利用的剩下的、经过交换的<strong>部分有序</strong>数组</p><p>性能：在比较中使用了交换，所以最终总的交换(移动)次数等于总的逆序对个数。但是比较仍然和选择相同，$N^2/2$。不过可以通过加入一个flag，标记本轮没有发生交换后提早退出。</p><p>稳定：是</p><p>所以冒泡排序实际上处于一个很尴尬的位置。交换虽然没有多做，但是有很多无意义的比较，因为要从部分有序数组里面寻找逆序对，会比较很多已经有序的数对。尽管设置flag可以减少很多，但是在最后一轮中，如果逆序对出现在靠后的位置，前面还是做了一些多余的比较，依然达不到插入那样节省。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble</span>(<span class="hljs-params">nums</span>):</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 总共填充N-1个位置，剩余一个自然有序</span><br>        changed = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i):  <span class="hljs-comment"># 从开始处冒泡</span><br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>]:<br>                nums[j+<span class="hljs-number">1</span>], nums[j] = nums[j], nums[j+<span class="hljs-number">1</span>]<br>                changed = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> changed:    <span class="hljs-comment"># 逆序对为0，全部有序</span><br>            <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>思路：利用插入排序，在更大跨度上做排序，最后使用跨度为1的插入排序保证全部有序。</p><p>基础方法：生成递增序列+插入排序</p><p>特点 &amp; 性能：希尔排序就是插入排序的直接拓展，由inversion的证明可知，希尔排序通过大跨度扫描，交换inversion，可以更快地减少总的inversion，为接下来的小跨度扫瞄交换创造有利条件。和归并、快排的性能差距在常数级别</p><p>稳定：否</p><p>除了上述的原理，还有实现上有两个地方注意：</p><ol><li>实现数组h-有序时，相当于需要对h个子数组进行排序。与其事先计算出每个子数组的index，不如扫描所有未排定的数，也就是从index=h的开始，根据它的index倒推回去，index=h表示它属于<code>h%h=0</code>号子数组，index=h+1的表示它属于1号子数组，依次类推，各自在自己的子数组里比较、插入</li><li>使用binary-search优化时，mid的计算涉及到等差数列的上下中位数的计算，因为还有其他题目涉及，我总结到<a href="https://aptend.github.io/2019/07/14/median/">这篇笔记</a>里</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_h</span>(<span class="hljs-params">nums, h=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    利用插入排序，将nums变为h-有序的</span><br><span class="hljs-string">    对于每个数，通过插入排序，和自己同组元素比较、移动</span><br><span class="hljs-string">    每个数安排完，就可以了</span><br><span class="hljs-string">    &gt;&gt;&gt; a = [7, 6, 2, 4, 9, 8, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; a1, a2, a3 = a[:], a[:], a[:]</span><br><span class="hljs-string">    &gt;&gt;&gt; sort_h(a1, h=1)</span><br><span class="hljs-string">    &gt;&gt;&gt; sort_h(a2, h=2) # [1,x,2,x,7,x,9] + [x,4,x,6,x,8]</span><br><span class="hljs-string">    &gt;&gt;&gt; sort_h(a3, h=3) # [1,x,x,4,x,x,7] + [x,6,x,x,9,x,x] + [x,x,2,x,x,8,x]</span><br><span class="hljs-string">    &gt;&gt;&gt; a1</span><br><span class="hljs-string">    [1, 2, 4, 6, 7, 8, 9]</span><br><span class="hljs-string">    &gt;&gt;&gt; a2</span><br><span class="hljs-string">    [1, 4, 2, 6, 7, 8, 9]</span><br><span class="hljs-string">    &gt;&gt;&gt; a3</span><br><span class="hljs-string">    [1, 6, 2, 4, 9, 8, 7]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h, N):  <span class="hljs-comment"># [0:h]是各组数第一个，跳过它</span><br>        v = nums[i]<br>        use_break = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-h, -<span class="hljs-number">1</span>, -h):  <span class="hljs-comment"># 询问每个左侧每个同组的位置，要不要移动</span><br>            <span class="hljs-keyword">if</span> nums[j] &gt; v:<br>                nums[j+h] = nums[j]<br>            <span class="hljs-keyword">else</span>:<br>                use_break = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> use_break:       <span class="hljs-comment"># nums[j] &lt;= v, nums[j+h]是为 v空出来的格子</span><br>            nums[j+h] = v<br>        <span class="hljs-keyword">else</span>:               <span class="hljs-comment"># 每个位置都要求交换, 同组的第一个就是空出来的位置</span><br>            nums[i%h] = v<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_binary_h</span>(<span class="hljs-params">nums, h=<span class="hljs-number">1</span></span>):</span>    <br>    N = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h, N):<br>        v = nums[i]<br>        lo, hi = i%h, i-h<br>        <span class="hljs-keyword">while</span> lo &lt;= hi:<br>            mid = <span class="hljs-built_in">int</span>((hi - lo) / h / <span class="hljs-number">2</span>)<br>            mid = lo + mid*h<br>            <span class="hljs-keyword">if</span> nums[mid] &gt; v:<br>                hi = mid - h<br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + h<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-h, lo-<span class="hljs-number">1</span>, -h):<br>            nums[j+h] = nums[j]<br>        nums[lo] = v<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_seq</span>(<span class="hljs-params">N</span>):</span><br>    h = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> h &lt; N // <span class="hljs-number">3</span>:<br>        h = <span class="hljs-number">3</span>*h + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> h &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">yield</span> h<br>        h = h // <span class="hljs-number">3</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell</span>(<span class="hljs-params">nums</span>):</span><br>    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> gen_seq(<span class="hljs-built_in">len</span>(nums)):<br>        sort_h(nums, h)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_binary</span>(<span class="hljs-params">nums</span>):</span><br>    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> gen_seq(<span class="hljs-built_in">len</span>(nums)):<br>        sort_binary_h(nums, h)<br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>插入排序还是本体，无论从思想上还是实现上，其他方法都可借鉴、对比</p><p>基础排序实现时，关注点不妨放在“位置上”，一个萝卜一个坑，思路会更清晰一点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rotated Array 相关四题总结</title>
    <link href="/2019/06/20/rotated-array/"/>
    <url>/2019/06/20/rotated-array/</url>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 033、081、153、154共四道rotated array的题目。重新梳理最原始的二分思想</p></blockquote><a id="more"></a><p>对旋转数组的切入视角是，在一个确定的旋转数组里，一刀切下去，一定会分成一个有序数组和一个规模更小的旋转数组。比如[5,6,1,2,4]，mid为1，那么左侧就是另一个旋转数组：[5，6，1]， 右侧就是一个有序数组[1, 2, 4]。这个可以通过和边缘数的比较来判断。</p><p><img src="https://s2.ax1x.com/2019/06/20/VxCYk9.png" alt="VxCYk9.png"></p><h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033 - Search in Rotated Sorted Array"></a>033 - Search in Rotated Sorted Array</h1><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).<br><br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br><br>You may assume no duplicate exists in the array.<br><br>Example 1:<br>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4<br><br>Example 2:<br>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1<br></code></pre></div></td></tr></table></figure><p>因为不存在重复数，所以当<code>nums[mid]</code>大于等于左侧边缘数<code>nums[lo]</code>时，说明左边就是一个有序数组；等于时说明mid=lo，只含一个数的有序数组。</p><p>然后就可以利用有序数组来判断target是否存在，不存在，就在切分的另一个数组里。</p><p>这里就回到了二分查找的最初的思路，每次检查mid是否是我们要找的数，是就返回，不是再根据情况删除一部分解空间。如此循环，直到找到解，或者解空间耗尽。</p><p>根据二分的实际实现，如果不满足条件，<strong>下一次搜索空间必然不包含mid</strong>。这样切入视角所说的一定切为有序和旋转，并不成立，旋转数组可能因为排除mid而消失，最后只剩下有序数组。所以视角不妨改成，旋转数组切分后，一定能找一个有序数组，有这样一个保证就足够了。但是原始的切入视角，之后会用到</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">nums, target</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = (lo + hi) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>       <span class="hljs-keyword">if</span> nums[mid] &gt;= nums[lo]:  <span class="hljs-comment"># 左侧一定就是有序数组</span><br>            <span class="hljs-keyword">if</span> nums[lo] &lt;= target &lt; nums[mid]:<br>                hi = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:                      <span class="hljs-comment"># 右侧一定是有序数组</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &lt;= nums[hi]:<br>                lo = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hi = mid - <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h1 id="081-Search-in-Rotated-Sorted-Array-II"><a href="#081-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="081 - Search in Rotated Sorted Array II"></a>081 - Search in Rotated Sorted Array II</h1><p>这次不含重复数的要求删除，有什么变化呢？</p><p>不妨考虑一个极端情况，[42, 42, 42, 42, 42] 这样数组，target是41。什么情况？简单的说，上一题所依赖的，一次切分，一定会找到<strong>一个</strong>有序数组的保证，不见了。所以这个题的时间复杂度最坏的情况只能是O(n)。也就是不论怎么和左右两侧数比较，只要出现等于的情况，就不能舍弃任何一侧的搜索空间，那这个时候怎么办？只能说明mid不是target，应该删除它。</p><p>当然删除中间的mid并不好操作，实际上有一个更微妙的实现：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">nums, target</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = (lo + hi) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-comment"># mid不是解，所以把开头的mid全部删除       </span><br>        <span class="hljs-keyword">while</span> lo &lt; mid <span class="hljs-keyword">and</span> nums[lo] == nums[mid]:<br>            lo += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果因为不等跳出循环，下面一个会取大于</span><br>        <span class="hljs-comment"># 如果因为lo = mid跳出循环，下面一定会取等于</span><br>       <span class="hljs-keyword">if</span> nums[mid] &gt;= nums[lo]:  <span class="hljs-comment"># 左侧一定就是有序数组</span><br>            <span class="hljs-keyword">if</span> nums[lo] &lt;= target &lt; nums[mid]:<br>                hi = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:                      <span class="hljs-comment"># 右侧一定是有序数组</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &lt;= nums[hi]:<br>                lo = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hi = mid - <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h1 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153 - Find Minimum in Rotated Sorted Array"></a>153 - Find Minimum in Rotated Sorted Array</h1><p>题面：在不含重复数的旋转数组里找最小值。</p><p>最小值一定在规模更小的旋转数组当中，我们就可以通过二分法，不停地减小旋转数组的规模，直到找到最小规模的旋转数组，一个逆序对，左侧是最大数，右侧就是最小数。这里就回到了我们最初的切入点，这一次，我们需要小心地排除搜索空间，保证留下的搜索空间里有旋转数组。</p><p>所以当<code>nums[mid] &gt;= nums[lo]</code>成立，[lo, mid]的闭区间有序，应该排除，但是不能排除mid，因为mid可能和右侧的数组成旋转数组。事实上，在不含重复数的前提下里，这一句判断永远无法取到等号，因为等号成立时，<code>mid=lo -&gt; hi - lo &lt;= 1</code> 已经跳出循环了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findmin</span>(<span class="hljs-params">nums</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[lo] &lt; nums[hi]:  <span class="hljs-comment"># 排除有序的情况，因为切分后不存在旋转数组</span><br>        <span class="hljs-keyword">return</span> nums[lo]<br>    <span class="hljs-keyword">while</span> hi - lo &gt; <span class="hljs-number">1</span>:  <span class="hljs-comment"># 只剩两个元素时停止</span><br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= nums[lo]:  <span class="hljs-comment"># 大于，左边为有序数组，排除掉</span><br>            lo = mid<br>        <span class="hljs-keyword">else</span>:                     <span class="hljs-comment"># 小于，右边为有序数组，排除掉</span><br>            hi = mid<br>    <span class="hljs-keyword">return</span> nums[hi]<br></code></pre></div></td></tr></table></figure><p>除了找逆序对，二分还可以用找元素的视角来做，这就是LeetCode给出的Solution的做法。具体地，我们要找到一个索引，满足：<code>nums[s] &gt; nums[s+1]</code> 或者 <code>nums[s-1] &gt; nums[s]</code>。也就是找到最小规模的旋转数组中的任意一个。因为必须找到一个数，就要彻底排除mid</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findmin</span>(<span class="hljs-params">nums</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[lo] &lt; nums[hi]:  <span class="hljs-comment"># 排除有序的情况，因为不存在旋转数组，实际上python的-1索引可用</span><br>        <span class="hljs-keyword">return</span> nums[lo]<br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-comment"># 只要确保当前的比较顺序，边界检查并不需要</span><br>        <span class="hljs-comment"># 合理的输入不可能mid=len(nums)，因为如果逆序对在最后两个，那么前一次循环已经找到了</span><br>        <span class="hljs-comment"># mid=0，可能，所以用现在这样的比较顺序，逆序对在头两个时可以先返回</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[mid+<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> nums[mid+<span class="hljs-number">1</span>]<br>       <span class="hljs-keyword">if</span> nums[mid-<span class="hljs-number">1</span>] &gt; nums[mid]:<br>            <span class="hljs-keyword">return</span> nums[mid]<br>        <span class="hljs-comment"># 没找到，自然应该排除mid，因为mid不是逆序对中的任何一个</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= nums[lo]:<br>            lo = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            hi = mid - <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h1 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154 - Find Minimum in Rotated Sorted Array II"></a>154 - Find Minimum in Rotated Sorted Array II</h1><p>作为153的拓展，154同样取消了不含重复数的前提。这就要求在等于的时候，只能删除一个数，当然删除这个数时也要非常小心，不能删除掉逆序对中的数，比如输入[10, 1, 10, 10, 10]，第一次查找就是等于，但是首位的10不能删除。所以需要判断是否处在逆序对中，是，可以直接返回结果，否，删除这个数进行收缩。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findmin</span>(<span class="hljs-params">nums</span>):</span><br>    lo, hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> nums[lo] &lt; nums[hi]:  <span class="hljs-comment"># 排除有序的情况，因为切分后不存在旋转数组</span><br>        <span class="hljs-keyword">return</span> nums[lo]<br>    <span class="hljs-keyword">while</span> hi - lo &gt; <span class="hljs-number">1</span>:  <span class="hljs-comment"># 只剩两个元素时停止</span><br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[lo]: <br>            lo = mid<br>        <span class="hljs-keyword">elif</span> nums[mid] &lt; nums[lo]:     <span class="hljs-comment"># 小于，右边为有序数组，排除掉</span><br>            hi = mid<br>        <span class="hljs-keyword">elif</span> nums[lo] &lt;= nums[lo+<span class="hljs-number">1</span>]:<br>            lo += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            hi = lo + <span class="hljs-number">1</span>  <span class="hljs-comment"># 等效于return nums[lo+1]</span><br><span class="hljs-keyword">return</span> nums[hi]<br></code></pre></div></td></tr></table></figure><p>按照查找元素的思路也是可以做的，唯一的区别是，在循环中没找到逆序对怎么办？说明这是一个全等数组，返回<code>nums[0]</code>就可以</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findmin</span>(<span class="hljs-params">nums</span>):</span><br>hi = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[lo] &lt; nums[hi]:<br>        <span class="hljs-keyword">return</span> nums[lo]<br>    <span class="hljs-keyword">while</span> lo &lt;= hi:<br>        mid = lo + (hi - lo) // <span class="hljs-number">2</span><br>        <span class="hljs-comment"># 这里需要边界检查</span><br>        <span class="hljs-keyword">if</span> mid &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[mid] &gt; nums[mid+<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> nums[mid+<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> nums[mid-<span class="hljs-number">1</span>] &gt; nums[mid]: <span class="hljs-comment"># 逆序对在最前会被上面语句截断，不用边检</span><br>            <span class="hljs-keyword">return</span> nums[mid]<br>        <br>        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[lo]:<br>            lo = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[mid] &lt; nums[lo]:<br>            hi = mid - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 全等数组lo会累加，所以也需要边界检查</span><br>        <span class="hljs-keyword">elif</span> lo &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[lo] &gt; nums[lo+<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> nums[lo+<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            lo += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最原始的二分的关键点：</p><ol><li>始终要保证搜索空间中保留着解的可能性。不能在收缩的过程中把想要找的目标给排除在外了。两个find min的题，两种思路，既可以查找逆序对，又可以查找元素，对应的跳出条件和收缩就不一样</li><li>搜索过程中判断目标是否找到，是个很灵活的事情。不一定要有，更不是一定发生在mid求值之后。g(x)视角的lower-bound、higher-bound就没有，find min II有发生在特殊的收缩语句之前。</li><li>查找元素的是个稳定的视角，可要看到其他的可能性。查找逆序对的比较就少很多</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
      <tag>LeetCode</tag>
      
      <tag>BinarySearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advent of Code 2018 回顾</title>
    <link href="/2019/06/16/advent/"/>
    <url>/2019/06/16/advent/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在AoC里狗刨的20天。</p></blockquote><a id="more"></a><p><img src="https://s2.ax1x.com/2019/06/16/V7J4aT.gif" alt="V7J4aT.gif"></p><p>从哪知道AoC的？已经记不清了。但是，故事的收尾，我总结为，两个“真的”，两个“重要”。</p><p><strong>菜。我是真的菜。</strong></p><p><strong>厉害，排行榜上的人是真的厉害</strong>。</p><p>总排行第4，Robert Xiao。没想到在这儿还能遇到。CMU FIG组成员，论文<a href="https://www.robertxiao.ca/research/viband/">ViBand</a>当时都给我看傻了，视频演出效果简直梦幻。个个都是人才，十几二十分钟就把问题解决了。</p><p>我菜嘛，那就不谈了。都没敢定时做，把题盘清楚了，老老实实写出来就是我现阶段的目标。既然因为菜，就要多总结，希望有所成长</p><p><strong>基础算法很重要</strong></p><p><strong>代码的可读性很重要</strong></p><p>我做到第22题，是真的做不动，一直在徘徊：想知道一个点到起点的最短距离，就需要知道周围四个点的最短距离，可这样是循环依赖的，看不到出口。到reddit上，才确认要用Dijkstra算法，于是把算法书掏出来，老老实实地看完有向图和最短路径章节，做好笔记，这才到23题上成功运用。</p><p>最近也在跟朋友学习乒乓球，越发认识到基本功的重要程度。正手攻球都不稳定，打的都是运气乒乓球。牢记基本概念，在概念定理的基础上去适应问题。</p><p>代码的可读性很重要。这个说来也巧，我在网上搜AoC的时候，看到了Elixir的作者Jose Valim在Twitch上用Exilir做AoC，仔细、流程完整：划分功能模块、取合适的名字、尽可能地写函数测试。虽然他这样做的部分原因是为了介绍Elixir的特性。但是我自己看下来很受用，于是也模仿他，不把每个题粗糙地当作算法题，得出结果就完事儿，也尽力保证代码的可读性。可惜这套视频不完整，中间很多天的录播都找不到了。</p><p>接下来对一些印象比较深的题做一个回顾。</p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>实际上是一个topo排序题。topo排序看过，但是理解得不深，导致第一次做的时候用错误的图结构在硬套DFS解法，误入歧途。topo排序图边<code>v-&gt;w</code>的物理含义有两种：</p><ol><li>表示依赖，w要先做，v后做，DFS解法用后序；</li><li>表示优先级，v要先做，w后做，DFS解法中用逆后序。</li></ol><p>topo还有一种非递归的方法，在表示依赖的情况下，出度为0的先做；在表示优先级的情况下，入度为0先做（这里本质上也是转化为依赖的表示形式）</p><p>非递归在本题里更适合，因为在有多个可以执行的任务时，有要求字母序，DFS不好做限制</p><h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><p>写了一个双向链表模拟游戏过程，结果看到有人用deque来做，当然代码更简洁，速度还快10倍。了解了一下deque的原理，也是用的双向链表，但是链表的元素是大小为64的数组块，这样指针更少，内存开销更小，申请、回收的效率也更高。从初始化也看出来，左右索引在初始block的中间，然后往两边扩展。这样也确实满足官方文档的强调的memory efficiency &amp; append/pop either side with O(1)</p><blockquote><p>Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BLOCK</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BLOCK</span> *<span class="hljs-title">leftlink</span>;</span><br>    PyObject *data[BLOCKLEN];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BLOCK</span> *<span class="hljs-title">rightlink</span>;</span><br>&#125; block;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    block *leftblock;<br>    block *rightblock;<br>    Py_ssize_t leftindex;       <span class="hljs-comment">/* 0 &lt;= leftindex &lt; BLOCKLEN */</span><br>    Py_ssize_t rightindex;      <span class="hljs-comment">/* 0 &lt;= rightindex &lt; BLOCKLEN */</span><br>    <span class="hljs-keyword">size_t</span> state;               <span class="hljs-comment">/* incremented whenever the indices move */</span><br>    Py_ssize_t maxlen;          <span class="hljs-comment">/* maxlen is -1 for unbounded deques */</span><br>    PyObject *weakreflist;<br>&#125; dequeobject;<br><br>deque_new(PyTypeObject *type, PyObject *args, PyObject *kwds)<br>&#123;<br>    ...<br>b = newblock();<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">NULL</span>) &#123;<br>        Py_DECREF(<span class="hljs-built_in">deque</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    MARK_END(b-&gt;leftlink);<br>    MARK_END(b-&gt;rightlink);<br><br>    Py_SIZE(<span class="hljs-built_in">deque</span>) = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">deque</span>-&gt;leftblock = b;<br>    <span class="hljs-built_in">deque</span>-&gt;rightblock = b;<br>    <span class="hljs-built_in">deque</span>-&gt;leftindex = CENTER + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">deque</span>-&gt;rightindex = CENTER;<br>    <span class="hljs-built_in">deque</span>-&gt;state = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">deque</span>-&gt;maxlen = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">deque</span>-&gt;weakreflist = <span class="hljs-literal">NULL</span>;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但从这个题来看，会在链表的中间添加和删除，deque的解法使用rotate再append、pop，rotate的复杂度也不是O(1)，所以从时间复杂度看不会比完全的双向链表快。那还比我快10倍，大概就是Python慢吧……</p><h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><p>思路上把矿车单独提出来成为一个集合，然后模拟前进、转弯。具体的有两处值得拿出来讲：</p><ol><li>允许矿车出现拐角处和十字交汇处。代码会自动推断矿车所处的位置。但是推断建立在不存在T型路口的前提下</li><li>转弯部分的逻辑使用的旋转矩阵，避免穷举</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">DIRECTIONS = &#123;<br>    <span class="hljs-string">&#x27;&gt;&#x27;</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-string">&#x27;&lt;&#x27;</span>: (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>),<br>    <span class="hljs-string">&#x27;^&#x27;</span>: (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-string">&#x27;v&#x27;</span>: (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>&#125;<br>TURNS = &#123;<br>    <span class="hljs-string">&#x27;left&#x27;</span>: [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]],<br>    <span class="hljs-string">&#x27;ahead&#x27;</span>: [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]],<br>    <span class="hljs-string">&#x27;right&#x27;</span>: [[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后把运行图画出来看起来还是挺好看的。</p><h1 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h1><p>思路是每一处溢出的地方，可以看成一个新的喷泉，形成一个可以递归的子问题。对每一处下降的水流，寻找地面(# or ~)，然后向左右两端寻找墙角或者溢出口，如果溢出口已经存在‘|’，不要进入下次递归，因为这表示已经有函数在做过了。这也是寻找的地面不包含‘|’的原因：如果地面是‘|’，那么溢出口也一定是‘|’，反正会终止。下面代码就是在水面两侧的类型</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">End</span>(<span class="hljs-params">Enum</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    #x                x            x    </span><br><span class="hljs-string">    ####  :WALL      |### :WATER   .### :EMPTY</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    WALL = <span class="hljs-number">0</span>   <span class="hljs-comment"># 墙角，填充返回就好</span><br>    WATER = <span class="hljs-number">1</span>  <span class="hljs-comment"># 溢出口，但是不需要进入递归</span><br>    EMPTY = <span class="hljs-number">2</span>  <span class="hljs-comment"># 溢出口，需要进入递归</span><br></code></pre></div></td></tr></table></figure><h1 id="day20"><a href="#day20" class="headerlink" title="day20"></a>day20</h1><p>这个题难了我好久。首先是题目是这么说的</p><blockquote><p>So, <code>^N(E|W)N$</code> contains a branch: after going north, you must choose to go <em>either east or west</em> before finishing your route by going north again. </p></blockquote><p>刚开始，我理解的<code>going north again</code>是在岔路的基础之上，所以最远距离就是3。但后来想，也可以理解成在岔路起点的基础上继续，最远距离就是2。前一种理解是平行空间，有一种是现实意义上的岔路。我也观察了一下输入数据，发现并没有展开平行宇宙的机会——根本没有上面例子中的那种输入，也就是但凡|在括号中间，反括号后面都没有继续行动</p><p>但还是按照前一种理解，因为感觉更难一些。</p><p>因为之前做了day17，惯性驱使想用递归。在分叉点划出子问题，等待结果，然后求局部最大值，最外层得到全局最大值。但是渐渐发现对两种岔路形式的处理实际上很不相同。我单独为只有一种特征岔路的情况写了递归方案，但是整合的时候依然很困难。</p><p>在<code>(oo|)</code>模式为原路返回的假设下(虽然输入也确实也是如此)，<code>ooo(oo|)o(oooo|)o(oooooo|)oo</code> 本身也应该是一种递归，本质长这样子：<code>ooo(o|o(oo|o(ooo|oo)))</code></p><p>我还是没能在同一个递归里处理清楚这两种行为很不相同，实际上又相互联系的模式。最后走向了迭代的路子。</p><p>正是因为两种模式的行为差别，在迭代里维护了两个栈，记录分岔点，当前层级的分支个数。对<code>)</code>和<code>|)</code>也是分开处理，才能完成“平行空间”的要求</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix"><span class="hljs-keyword">if</span> <span class="hljs-attr">ch</span> == &#x27;(&#x27;:<br>    stack.append((x, y))<br>    forks_stack.append(n_forks)<br>    <span class="hljs-attr">n_forks</span> = <span class="hljs-number">0</span><br>elif <span class="hljs-attr">ch</span> == &#x27;|&#x27;:<br>    <span class="hljs-keyword">if</span> ins[i+<span class="hljs-number">1</span>] == &#x27;)&#x27;:  <span class="hljs-comment"># 遇到原路返回型岔路，备选+1，回到(开始处</span><br>        i += <span class="hljs-number">1</span><br>        x, <span class="hljs-attr">y</span> = stack.pop()<br>        <span class="hljs-attr">n_forks</span> = forks_stack.pop()<br>        <span class="hljs-attr">steps</span> = rooms[(x, y)]<br>    <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 当前点入栈，因为平行空间可能在此基础上继续。</span><br>                         <span class="hljs-comment"># 备选+1，回到(开始处</span><br>        stack.append((x, y))<br>        n_forks += <span class="hljs-number">1</span><br>        x, <span class="hljs-attr">y</span> = stack[-<span class="hljs-number">1</span> - n_forks]<br>        <span class="hljs-attr">steps</span> = rooms[(x, y)]<br>elif <span class="hljs-attr">ch</span> == &#x27;)&#x27;:<br>    for _ <span class="hljs-keyword">in</span> range(n_forks):   <span class="hljs-comment"># 在最长岔路基础上继续</span><br>        <span class="hljs-attr">fork</span> = stack.pop()<br>        <span class="hljs-keyword">if</span> rooms[fork] &gt; steps:<br>            x, <span class="hljs-attr">y</span> = fork<br>            <span class="hljs-attr">steps</span> = rooms[fork]<br>    stack.pop()                  <span class="hljs-comment"># 抛弃原始(开始处</span><br>    <span class="hljs-attr">n_forks</span> = forks_stack.pop()  <span class="hljs-comment"># 回到上层的岔路计数</span><br></code></pre></div></td></tr></table></figure><p>总结一下，像这种求全局最大值，又有明晰的指令，一步一步模拟出来可能是比递归更自然的解决方式。</p><h1 id="day22"><a href="#day22" class="headerlink" title="day22"></a>day22</h1><p>在最短路径算法的应用上，我的思路是，每一块地形，都对应两种工具，所以每一块地都有两个点，在同一块地上切换工具，路径权重就是7</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">g.add_edge(Edge(src, src+<span class="hljs-number">1</span>, <span class="hljs-number">7</span>))<br>g.add_edge(Edge(src+<span class="hljs-number">1</span>, src, <span class="hljs-number">7</span>))<br></code></pre></div></td></tr></table></figure><p>然后就是该地形指向周围4个地型的边，只有是相同工具时，才能移动，就是1，否则需要在本地切换工具再移动。转换信息用deltas表示，转换顺序用edge_order表示</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 0: rocky  [torch gear]</span><br><span class="hljs-comment"># 1: wet    [gear neither]</span><br><span class="hljs-comment"># 2: narrow [torch neither]</span><br><br><span class="hljs-comment"># delta[0][1] means </span><br><span class="hljs-comment"># (rocky[0] -&gt; wet[0], # rocky with torch -&gt; wet with gear</span><br><span class="hljs-comment">#  rocky[0] -&gt; wet[1],</span><br><span class="hljs-comment">#  rocky[1] -&gt; wet[0],</span><br><span class="hljs-comment">#  rocky[1] -&gt; wet[1])</span><br><br>deltas = [<br>    [(<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>), (<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">None</span>), (<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)],<br>    [(<span class="hljs-literal">None</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>), (<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>), (<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>)],<br>    [(<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>), (<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>)],<br>]<br>edge_order = [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>...<br><br>delta = deltas[src_type][to_type]<br><span class="hljs-keyword">for</span> idx, weight <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(delta):<br>    <span class="hljs-keyword">if</span> weight <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">continue</span><br>    d1, d2 = edge_order[idx]<br>    g.add_edge(Edge(src+d1, to+d2, weight))<br></code></pre></div></td></tr></table></figure><p>还有就是python没有内置可以方便修改值的优先队列，所以在Dijkstra内部本来需要修改点的地方，不用判断是否在优先队列里，直接添加，在外面通过一个集合去重</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">dist, v = heappop(heap)<br><span class="hljs-keyword">if</span> v == target:<br>    <span class="hljs-keyword">return</span> dist, path<br><span class="hljs-keyword">if</span> v <span class="hljs-keyword">in</span> seen:<br>    <span class="hljs-keyword">continue</span><br>seen.add(v)<br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> g.adj[v]:<br>    w = e.to<br>    <span class="hljs-keyword">if</span> dist_to[w] &gt; dist_to[v] + e.weight:<br>        dist_to[w] = dist_to[v] + e.weight<br>        edge_to[w] = v<br>        heappush(heap, (dist_to[w], w))<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python字典内部实现</title>
    <link href="/2019/05/04/pydict/"/>
    <url>/2019/05/04/pydict/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这一篇会比较长。和这个系列的文章一样，主要目标读者是自己，以及一些希望了解字典内部工作原理，并且已经在半路上的人。我会用Python代码翻译CPython的实现。考察对象包括3.6之前的普通字典，3.6之后的compact字典。重点放在字典的核心逻辑，会省略比如字典迭代、字典合并、缓冲池、查找时的变动检查等特性和细节。</p></blockquote><a id="more"></a><h1 id="新老字典大乱斗"><a href="#新老字典大乱斗" class="headerlink" title="新老字典大乱斗"></a>新老字典大乱斗</h1><h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h2><h3 id="字典应用场景"><a href="#字典应用场景" class="headerlink" title="字典应用场景"></a>字典应用场景</h3><p>参考源码中的这段<a href="https://github.com/python/cpython/blob/3.7/Objects/dictnotes.txt#L4">说明</a>，先捋一下字典的应用场景，对字典有个更全面的认识。对后面了解字典内存优化也有帮助</p><p>Python内部实现层面：</p><div class="hljs code-wrapper"><pre><code>1. 传递关键字参数。大小1-3，写少，读少2. 查找类方法。大小8-10，写少，读多3. 实例attribute，全局变量查找。大小不定，大概率4-10，频繁读写4. builtins。大小150左右，不写，频繁读。</code></pre></div><p>应用层面：</p><ol><li>动态映射。添加、删除、替换交替进行。比如服务发现中的注册、过期、更新</li><li>成员测试。创建时写入key一次，之后基本不变，频繁调用__contains__()</li><li>uniquification。主要工作发生在字典的创建过程中，对小范围的key反复读写，比如去重、Counter、反向索引</li></ol><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><p>关于hash表的考量，同样来自源码的<a href="https://github.com/python/cpython/blob/3.7/Objects/dictobject.c#L134">注释</a>，以下为个人意译</p><p>Python选择开放地址法而不是拉链法，因为拉链法要维护额外的连接，开销更大</p><blockquote><p>来自未来的说明 2020-12:<br>开放地址法能更好地利用CPU的缓存</p></blockquote><p>大多数hash方案都依赖于一个“好”的hash函数，能出色地模拟随机性，均匀地散布key。但Python并没有沿着这条路走，它最重要的hash函数，针对int类型的，显得非常平常，可预期：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">&gt;&gt;&gt;[<span class="hljs-built_in">hash</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure><p>实际上这并没有想象中那么坏。在特定环境下，比如，在一个大小为$2^i$的符号表中，key是连续整型，那么直接使用key的hash值(就是key)最后i个bit作为索引，真滴非常快，还没有冲突，比随机算一个可能引发冲突的索引更有效</p><p>但是另一方面，如果冲突确实发生了，想快速插入已经连被续填充的hash表，必须得有一个更精细的冲突解决策略。同时，使用低i位为索引这行为本身，也存在脆弱的极端情况，比如，考虑<code>[i &lt;&lt; 16 for i in range(20000)]</code>作为key，去填充$2^{15}$的hash表，那么取后15位就会出现index<strong>全为0</strong>的情况</p><p>但是对这种特殊情况的处理不能损害常规情况下的处理速度，所以我们还是用低i位bit作为key在表中的index，剩下的仰仗于冲突解决策略。如果通常第一次查找就能找到我们所期待的key(事实证明，这也确实是常规情况，因为会把装载率控制在2/3以下)，那么像这样，把第一次index计算整得快一点，收效会很大。</p><p>冲突解决方案的第一部分:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 第一次映射到index，直接使用较低的i位</span><br><span class="hljs-comment"># 因为是二次幂，等效于取余，这里为简便就这么写吧</span><br>j = hashvalue % <span class="hljs-number">2</span>**i <span class="hljs-comment"># j = hashvalue &amp; (2**i - 1)</span><br><span class="hljs-keyword">while</span> not_found(j):<br>    j = ((<span class="hljs-number">5</span>*j)+<span class="hljs-number">1</span>) % <span class="hljs-number">2</span>**i <span class="hljs-comment"># 然后就可以按照特定顺序遍历index</span><br></code></pre></div></td></tr></table></figure><p>对于$j\in[0,2^i)$，上式重复$2^i$次，会把$[0,2^i)$中每个数确切地再现一次。等于说，这是一个变相的遍历函数。比如对于容量为8的表，以0开头</p><p>0 -&gt; 1 -&gt; 6 -&gt; 7 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; 1 -&gt; 6 [重复]</p><p>这种方式遍历和线性遍历相比有什么好处呢？大概就是在现实生活中，这种顺序的数字序列远比连续数字序列出现的概率小。如果两个hash值在index5冲突，后一个会去找index2，而不是index6，这样接下更可能出现的hash为index6的key就不会冲突。</p><p>冲突解决方案的第二部分，就要在后续的每一步位置探测中都把hashvalue考虑进来。如果不考虑hashvalue，那么后i位相同的hashvalue所产生的探测序列都是一样的，这并不是一个高效的冲突解决方案。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">j = hashvalue % <span class="hljs-number">2</span>**i <span class="hljs-comment"># 第一次映射到index，直接使用较低的i位</span><br>perturb = hashvalue<br><span class="hljs-keyword">while</span> not_found(j):<br>    perturb &gt;&gt;= PERTURB_SHIFT<br>    j = ((<span class="hljs-number">5</span>*j) + <span class="hljs-number">1</span> + perturb) % <span class="hljs-number">2</span>**i <span class="hljs-comment"># 然后使用perturb提供的信息进行探测下一个位置</span><br></code></pre></div></td></tr></table></figure><p>探测依赖hashvalue所有bit位，因为通过+perturb，快速放大了那些不会影响初始位置的bit位之间的微小差异(毕竟只有后i位可以决定初始index嘛)。注意perturb是无符号数，所以最终会变为0，回归到第一部分的原始遍历函数，一定能找到一个空位。</p><p>如何选择PERTUR_SHIFT的值？这需要一定的权衡。小一点，那么hashvalue的高位bit将<strong>更多</strong>地参与到探测序列生成中来；大一点，也能使高位bit<strong>更快速</strong>地影响序列生成，这对之前讨论的极端情况是有利的。最后实验得出5能够最小化冲突，当然4、6也差不到哪里去</p><p>生成探测序列，<a href="http://code.activestate.com/recipes/578375/">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_probes</span>(<span class="hljs-params">hashvalue, mask</span>):</span><br>    <span class="hljs-string">&#x27;Same sequence of probes used in the current dictionary design&#x27;</span><br>    PERTURB_SHIFT = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">if</span> hashvalue &lt; <span class="hljs-number">0</span>:<br>        hashvalue = -hashvalue<br>    i = hashvalue &amp; mask <span class="hljs-comment">#取得第一次的index</span><br>    <span class="hljs-keyword">yield</span> i<br>    perturb = hashvalue<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <span class="hljs-comment">#循环开始</span><br>        i = (<span class="hljs-number">5</span> * i + perturb + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span><br>        <span class="hljs-keyword">yield</span> i &amp; mask<br>        perturb &gt;&gt;= PERTURB_SHIFT<br></code></pre></div></td></tr></table></figure><h2 id="1-Legacy-Dictionary"><a href="#1-Legacy-Dictionary" class="headerlink" title="1. Legacy Dictionary"></a>1. Legacy Dictionary</h2><p>这里先介绍3.6之前的字典，关键参考的是《Python源码剖析》。</p><h3 id="数据结构-amp-初始化"><a href="#数据结构-amp-初始化" class="headerlink" title="数据结构 &amp; 初始化"></a>数据结构 &amp; 初始化</h3><p>数据结构分为，1.储存键值的Entry；2.维护Entries的容器Dict</p><p>PyDictEntry</p><ul><li>me_hash</li><li>me_key</li><li>me_value</li></ul><p>PyDictObject</p><ul><li><p>ma_fill: 被使用过的entry数， Active+Dummy</p></li><li><p>ma_used: 正在被使用的entry数，Active</p></li><li><p>ma_mask: $2^n-1$，变相表达字典容量，减1为了方便与运算获得角标位置</p></li><li><p>ma_table：entries，储存key-value的entry集合</p></li><li><p>ma_lookup：查找方法，hash查找方法，针对key类型有优化</p></li><li><p>ma_smalltable: 字典的伴生entries，entry集合的容量为8，初始化时就申请了内存</p></li></ul><p>PyDict_New</p><ol><li>查看缓冲池，重用或者新建</li><li>新建: smalltable清零; ma_table指向ma_smalltable; ma_used = ma_fill = 0，ma_mask = 7，ma_lookup默认使用lookdict_string</li></ol><p><img src="https://s2.ax1x.com/2019/03/04/kOhJbj.png" alt="kOhJbj.png"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">DICT_MINISIZE = <span class="hljs-number">8</span><br>DUMMY = <span class="hljs-string">&quot;dummy&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyDictEntry</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.me_hash = <span class="hljs-literal">None</span><br>        self.me_key = <span class="hljs-literal">None</span><br>        self.me_value = <span class="hljs-literal">None</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.me_value:<br>            s = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.me_key&#125;</span>-<span class="hljs-subst">&#123;self.me_value&#125;</span>&quot;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;s:&lt;<span class="hljs-number">5</span>&#125;</span>&quot;</span><br>        <span class="hljs-keyword">elif</span> self.me_key:<br>            <span class="hljs-keyword">assert</span> self.me_key <span class="hljs-keyword">is</span> DUMMY<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DUMMY&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FREE &quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyDictObject</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 这里忽略了缓冲池，可以使用__new__来模拟</span><br>        self.ma_fill = <span class="hljs-number">0</span><br>        self.ma_used = <span class="hljs-number">0</span><br>        self.ma_mask = DICT_MINISIZE - <span class="hljs-number">1</span><br>        self.ma_smalltable = [PyDictEntry() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(DICT_MINISIZE)]<br>        self.ma_table = self.ma_smalltable<br>        self.lookup = dict_lookup<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> PyDict_GetItem(self, key)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        PyDict_SetItem(self, key ,value)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delitem__</span>(<span class="hljs-params">self, key</span>):</span><br>        PyDict_DelItem(self, key)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">repr</span>(self.ma_table)<br>    <br><span class="hljs-comment"># PyDict_SetItem(dc, key, value)在容量伸缩部分补齐</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PyDict_GetItem</span>(<span class="hljs-params">dc, key</span>):</span><br>    hashvalue = <span class="hljs-built_in">hash</span>(key)<br>    ep = dc.lookup(dc, key, hashvalue)<br>    <span class="hljs-keyword">if</span> ep.me_value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> KeyError(key)<br>    <span class="hljs-keyword">return</span> ep.me_value<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PyDict_DelItem</span>(<span class="hljs-params">dc, key</span>):</span><br>    dict_del(dc, key, <span class="hljs-built_in">hash</span>(key))<br></code></pre></div></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>字典默认的是lookdict_string查找函数，这是一种针对key为string类型的字典做的优化。更通用的是lookdict版本，在key不是string的情况下工作。这里直接先看基础版本</p><p>沿着冲突链，寻找两种中止：1. 未使用的entry；2.key匹配的entry。期间如果遇到了dummy entry，设置freeslot，在返回未使用的entry时，优先返回freeslot代表的dummy entry，方便重用entry。所以两种中止条件，共三种返回状态，1、空entry (key=value=NULL)，2、dummy entry (key=DUMMY,value=NULL)，3、active entry (key\value均不为NULL）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">DUMMY = <span class="hljs-string">&quot;dummy&quot;</span><br>        <br><span class="hljs-comment"># lookdict重命名为dict_lookup</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_lookup</span>(<span class="hljs-params">dc, key, hashvalue</span>):</span><br>    freeslot = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen_probes(hashvalue, dc.ma_mask):<br>        entry = dc.ma_table[i]<br>        <span class="hljs-comment"># unused 直接返回</span><br>        <span class="hljs-keyword">if</span> entry.me_key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> entry <span class="hljs-keyword">if</span> freeslot <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> freeslot<br>        <span class="hljs-comment"># 冲突链上遇到的第一个墓碑，直接记下来，去下一个位置</span><br>        <span class="hljs-keyword">if</span> entry.me_key <span class="hljs-keyword">is</span> DUMMY:<br>            freeslot = entry<br>        <span class="hljs-comment"># 冲突链上有个好端端的key，所以检查一哈是不是我们想要的</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> (entry.me_key <span class="hljs-keyword">is</span> key <span class="hljs-keyword">or</span>  <span class="hljs-comment"># 引用相同</span><br>                entry.me_hash == hashvalue <span class="hljs-keyword">and</span>  <span class="hljs-comment"># 检查hash</span><br>                    entry.me_key == key):  <span class="hljs-comment"># 最后检查*最耗时*的相等检查</span><br>                <span class="hljs-keyword">return</span> entry<br></code></pre></div></td></tr></table></figure><p>再说回lookdict_string的优化问题。查找里的性能瓶颈就是在检查key是否是目标key。本来可以直接使用<code>entry.key == key</code>来判断，但是不同的类型的比较操作性能差别很大，能避免就避免，于是先比较引用、hash。而lookdict_string的优化就是直接是由字符串的比较，省得还去找类型的比较函数</p><h3 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h3><p>插入的想法是，先查找，三种返回状态，Active替换value，Dummy、空都要填充所用entry字段，并增加ma_used，注意空entry需要额外增加ma_fill</p><p>删除的想法是，先查找，三种返回状态，Active和变为Dummy，ma_used减少，空和Dummy就抛出KeyError</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_insert</span>(<span class="hljs-params">dc, key, hashvalue, value</span>):</span><br>    entry = dc.lookup(dc, key, hashvalue)<br>    <span class="hljs-comment"># 正在使用的entry</span><br>    <span class="hljs-keyword">if</span> entry.me_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        entry.me_value = value<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> entry.me_key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 未被使用的entry</span><br>            dc.ma_fill += <span class="hljs-number">1</span><br>        entry.me_hash = hashvalue<br>        entry.me_key = key<br>        entry.me_value = value<br>        dc.ma_used += <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_del</span>(<span class="hljs-params">dc, key, hashvalue</span>):</span><br>    entry = dc.lookup(dc, key, hashvalue)<br>    <span class="hljs-keyword">if</span> entry.me_value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 空或者dummy，dummy出现在重复删除时</span><br>        <span class="hljs-keyword">raise</span> KeyError(key)<br>    <span class="hljs-keyword">else</span>:<br>        entry.me_key = DUMMY<br>        entry.me_hash = <span class="hljs-literal">None</span><br>        entry.me_value = <span class="hljs-literal">None</span><br>        dc.ma_used -= <span class="hljs-number">1</span> <br></code></pre></div></td></tr></table></figure><h3 id="容量伸缩"><a href="#容量伸缩" class="headerlink" title="容量伸缩"></a>容量伸缩</h3><p>字典的大小(ma_mask+1)必须为二次幂，而为了保证hash表的效率，使用过的entry应当是总体容量的2/3。也就是，当ma_fill超过(ma_size+1)的2/3，字典容量需要进行一次调整，调整的依据称为增长率</p><p>Python各版本的增长率如下表</p><table><thead><tr><th>版本</th><th>growth rate</th></tr></thead><tbody><tr><td>2.x ~ 3.2</td><td>active*4</td></tr><tr><td>3.3</td><td>active*2</td></tr><tr><td>3.4~3.6</td><td>active*2+capacity/2</td></tr><tr><td>3.7</td><td>active*3</td></tr></tbody></table><blockquote><p> 具体在2.x中还有一个考虑内存的经验判断，这里不妨忽略掉：</p><p> <code>growth_rate = ma_used * (2 if ma_used &gt; 50000 else 4)</code></p></blockquote><p>字典容量capacity，则是大于growth_rate的最小二次幂。</p><p>根据这些信息，我们可以做出下面这个图</p><p><img src="https://s2.ax1x.com/2019/03/05/kXt5ad.png" alt="kXt5ad.png"></p><p>所以在3.2之前，有可能存在4倍扩容，而3.2之后，最大也就两倍扩容了。</p><p>注意中间3.4~3.6的那个奇怪的增长率，实际上是个<a href="https://bugs.python.org/issue33205">bug</a>，它阻止字典容量变小。</p><p>什么时候检查这个临界点呢？插入数据的时候。如果确实插入了一个新的Active，并且满足容量边界触发条件，则开始resize。所以，<strong>删除字典entry的时候容量并不改变</strong>。</p><p>resize的想法是，按照新的容量，新申请table，复位字典的字段，然后把原有的active放到新table中。当然还要考虑到smalltable的重用</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PyDict_SetItem</span>(<span class="hljs-params">dc, key, value</span>):</span><br>    hashvalue = <span class="hljs-built_in">hash</span>(key)<br>    n_used = dc.ma_used<br>    dict_insert(dc, key, hashvalue, value)<br>    <span class="hljs-keyword">if</span> dc.ma_used &gt; n_used <span class="hljs-keyword">and</span> dc.ma_fill*<span class="hljs-number">3</span> &gt;= (dc.ma_mask+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>:<br>        growth_rate = dc.ma_used * (<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> dc.ma_used &lt; <span class="hljs-number">50000</span> <span class="hljs-keyword">else</span> <span class="hljs-number">4</span>)<br>        dict_resize(dc, growth_rate)<br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_resize</span>(<span class="hljs-params">dc, size</span>):</span><br>    <span class="hljs-comment"># ma_mask+1必须为二次幂</span><br>    print(<span class="hljs-string">&#x27;----resize-----&#x27;</span>)<br>    size = <span class="hljs-built_in">max</span>(DICT_MINISIZE, <span class="hljs-number">2</span> ** size.bit_length())<br>    old_table = dc.ma_table<br>    is_old_table_malloced = old_table <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> dc.ma_smalltable<br>    <span class="hljs-comment"># 容量减小，应该使用smalltable</span><br>    <span class="hljs-keyword">if</span> size == DICT_MINISIZE:<br>        new_table = dc.ma_smalltable<br>        <span class="hljs-comment"># 本来就是smalltable，还要resize，两种情况</span><br>        <span class="hljs-keyword">if</span> new_table <span class="hljs-keyword">is</span> old_table:<br>            <span class="hljs-comment"># 1.被内部代码强制resize了，什么都不做</span><br>            <span class="hljs-keyword">if</span> dc.ma_fill == dc.ma_used:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 2.存在删除操作</span><br>            <span class="hljs-comment"># 插入5个值，fill=used=5，删除，fill=5，used=0</span><br>            <span class="hljs-comment"># 再插入一个，fill=6, used=1, 触发resize，目的仅仅时删除dummy entry</span><br>            <span class="hljs-keyword">assert</span> dc.ma_fill &gt; dc.ma_used<br>            small_copy = deepcopy(old_table)<br>            old_table = small_copy  <span class="hljs-comment"># 此时new_table和old_table不再是同一个identity</span><br>    <span class="hljs-keyword">else</span>:<br>        new_table = [PyDictEntry() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br><br>    <span class="hljs-comment"># 初始化新字典</span><br>    <span class="hljs-keyword">assert</span> new_table <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> old_table<br>    dc.ma_table = new_table<br>    dc.ma_mask = size - <span class="hljs-number">1</span><br>    dc.ma_used = <span class="hljs-number">0</span><br>    dc.ma_fill = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> new_table:<br>        entry.me_hash = entry.me_key = entry.me_value = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> old_table:<br>        <span class="hljs-keyword">if</span> entry.me_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            dict_insert(dc, entry.me_key, entry.me_hash, entry.me_value)<br>        <span class="hljs-comment"># 剩下要么是未使用，要么是dummy</span><br>        <span class="hljs-keyword">elif</span> entry.me_key <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">assert</span> entry.me_key <span class="hljs-keyword">is</span> DUMMY<br><br>    <span class="hljs-keyword">if</span> is_old_table_malloced:<br>        <span class="hljs-keyword">del</span> old_table  <br></code></pre></div></td></tr></table></figure><h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    d = PyDictObject()<br>    op_map = <span class="hljs-built_in">dict</span>(S=<span class="hljs-string">&#x27;__setitem__&#x27;</span>, G=<span class="hljs-string">&#x27;__getitem__&#x27;</span>, D=<span class="hljs-string">&#x27;__delitem__&#x27;</span>)<br>    operations = [<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],   <span class="hljs-comment">#DUMMY</span><br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">11</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">1</span>]],   <br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">2</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">3</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">14</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">4</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">15</span>]], <span class="hljs-comment"># fill到6，触发smalltable的resize</span><br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">14</span>]],  <span class="hljs-comment"># 插入成功后触发resize</span><br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">16</span>]],  <br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">16</span>, <span class="hljs-number">116</span>]], <span class="hljs-comment"># 0,1,6,15  0为DUMMY，1、6Active，15FREE，占用0DUMMY位</span><br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]], <span class="hljs-comment"># 0,1,6,15  占15FREE位</span><br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">17</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">7</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">6</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">5</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">4</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">3</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">2</span>]],<br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">1</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">18</span>]],<br>        [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">19</span>]], <span class="hljs-comment"># 触发容量变小的resize</span><br>        [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">999</span>]] <span class="hljs-comment"># let&#x27;s end up with error</span><br>    ]<br><br>    <span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> operations:<br>        opt, opd = op<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">getattr</span>(d, op_map[opt])(*opd)<br>        <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-built_in">repr</span>(e), e)<br>        <span class="hljs-keyword">if</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>):<br>            print(d, d.ma_used, d.ma_fill)<br></code></pre></div></td></tr></table></figure><h2 id="中场休息·讨论"><a href="#中场休息·讨论" class="headerlink" title="中场休息·讨论"></a>中场休息·讨论</h2><ul><li><p>插入序</p><p>插入的(key，value)具体在ma_table中的哪一个位置，是hashvalue决定的，和插入的顺序无关。当迭代字典时，自然无法按照插入顺序返回entry</p></li><li><p>共享key</p><p>在最开始提到字典在Python中的一个典型应用，实例的attribute。大多数情况下，面向对象模式会在__init__里设置好实例字典里的key，而且之后较多更新而少增删。因此可以考虑在同一类型的实例中共享key，不同的实例维护不同的values就好。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># legacy dictionary里是这样存的</span><br><br><span class="hljs-comment"># colors instance</span><br>ma_table = [[<span class="hljs-number">3086305163739458776</span>, <span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]，<br>    [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],           <br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-number">6038797773365358412</span>, <span class="hljs-string">&#x27;barry&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-number">8949987314752724126</span>, <span class="hljs-string">&#x27;timmy&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>]]<br><br><span class="hljs-comment"># fruits instance</span><br>ma_table = [[<span class="hljs-number">3086305163739458776</span>, <span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>]，<br>    [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],           <br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-number">6038797773365358412</span>, <span class="hljs-string">&#x27;barry&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>            [<span class="hljs-number">8949987314752724126</span>, <span class="hljs-string">&#x27;timmy&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]]<br><br><span class="hljs-comment"># 共享keys的大小依然是二次幂，values的大小就可以是2/3</span><br>cached_keys = [<span class="hljs-number">2</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>]<br><span class="hljs-comment"># colors instance</span><br>values = [[<span class="hljs-number">8949987314752724126</span>, <span class="hljs-string">&#x27;timmy&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>],<br>          [<span class="hljs-number">6038797773365358412</span>, <span class="hljs-string">&#x27;barry&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>],<br>          [<span class="hljs-number">3086305163739458776</span>, <span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>],<br>          [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>          [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>]]<br><br><span class="hljs-comment"># fruits instance</span><br>values = [[<span class="hljs-number">8949987314752724126</span>, <span class="hljs-string">&#x27;timmy&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>],<br>          [<span class="hljs-number">6038797773365358412</span>, <span class="hljs-string">&#x27;barry&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>],<br>          [<span class="hljs-number">3086305163739458776</span>, <span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>],<br>          [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>          [<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>]]<br></code></pre></div></td></tr></table></figure><p>可以看到，将key和value分离，不仅在特定的场景下节约了内存，还保留了插入顺序。因为在单独的cached_keys中插入，角标递增，values天然满足插入序。沿着这个想法，对于那些普通的非实例字典，也可以采用key、value分离的思路来保证插入序，尽管节约内存空间这个目标可能无法实现了，因为这些字典并不共享key。</p></li></ul><p>接下来，就看看Python3.7中，具体是怎样分离key和value</p><h2 id="2-Compact-Dictionary"><a href="#2-Compact-Dictionary" class="headerlink" title="2. Compact Dictionary"></a>2. Compact Dictionary</h2><p>基于3.7实现。建议读3.7的源码，修了3.6的bug，而且整体流程也更加简洁。</p><h3 id="Combined-or-Splited"><a href="#Combined-or-Splited" class="headerlink" title="Combined or Splited"></a>Combined or Splited</h3><p>中场讨论知道，key-value分离有两种典型的应用场景，由此分为combined(不共享key)和splited(共享key)两种字典。这俩数据结构是同一套，只是在个别字段上存在区别。</p><p>然后把两种的区别总结如下：</p><table><thead><tr><th></th><th>combined-table</th><th>splited-table</th></tr></thead><tbody><tr><td>ma_values</td><td>NULL</td><td>不为NULL</td></tr><tr><td>dk_refcnt</td><td>=1</td><td>&gt;=1，&gt;1时表明key正在被多个实例共享</td></tr><tr><td>场景</td><td>普通显式字典</td><td>实例字典，容量为8，key为string类型</td></tr></tbody></table><p>关于Compact Dict的几个关键信息，参考<a href="https://www.python.org/dev/peps/pep-0412/">PEP412</a>，<a href="https://bugs.python.org/issue28040">issue28040</a></p><ol><li>由dict()或{}语法创建的显式字典，一开始就是combined，永远不会转换为split。</li><li>当创建实例的__dict__字典时，会采用split-table，缓存到该类型里，可以让多个实例共享同样的key。当字典开始出现独立的变化，比如增加一个以数字为key的entry，或者破坏插入序(见第4点)，就会退化为combined-table </li><li>由于split-table的存在，诞生了一种新的Pending的状态</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 1. Unused. 也被称为FREE、EMPTY </span><br><br><span class="hljs-comment"># 2. Active.  index &gt;= 0, me_key != NULL and value != NULL </span><br><span class="hljs-comment">#    注意这个value可能是dk_entries[index].me_value, 可能是ma_values[index]</span><br><br><span class="hljs-comment"># 3. Dummy.  index == DKIX_DUMMY  (combined only)</span><br>   <br><span class="hljs-comment"># 4. Pending. index &gt;= 0, key != NULL, and ma_values[index] == NULL  (split only)</span><br><span class="hljs-comment">#   Not yet inserted in split-table. </span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br>a, b = C(), C() <span class="hljs-comment"># a、b共享keys</span><br>a.attr1, a.attr2 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-comment"># 现在b就有两个Pending状态的slot，attr1和attr2</span><br>b.attr1 = <span class="hljs-number">11</span>, b.attr2 = <span class="hljs-number">12</span>  <span class="hljs-comment"># b填充pending状态，依然共享key</span><br><span class="hljs-comment"># 但是如果先b.attr2=12，b.attr1 = 12, 11就会破坏插入序，b的字典转换为combine。</span><br><span class="hljs-comment"># 或者b.attr3=13也会造成字典转换为combine</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li><p>resize时，splited也会转变为combined。有一个例外：如下C类的实例字典，初始化时有6个值，会触发resize，但是因为仅一个实例(利用dk_refcnt判断)，会立马转换为splited</p><blockquote><p>PyDict_SetItem() may call dictresize and convert split table into combined table. In such case, convert it to split table again and update type’s shared key only when this is <strong>the only dict</strong> sharing key with the type.<br>This is to allow using shared key in class like this:    </p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span>(<span class="hljs-params">self</span>):</span><br>  <span class="hljs-comment"># one dict resize happens</span><br>  self.a, self.b, self.c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>  self.d, self.e, self.f = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span><br>a = C()<br></code></pre></div></td></tr></table></figure></blockquote></li></ol><h3 id="数据结构-amp-初始化-1"><a href="#数据结构-amp-初始化-1" class="headerlink" title="数据结构 &amp; 初始化"></a>数据结构 &amp; 初始化</h3><p><img src="https://s2.ax1x.com/2019/03/06/kjOeCF.png" alt="kjOeCF.png"></p><p>两个字典用的都基于相同数据结构，只是对各字段的使用有区别，如上图</p><p>PyDictKeyEntry</p><ul><li>me_hash</li><li>me_key</li><li>me_value</li></ul><p>这就是原来的PyDictEntry，名字中加Key，因为这里的entry被安置到下面要提及的Keys对象中</p><p>PyDictKeysObject</p><ul><li>dk_refcnt：当前Keys对象有多少个引用</li><li>dk_size：字典容量，二次幂，等效原来的(ma_mask+1)。现在mask用宏计算。</li><li>dk_lookup：查找函数，方便优化</li><li>dk_usable: 初始化为dk_size的2/3，减到0时就resize字典</li><li>dk_nentries: 等效原来的ma_fill，包含active和dummy</li><li>dk_indices: 索引数组，大小同dk_size</li><li>dk_entries: 这是紧随的一片地址，大小同dk_usable，安置entry，在C实现中没有直接指针，通过宏从dk_indices计算起始位置。split字典中每个entry的value都为NULL，因为它有专门的放置位置</li></ul><p>PyDictObject</p><ul><li>ma_used：正在使用entry，active</li><li>ma_version_tag：每次修改字典会打新tag，和细节优化有关，这里不管啦</li><li>ma_keys：PyDictKeysObject对象</li><li>ma_values: split字典的value存在这里，split字典时申请dk_usable大小的空间</li></ul><p>新版本里没有smalltable了，因为smalltable不支持splited-table形式，在combined-table中等效于dk_entries</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count<br><br>DICT_MINISIZE = <span class="hljs-number">8</span><br>FREE = -<span class="hljs-number">1</span><br>DUMMY = -<span class="hljs-number">2</span><br>DICT_NEXT_VERSION = count().__next__<br>SHARED_KEYS = <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">growth_rate</span>(<span class="hljs-params">dc</span>):</span><br>    <span class="hljs-keyword">return</span> dc.ma_used * <span class="hljs-number">3</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dk_entries_at</span>(<span class="hljs-params">dc, ix</span>):</span><br>    <span class="hljs-keyword">return</span> dc.ma_keys.dk_entries[ix]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_is_splited_table</span>(<span class="hljs-params">dc</span>):</span><br>    <span class="hljs-keyword">return</span> dc.ma_values <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyDictKeyEntry</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.me_hash = <span class="hljs-literal">None</span><br>        self.me_key = <span class="hljs-literal">None</span><br>        self.me_value = <span class="hljs-literal">None</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.me_key <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> self.me_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                s = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.me_key&#125;</span>-<span class="hljs-subst">&#123;self.me_value&#125;</span>&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                s = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.me_key&#125;</span>-*&quot;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;s:&lt;<span class="hljs-number">5</span>&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;#    &quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyDictKeysObject</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, size</span>):</span><br>        self.dk_refcnt = <span class="hljs-number">1</span><br>        self.dk_size = size<br>        self.dk_lookup = dict_lookup<br>        self.dk_usable = (self.dk_size &lt;&lt; <span class="hljs-number">1</span>) // <span class="hljs-number">3</span><br>        self.dk_nentries = <span class="hljs-number">0</span><br>        self.dk_indices = [FREE]*self.dk_size<br>        self.dk_entries = [PyDictKeyEntry() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.dk_usable)]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inv_match</span>(<span class="hljs-params">ix</span>):</span><br>            <span class="hljs-keyword">if</span> ix == -<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;FREE &#x27;</span><br>            <span class="hljs-keyword">elif</span> ix == -<span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DUMMY&#x27;</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;ix:&lt;<span class="hljs-number">5</span>&#125;</span>&quot;</span><br>        visual_indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(inv_match, self.dk_indices))<br>        str_indices = <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;<span class="hljs-string">&#x27;, &#x27;</span>.join(visual_indices)&#125;</span>]&quot;</span><br>        <span class="hljs-keyword">return</span> str_indices+<span class="hljs-string">&quot;\n&quot;</span>+<span class="hljs-built_in">repr</span>(self.dk_entries)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyDictObject</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, keys, values</span>):</span><br>        self.ma_used = <span class="hljs-number">0</span><br>        self.ma_version_tage = DICT_NEXT_VERSION()<br>        self.ma_keys = keys<br>        self.ma_values = values<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, key</span>):</span><br>        ix, _ = self.ma_keys.dk_lookup(self, key, <span class="hljs-built_in">hash</span>(key))<br>        <span class="hljs-keyword">if</span> ix &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-keyword">if</span> _is_splited_table(self):<br>            <span class="hljs-keyword">return</span> self.ma_values[ix]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> self.ma_keys.dk_entries[ix].me_value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        dict_insert(self, key, <span class="hljs-built_in">hash</span>(key), value) <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delitem__</span>(<span class="hljs-params">self, key</span>):</span><br>        dict_del(self, key, <span class="hljs-built_in">hash</span>(key))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> _is_splited_table(self):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">repr</span>(self.ma_keys)&#125;</span> <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>(self.ma_keys)&#125;</span>\n<span class="hljs-subst">&#123;self.ma_values&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">repr</span>(self.ma_keys)<br>        <br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_factory</span>(<span class="hljs-params">kind</span>):</span><br>    <span class="hljs-keyword">if</span> kind == <span class="hljs-string">&#x27;combine&#x27;</span>:<br>        <span class="hljs-keyword">return</span> PyDictObject(PyDictKeysObject(DICT_MINISIZE), <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">elif</span> kind == <span class="hljs-string">&#x27;split&#x27;</span>:<br>        <span class="hljs-keyword">global</span> SHARED_KEYS<br>        <span class="hljs-keyword">if</span> SHARED_KEYS <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            SHARED_KEYS = PyDictKeysObject(DICT_MINISIZE)<br>        <span class="hljs-keyword">else</span>:<br>            SHARED_KEYS.dk_refcnt += <span class="hljs-number">1</span><br>        values = [<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(SHARED_KEYS.dk_usable)]<br>        <span class="hljs-keyword">return</span> PyDictObject(SHARED_KEYS, values)<br></code></pre></div></td></tr></table></figure><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>这里查找的对象是dk_keys，一个数组，记录entry索引的那个，gen_probes没有变化</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_lookup</span>(<span class="hljs-params">dc, key, hashvalue</span>):</span><br>    <span class="hljs-comment"># 因为分离的key和value，lookup返回实际上需要返回ix和pos</span><br>    <span class="hljs-comment"># ix是entry在dk_entries中的索引，pos是ix在dk_indices中的索引</span><br>    <span class="hljs-comment"># 3.6版本有freeslot，把pos由指针传出去</span><br>    <span class="hljs-comment"># 3.7版本没有freeslot，在需要的时候重新使用probe去获取pos</span><br>    <span class="hljs-comment"># 这里我们直接用python的tuple返回(ix, pos)</span><br>    <span class="hljs-comment"># 所以实际上还是返回了三种状态，free，dummy，匹配</span><br>    freeslot = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen_probes(hashvalue, dc.ma_keys.dk_size-<span class="hljs-number">1</span>):<br>        ix = dc.ma_keys.dk_indices[i]<br>        <span class="hljs-keyword">assert</span> ix &gt;= DUMMY<br>        <span class="hljs-comment"># unused 直接返回</span><br>        <span class="hljs-keyword">if</span> ix == FREE:<br>            <span class="hljs-keyword">return</span> (ix, i) <span class="hljs-keyword">if</span> freeslot <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> (DUMMY, freeslot)<br>        <span class="hljs-keyword">if</span> ix == DUMMY:<br>            freeslot = i<br>        <span class="hljs-comment"># ix &gt;= 0，所以检查一哈是不是我们想要的</span><br>        <span class="hljs-keyword">else</span>:<br>            entry = dk_entries_at(dc, ix)<br>            <span class="hljs-keyword">assert</span> entry.me_key <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> (entry.me_key <span class="hljs-keyword">is</span> key <span class="hljs-keyword">or</span>  <span class="hljs-comment"># 引用相同</span><br>                entry.me_hash == hashvalue <span class="hljs-keyword">and</span>  <span class="hljs-comment"># 检查hash</span><br>                    entry.me_key == key):  <span class="hljs-comment"># 最后检查*最耗时*的相等检查</span><br>                <span class="hljs-keyword">return</span> (ix, i)<br>        <span class="hljs-comment"># key不对应，找下一个</span><br></code></pre></div></td></tr></table></figure><h3 id="插入与删除-1"><a href="#插入与删除-1" class="headerlink" title="插入与删除"></a>插入与删除</h3><p>这里把resize的逻辑放到了insert里面。</p><p>至于删除，主要要到把splited转变为combined再设置dummy的操作</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_insert</span>(<span class="hljs-params">dc, key, hashvalue, value</span>):</span><br>    ix, pos = dc.ma_keys.dk_lookup(dc, key, hashvalue)<br><br>    <span class="hljs-keyword">if</span> _is_splited_table(dc):<br>        <span class="hljs-comment"># 如果插入的顺序不同，停止共享</span><br>        <span class="hljs-comment"># 第一种情况，插入已存在的key(Pending态)，但是不是按照最开始的插入序</span><br>        <span class="hljs-comment"># 第二种情况，插入了新的key-value</span><br>        <span class="hljs-keyword">if</span> (ix &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dc.ma_values[ix] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> dc.ma_used != ix<br>              <span class="hljs-keyword">or</span> ix == FREE <span class="hljs-keyword">and</span> dc.ma_used != dc.ma_keys.dk_nentries):<br>            print(<span class="hljs-string">&quot;--back to combine--&quot;</span>)<br>            dict_resize(dc, growth_rate(dc))<br><br>    <span class="hljs-comment"># 正在使用的entry</span><br>    <span class="hljs-keyword">if</span> ix &gt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> _is_splited_table(dc):<br>            <span class="hljs-keyword">if</span> dc.ma_values[ix] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># pending状态</span><br>                <span class="hljs-keyword">assert</span> ix == dc.ma_used<br>                dc.ma_used += <span class="hljs-number">1</span><br>            dc.ma_values[ix] = value<br>        <span class="hljs-keyword">else</span>:<br>            entry = dk_entries_at(dc, ix)<br>            <span class="hljs-keyword">assert</span> entry.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>            entry.me_value = value<br>        dc.ma_version_tage = DICT_NEXT_VERSION()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># DUMMY或者FREE, 一定会增加一个key，value都是新鲜的active态，</span><br>        <span class="hljs-comment"># 等效于原来的ma_used+1检查</span><br>        <span class="hljs-comment"># 所以要检查一下字典大小，看是否resize</span><br>        <span class="hljs-comment"># </span><br>        <span class="hljs-keyword">if</span> dc.ma_keys.dk_usable &lt;= <span class="hljs-number">0</span>:<br>            dict_resize(dc, growth_rate(dc))<br>            <span class="hljs-comment"># 这句话C实现里没有，因为pos是按序去查找的</span><br>            ix, pos = dc.ma_keys.dk_lookup(dc, key, hashvalue)        <br>        <br>        <span class="hljs-comment"># 在没有保证插入序的时候，这里会检查是否为FREE，是，ma_fill才会+1，</span><br>        <span class="hljs-comment"># 这样就悄无声息地重用了被删除entry在ma_table中的位置</span><br>        <span class="hljs-comment"># 但是因为保证插入序，不能重用删除的entry在dk_entries中的位置</span><br>        <span class="hljs-comment"># ma_fill对标的dk_nentries无论FREE/DUMMY都会+1</span><br>        <span class="hljs-comment"># 重用的只能是删除key在dk_indices中的位置</span><br>        true_ix = dc.ma_keys.dk_nentries<br>        dc.ma_keys.dk_indices[pos] = true_ix <br>        <span class="hljs-comment"># 要插入的entry在dk_nentries处</span><br>        entry = dk_entries_at(dc, true_ix)<br><br>        entry.me_hash = hashvalue<br>        entry.me_key = key<br>        <span class="hljs-keyword">if</span> _is_splited_table(dc):<br>            <span class="hljs-keyword">assert</span> dc.ma_values[true_ix] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>            dc.ma_values[true_ix] = value<br>        <span class="hljs-keyword">else</span>:<br>            entry.me_value = value<br>        dc.ma_used += <span class="hljs-number">1</span><br>        dc.ma_version_tage = DICT_NEXT_VERSION()<br>        dc.ma_keys.dk_usable -= <span class="hljs-number">1</span><br>        dc.ma_keys.dk_nentries += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">assert</span> dc.ma_keys.dk_usable &gt;= <span class="hljs-number">0</span><br>        <br>        <br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_del</span>(<span class="hljs-params">dc, key, hashvalue</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;只有combine支持删除，split也要先转换</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ix, pos = dc.ma_keys.dk_lookup(dc, key, hashvalue)<br>    <span class="hljs-keyword">if</span> ix == FREE <span class="hljs-keyword">or</span> ix == DUMMY:<br>        <span class="hljs-keyword">raise</span> KeyError(key)<br>    <span class="hljs-keyword">if</span> _is_splited_table(dc):<br>        <span class="hljs-keyword">if</span> dc.ma_values[ix] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment">#pending状态</span><br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-comment"># resize一个相等大小的keys，-1因为使用了bit_length()</span><br>        print(<span class="hljs-string">&quot;----back to combine----&quot;</span>)<br>        dict_resize(dc, dc.ma_keys.dk_size-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 因为pending的存在，resize重建indices可能造成ix, pos的变动</span><br>        ix, pos = dc.ma_keys.dk_lookup(dc, key, hashvalue)<br>        <span class="hljs-keyword">assert</span> ix &gt;= <span class="hljs-number">0</span> <span class="hljs-comment"># 一定能找到</span><br>    <br>    dc.ma_used -= <span class="hljs-number">1</span><br>    dc.ma_version_tage = DICT_NEXT_VERSION()<br>    dc.ma_keys.dk_indices[pos] = DUMMY<br>    entry = dk_entries_at(dc, ix)<br>    entry.me_key = <span class="hljs-literal">None</span><br>    entry.me_value = <span class="hljs-literal">None</span><br></code></pre></div></td></tr></table></figure><h3 id="容量伸缩-1"><a href="#容量伸缩-1" class="headerlink" title="容量伸缩"></a>容量伸缩</h3><p>不论split还是combine，resize的关键点要把握住，ma_used是连接前后的关键值。resize完成后，nentries和ma_used相等。流程先分类别处理两种字典的value，保证ma_used个值被转移到新字典里，然后再重建dk_indices</p><p>关于增长率，在之前讨论过。3.7改成了<code>active*3</code>，最多容量扩大一倍</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict_resize</span>(<span class="hljs-params">dc, size</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    会把splited-table转变为combined-table，可以通过make_keys_shared转变回来</span><br><span class="hljs-string">    这就是在超过5个attr的实例字典初始化中要做的事情</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    print(<span class="hljs-string">&#x27;----resize-----&#x27;</span>)<br>    size = <span class="hljs-built_in">max</span>(DICT_MINISIZE, <span class="hljs-number">2</span> ** size.bit_length())<br>    old_keys = dc.ma_keys<br>    old_entries = old_keys.dk_entries<br>    <br>    dc.ma_keys = PyDictKeysObject(size)<br>    <span class="hljs-keyword">assert</span> dc.ma_keys.dk_usable &gt;= dc.ma_used<br><br>    <span class="hljs-keyword">if</span> _is_splited_table(dc):<br>        <span class="hljs-comment"># 转变为combine字典，把ma_values转移到dk_entries中</span><br>        <span class="hljs-comment"># split字典的ma_values一定密集，ma_used个值</span><br>        <span class="hljs-comment"># 小于等于dk_entries的个数，等于发生在没有pending时     </span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(dc.ma_used):<br>            <span class="hljs-keyword">assert</span> dc.ma_values[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>            old_entry = old_entries[i]<br>            new_entry = dk_entries_at(dc, i)<br>            new_entry.me_key = old_entry.me_key<br>            new_entry.me_hash = old_entry.me_hash<br>            new_entry.me_value = dc.ma_values[i]<br>        <span class="hljs-comment"># KeysObject可能被其他实例对象引用，不能释放，仅释放ma_values</span><br>        <span class="hljs-keyword">del</span> dc.ma_values<br>        dc.ma_values = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 总共需要向新的dk_entries塞入ma_used个值</span><br>        <span class="hljs-comment"># 不存在DUMMY，完全复制</span><br>        <span class="hljs-keyword">if</span> old_keys.dk_nentries == dc.ma_used:<br>            dc.ma_keys.dk_entries[:dc.ma_used] = old_entries[:dc.ma_used]<br>        <span class="hljs-comment"># 否则找出合格的ma_used个</span><br>        <span class="hljs-keyword">else</span>:<br>            active_entry = [<br>                entry <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> old_entries <span class="hljs-keyword">if</span> entry.me_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(active_entry) == dc.ma_used<br>            dc.ma_keys.dk_entries[:dc.ma_used] = active_entry<br>        <span class="hljs-comment"># 因为是combine的字典，KeysObject不会被其他引用，所以需要释放掉</span><br>        <span class="hljs-keyword">assert</span> old_keys.dk_refcnt == <span class="hljs-number">1</span><br>        <span class="hljs-keyword">del</span> old_entries<br>        <span class="hljs-keyword">del</span> old_keys<br><br>    <span class="hljs-comment"># 处理完entries和values，然后是根据密集的dk_entries重建dk_indices</span><br>    mask = size - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> ix, entry <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dc.ma_keys.dk_entries[:dc.ma_used]):<br>        <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> gen_probes(entry.me_hash, mask):<br>            <span class="hljs-keyword">if</span> dc.ma_keys.dk_indices[pos] == FREE: <span class="hljs-comment"># 不可能出现DUMMY</span><br>                dc.ma_keys.dk_indices[pos] = ix<br>                <span class="hljs-keyword">break</span><br>    dc.ma_keys.dk_usable -= dc.ma_used<br>    dc.ma_keys.dk_nentries = dc.ma_used<br></code></pre></div></td></tr></table></figure><h3 id="小测试-1"><a href="#小测试-1" class="headerlink" title="小测试"></a>小测试</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_tests</span>(<span class="hljs-params">d, operations</span>):</span><br>    op_map = <span class="hljs-built_in">dict</span>(S=<span class="hljs-string">&#x27;__setitem__&#x27;</span>, G=<span class="hljs-string">&#x27;__getitem__&#x27;</span>, D=<span class="hljs-string">&#x27;__delitem__&#x27;</span>)<br>    <span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> operations:<br>        opt, opd = op<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">getattr</span>(d, op_map[opt])(*opd)<br>        <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-built_in">repr</span>(e), e)<br>        <span class="hljs-keyword">if</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>):<br>            print(d, d.ma_used, d.ma_keys.dk_nentries,<br>                  d.ma_keys.dk_usable, <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span> <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;combine&#x27;</span>:<br>        d = dict_factory(<span class="hljs-string">&#x27;combine&#x27;</span>)<br>        operations = [<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],  <span class="hljs-comment"># DUMMY</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">1</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">2</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">3</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">14</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">4</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">15</span>]],  <span class="hljs-comment"># fill到6，resize</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">14</span>]],  <span class="hljs-comment"># 插入成功后触发resize</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">16</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">16</span>, <span class="hljs-number">116</span>]],  <span class="hljs-comment"># 0,1,6,15  0为DUMMY，1、6Active，15FREE，占用0DUMMY位, </span><br>                               <span class="hljs-comment">#但是注意entries没有对应的那个</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]],    <span class="hljs-comment"># 0,1,6,15  占15FREE位</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">17</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">7</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">6</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">0</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">5</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">4</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">3</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">2</span>]],<br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">1</span>]],<br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">18</span>]], <span class="hljs-comment"># 这里比原来版本提前一轮resize，就是因为没有重用entries，nentries一直增加</span><br>            [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">19</span>]],  <br>            [<span class="hljs-string">&#x27;D&#x27;</span>, [<span class="hljs-number">999</span>]]  <span class="hljs-comment"># let&#x27;s end up with error</span><br>        ]<br>        run_tests(d, operations)<br><br>    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;split&#x27;</span>:<br>        d1 = dict_factory(<span class="hljs-string">&#x27;split&#x27;</span>)<br>        d2 = dict_factory(<span class="hljs-string">&#x27;split&#x27;</span>)<br>        run_tests(d1, [[<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]], [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>]]])<br>        run_tests(d2, [[<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">20</span>]], [<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">21</span>]]])<br>        run_tests(d2, [[<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">22</span>]]])<br>        <span class="hljs-comment"># 插入序改变，退化</span><br>        run_tests(d1, [[<span class="hljs-string">&#x27;S&#x27;</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>]], [<span class="hljs-string">&#x27;S&#x27;</span>, (<span class="hljs-number">4</span>, <span class="hljs-number">14</span>)], [<span class="hljs-string">&#x27;D&#x27;</span>, (<span class="hljs-number">3</span>,)]]) <br>        <span class="hljs-comment"># 删除，也退化</span><br>        run_tests(d2, [[<span class="hljs-string">&#x27;D&#x27;</span>, (<span class="hljs-number">2</span>,)]])   <br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Python字典的hash策略选择的是<strong>开放地址法</strong>，因为拉链法要维护额外的连接，比如链表的指针，开销更大。</li><li>开放地址法的冲突解决方案，总共有两步：<ol><li>找到一种基本的、人类生活中<strong>出现概率较小的索引序列</strong>，比如<code>idx = (5*idx+1) % 2**i</code></li><li>在基本序列基础上，每一步引入hashvalue的影响，以免hashvalue第一次确定的索引相同后，之后每次产生的新索引都相同(即<strong>探测链相同</strong>)</li></ol></li><li>装载率指，删除产生的空位entry(dummy)+正在使用的entry / 总的entry数量(二次幂)，装载率超过2/3时容量改变。注意删除key不会造成容量改变。</li><li>为什么3.6之后的字典能够保证插入序？因为keys和values分离了，想象keys，values都是列表，每次插入新值，values都按顺序写入值。即使发生删除，values中出现空位后，再插入值，新值也会按顺序出现在最后。探测链上的DUMMY值，只会出现在keys中，所以keys中因为删除出现的空位是可以被复用的。</li><li>字典的容量伸缩机制？字典的总容量(keys的大小)，一直都是二次幂，当装载率（active+dummy）超过容量的2/3，就会触发resize，调整总容量，重新分配新的内存，把因删除产生的dummy抹除。调整的总容量，目前3.7版本的一次调整，最多翻倍，最少可以回到8的初始值。</li><li>现在应该更能理解__slots__在做什么。一个实例字典，都要殚精竭虑地share key来减少内存使用。那么直接定义slots，让额外的__dict__消失岂不美滋滋？也就是《Fluent Python》中强调的，__slots__的本质就是减少内存，不是给你用来做限制的。</li><li>再黑魔法都是人写出来的，消除神秘感，也算是增强自己的信心，不要怕。一步一步做，他们也会写出bug啊。看Raymond的演讲，知道方案也是慢慢深入的，没有一步登天。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
