<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/howl.png">
    <link rel="icon" type="image/png" href="/howl.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Is Life Always This Hard? / After all this time?">
    <meta name="author" content="aptend">
    <meta name="keywords" content>
    <title>client-go工作队列学习(二) - 延时队列 ~ No one</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/github.min.css">
    
    <link rel="stylesheet" href="/css/github-markdown.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>No one</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">client-go工作队列学习(二) - 延时队列</p>
            <br>
            
            <p>Friday, March 20th 2020, 8:45 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="markdown-body post-content py-5 z-depth-3 main">
                <p>第二篇，延时队列: 想进去排队啊？等着</p>
<a id="more"></a>
<h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><pre><code class="go">type DelayingInterface interface {
  Interface                     // 继承了通用队列所有接口          
  AddAfter(item interface{}, duration time.Duration) // 增加了延迟添加的接口
}
</code></pre>
<p>从接口定义看，猜测是元素在duration之后的再加入队列，那维护一个优先队列，设定线程timer，轮询队列头元素是否满足加入队列的绝对时间条件，满足就直接调用通用队列的Add？哎呀终于猜对了一把方向。</p>
<p>下面是实现用的结构：</p>
<pre><code class="go">type delayingType struct {
  Interface                    // 组合通用队列实现
  clock clock.Clock            // 时钟，用于获取时间
  stopCh chan struct{}         // 优先队列的协程需要退出信号
  stopOnce sync.Once           // 向优先队列协程发送关闭信号只能发一次
  heartbeat clock.Ticker       // 定时器，定时唤醒处理协程去看队列头是否满足插入时间
  waitingForAddCh chan *waitFor // 所有延迟添加的元素封装成waitFor放到chan中
  metrics retryMetrics         // 和通用队列中的metrics功能类似
}
</code></pre>
<p>waitFor就是要放入优先队列中的元素结构</p>
<pre><code class="go">type waitFor struct {
  data  t             // 元素数据，这个t就是在通用队列中定义的类型interface{}
  readyAt time.Time   // 插入动作生效的绝对时间
  index int           // 指示这个元素在优先队列中的位置，用来调整在队列中的值
}
</code></pre>
<p>虽然允许多次调用关闭，但在stopOnce的作用下只会关闭一次。</p>
<pre><code class="go">// 只关闭一次

func (q *delayingType) ShutDown() {
  q.stopOnce.Do(func() {
    q.Interface.ShutDown()
    close(q.stopCh)
    q.heartbeat.Stop()
  })
}

</code></pre>
<p><code>AddAfter</code>长这样，逻辑足够简单了。</p>
<pre><code class="go">func (q *delayingType) AddAfter(item interface{}, duration time.Duration) {

  // don&#39;t add if we&#39;re already shutting down
  if q.ShuttingDown() {
    return
  }

  q.metrics.retry()
  // immediately add things with no delay
  if duration &lt;= 0 {
    q.Add(item)
    return
  }

  select {
  case &lt;-q.stopCh:
    // unblock if ShutDown() is called
    // 可以从stopCh中读出，说明关闭事件发生，直接跳过后面的添加
  case q.waitingForAddCh &lt;- &amp;waitFor{data: item, readyAt: q.clock.Now().Add(duration)}:
    // 向优先队列发送waitFor
  }
}
</code></pre>
<p>下面是关于优先队列的逻辑，还是有太多我想不到的优化。</p>
<pre><code class="go">// waitingLoop runs until the workqueue is shutdown and
// keeps a check on the list of items to be added.
func (q *delayingType) waitingLoop() {

  defer utilruntime.HandleCrash()

  // Make a placeholder channel to use when there are no items in our list
  // 队列中没有元素时，这个watiloop实际上不用醒来，这里的具体做法就是创建一个永远不会有输入的chan，
  // select就永远睡去了
  never := make(&lt;-chan time.Time) 

  // Make a timer that expires when the item at the head of the waiting queue is ready
  // 假如，队列中第一个事件开始于4min后，而且期间新元素插入，waitloop应该4min之后再醒来执行事件
  var nextReadyAtTimer clock.Timer

  // 初始化优先队列
  waitingForQueue := &amp;waitForPriorityQueue{}
  heap.Init(waitingForQueue)


// t是对象，队列要维护对象的身份，相同对象插入时，仅更新时间，不要重复插入
  waitingEntryByData := map[t]*waitFor{}

  for {
    if q.Interface.ShuttingDown() {
      return
    }

    now := q.clock.Now()

    // Add ready entries
    // 醒来了，开始干活，队列中有对象
    for waitingForQueue.Len() &gt; 0 {
      entry := waitingForQueue.Peek().(*waitFor)
      if entry.readyAt.After(now) {
        break // 后面的对象都不会生效了，跳出处理
      }

      // 满足生效时间，弹出对象，插入下层队列
      entry = heap.Pop(waitingForQueue).(*waitFor)
      q.Add(entry.data)
      // 去重用的map中删除
      delete(waitingEntryByData, entry.data)
    }

    // Set up a wait for the first item&#39;s readyAt (if one exists)
    // 经过上步，生效的对象都插入队列了，看距离下一次生效要多长时间，先假设队列已空，无限长
    nextReadyAt := never

    if waitingForQueue.Len() &gt; 0 {
      if nextReadyAtTimer != nil {
        // 新插入的元素生效时间可能更短，取消之前的timer
        nextReadyAtTimer.Stop()
      }

      entry := waitingForQueue.Peek().(*waitFor)
      nextReadyAtTimer = q.clock.NewTimer(entry.readyAt.Sub(now))
      nextReadyAt = nextReadyAtTimer.C()
    }

    select {

    case &lt;-q.stopCh:
      return

    case &lt;-q.heartbeat.C():
      // continue the loop, which will add ready items
      // 理论上这个没用，保险一下，跳出select，去到上面的处理流程，尝试去添加生效的事件

    case &lt;-nextReadyAt:
      // continue the loop, which will add ready items
      // 之前设置的队列头部事件设里的timer，此时第一个事件应该生效了

    case waitEntry := &lt;-q.waitingForAddCh:

      // AddAfter被调用啦，新加入元素
      if waitEntry.readyAt.After(q.clock.Now()) {
        insert(waitingForQueue, waitingEntryByData, waitEntry)
      } else {
        q.Add(waitEntry.data)
      }


      // 把chan中可用的entry一次性处理完
      drained := false
      for !drained {
        select {
        case waitEntry := &lt;-q.waitingForAddCh:
          if waitEntry.readyAt.After(q.clock.Now()) {
            insert(waitingForQueue, waitingEntryByData, waitEntry)
          } else {
            q.Add(waitEntry.data)
          }
        default:
          drained = true
        }
      }
    }
  }
}


// 插入优先队列
func insert(q waitForPriorityQueue, knownEntries map[t]waitFor, entry *waitFor) {
  // if the entry already exists, update the time only if it would cause the item to be queued sooner
  // 已在队列中，并且生效时间提前，更新时间。Heap.Fix，大概相当于swim和sink吧
  existing, exists := knownEntries[entry.data]
  if exists {
    if existing.readyAt.After(entry.readyAt) {
      existing.readyAt = entry.readyAt
      heap.Fix(q, existing.index)
    }
    return
  }
  heap.Push(q, entry)
  knownEntries[entry.data] = entry
}

</code></pre>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul>
<li><p>优先队列的检查，并不是依靠无差别的heartbeat做的。每次插入时会检查，没有插入时，检查队列头，确定最近事件的发生，调整timer时机，避免loop无意义地醒来，性能更好。</p>
<pre><code class="txt">  +--------------------------------------+
  |                                      |
  |                              +------------------+
  |                              |  Add all ready   |
  |                              | elements in pq   | 
  |                              | by loop          |
  |                              +------------------+
  |                                      |
  |                                      |
  |                              +------------------+
  |                              | set `nextReadyAt`|
  |                              | according to the |
  |                              | head of pq       |
  |                              +------------------+
  |                                      |
  |                                      | select on!
  |                                      |
  |             +------------------------+-----------------+-------------+
  |             |                        |                 |             |
  |        waitingForAdd             heartbeat        nextReadyAt     stopCh
  |             |                        |                 |             |
  |    +------------------+              |                 |             |
  |    | insert into pq   |              |                 |             |
  |    | or change val    |              |                 |             |
  |    | in pq by loop    |              |                 |             |
  |    +------------------+              |                 |             | break!
  |             |                        |                 |             |
  |             +------------------------+-----------------+             |
  |                                      |                               |
  +--------------------------------------+                               v
</code></pre>
</li>
</ul>
<ul>
<li><p>而误解的heartbeat，实际上是工程上的保险，时间隔为10s(maxWait)，其注释写道：</p>
<blockquote>
<p>// maxWait keeps a max bound on the wait time. It’s <strong>just insurance against weird things happening</strong>.  Checking the queue every 10 seconds <strong>isn’t expensive</strong> and we know that we’ll never end up with an expired item sitting for more than 10 seconds.</p>
</blockquote>
</li>
<li><p>队列元素的修改，重排，Go可以使用Fix，这也太实诚了。虽然大家都是通过数组实现的优先队列，但是学院派一点，都说自己不保证底层的实现方式，你只能用push和pop接口，不支持修改，支持修改的应该是额外的数据结构。Python里面没有对应的接口，但是可以用内部函数冒充一下，而Rust中也有siftup等，但是私有方法用不了</p>
</li>
</ul>
<pre><code class="python">def heapfix(heap, idx):
    if idx &gt;= len(heap):
        raise IndexError
    heapq._siftdown(heap, 0, idx)  # try swimming to tree top
    heapq._siftup(heap, idx)       # try sinking to tree leaf

def test_fix():
    heap = [randint(0, 100) for _ in range(50)]
    heapify(heap)
    idx, val = randint(0,49), randint(-20, 120)
    heap[idx] = val
    heapfix(heap, idx)
    pop_order = [heappop(heap) for _ in range(len(heap))]
    return all(x &lt;= y for (x, y) in zip(pop_order, pop_order[1:]))
</code></pre>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Algo</span>
                        &nbsp;
                         
                        <span class="badge badge-light">#&nbsp;Go</span>
                        &nbsp;
                         
                        <span class="badge badge-light">#&nbsp;Kubernetes</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <!-- <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p>  -->
    <div id="tocbot"></div>
  </div>


        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>

  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
<script src="/js/main.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>

<script src="/js/post.js"></script>

<script src="/js/plugins/prettify.js"></script>
<script>
  $(document).ready(function () {
    $('pre').addClass('prettyprint');
    prettyPrint();
  })
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>