<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/howl.png">
    <link rel="icon" type="image/png" href="/howl.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Is Life Always This Hard? / After all this time?">
    <meta name="author" content="aptend">
    <meta name="keywords" content>
    <title>一个Rust生命周期问题 ~ No one</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/github.min.css">
    
    <link rel="stylesheet" href="/css/github-markdown.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>No one</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">一个Rust生命周期问题</p>
            <br>
            
            <p>Thursday, December 17th 2020, 8:06 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="markdown-body post-content py-5 z-depth-3 main">
                <p>给知乎上一个生命周期问题提供的解决办法</p>
<a id="more"></a>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p><a href="https://zhuanlan.zhihu.com/p/104742696" target="_blank" rel="noopener">一个关于rust生命周期的问题分析 - 知乎 (zhihu.com)</a></p>
<p>相关的 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f1ffcb16c412679feeaa5fe594052ed" target="_blank" rel="noopener">Rust Playground (rust-lang.org)</a></p>
<p>场景目标是，有一个已经存在的 <code>&amp;[u8]</code> buffer，一个<code>Parser</code>结构的<code>parse</code>方法希望查阅这个buffer，同时修改自身的状态，以自身状态为基础产生一个新的<code>&amp;[u8]</code> buffer，返回这个新引用。 <code>parse</code> 方法可以多次调用，所以希望在<code>Parser</code>结构的基础上制作一个迭代器，每次迭代执行<code>parse</code>，返回构建的 <code>u8</code> buffer</p>
<p>由此有以下代码：</p>
<pre><code class="rust">struct Parser {
// ...
}

impl Parser {
       pub fn parse&lt;&#39;a&gt;(&amp;&#39;a mut self, buf: &amp;&#39;a [u8]) -&gt; Option&lt;&amp;&#39;a u8&gt; {
           todo!()
       }

       pub fn iter&lt;&#39;a&gt;(&amp;&#39;a mut self, buf: &amp;&#39;a [u8]) -&gt; ParseIter&lt;&#39;a&gt; {
           ParseIter { parser: self, buf }
       }
}

pub struct ParseIter&lt;&#39;a&gt; {
    parser: &amp;&#39;a mut Parser,
    buf: &amp;&#39;a [u8],
}

impl&lt;&#39;a&gt; Iterator for ParseIter&lt;&#39;a&gt; {
    type Item = &amp;&#39;a u8;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.parser.parse(self.buf)
    }
}
</code></pre>
<p>但是甚至不待使用<code>ParseIter&lt;&#39;a&gt;</code>，就会因为生命周期问题产生编译错误。<br>个人感觉错误本身对修改的指导意义不大，就不贴在这里了，有需要可以看原文。</p>
<blockquote>
<p>评论中提出，去掉<code>parser</code>中<code>self</code>的生命周期标记，变成<br><code>fn parse&lt;&#39;a&gt;(&amp;mut self, buf: &amp;&#39;a [u8]) -&gt; Option&lt;&amp;&#39;a u8&gt;</code><br>这的确可以通过编译，但是这表明的是作为返回值的引用和<code>Parser</code>本身无关，并没有基于它的任何字段。显然这和设计的目标不一致。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在不实现<code>ParseIter&lt;&#39;a&gt;</code>的<code>next</code>时，程序可以编译，所以从<code>next</code>的实现着手分析，看他破坏了什么东西。将实现做如下展开：</p>
<pre><code class="rust">fn next&lt;&#39;iter&gt;(&amp;&#39;iter mut self) -&gt; Option&lt;&amp;&#39;a u8&gt; {
    let parser: &amp;&#39;a mut Parser = &amp;mut *self.parser;
    let buf: &amp;&#39;a [u8] = self.buf;
    return Parser::parse(parser, buf);
}
</code></pre>
<p>buf的引用可以直接通过Copy复制，所以可以得到<code>&amp;&#39;a [u8]</code>。</p>
<p>但是<code>parser</code>属于可变引用，不能Copy，只能通过<code>Deref</code>再重新取引用，如原文作者所说，实际发生的是</p>
<pre><code class="rust">fn deref_mut&lt;&#39;iter&gt;(&amp;&#39;iter mut &amp;&#39;a mut Parser) -&gt; &amp;&#39;iter mut Self::Target;
</code></pre>
<p>返回的引用需要受限于<code>&#39;iter</code>生命周期，但是这里并没有<code>&#39;iter: &#39;a</code>关系，所以不能保证parser的存活范围，换言之，万一<code>&#39;iter</code>更小，从中借出一个生命周期更长的引用显然不可能。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原文作者并没有给出解决方法。这里给出一个大佬 <a href="https://github.com/BurntSushi" target="_blank" rel="noopener">BurntSushi</a> 在 fst 库中给出的方案：<a href="https://docs.rs/fst/0.4.5/fst/trait.Streamer.html" target="_blank" rel="noopener">Streamer</a>。</p>
<p>在上节分析的最后，我们发现缺少<code>&#39;iter: &#39;a</code>的保证，如果想加上，就会发想<code>Iterator</code>这个trait阻止你这么做了。Iterator的本意，是希望迭代出的元素的生命周期和自身无关，可以被外界同时持有多个，甚至迭代器被drop也没有关系。但是上述场景不是这样的，每次迭代返回的引用，不可能被同时持有，因为受限制于<code>Parser</code>本身的状态，自然也就和持有<code>&amp;mut Parser</code>引用的<code>ParserIter</code>有关了。因此我们可以说，针对这个场景，<code>Iterator</code>这个trait选错了。</p>
<p>fst中的迭代也是类似的场景，所以制作了一个<code>Streamer</code>的trait。</p>
<pre><code class="rust">pub trait Streamer&lt;&#39;a&gt; {
    type Item: &#39;a;
    fn next(&amp;&#39;a mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>形式上和<code>Iterator</code>很像，区别在于对迭代器本身和返回值多了<code>&#39;a</code>生命周期绑定，表明返回值的生命周期不能超过迭代器本身。因此迭代的元素不可以被同时持有，要么阅后即焚，要么及时复制，所以得名<code>Stream-流</code></p>
<p>如果实现<code>Streamer&lt;&#39;a&gt;</code>，整个的生命周期会按照最短的迭代器的声明周期进行对齐，比如<code>buf</code>的长生命周期在编译时缩短(协变)，以配合<code>Parser::iter</code>方法。成功通过编译，cool</p>
<h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>下面是Streamer文档的后续翻译，作为补充</p>
<p>“””</p>
<p>但是本身这个结构非常难用，会涉及到高阶生命周期绑定。在一个函数中使用该trait，<code>Streamer</code>的生命周期和使用函数没有任何关联，必须用一种方法表示<code>Streamer&lt;&#39;a&gt;</code>的<code>&#39;a</code>可以对任意生命周期有效，不必受制于函数的调用作用域。大概长这样</p>
<pre><code class="rust">fn takes_stream&lt;T, S&gt;(s: S)
    where S: for&lt;&#39;a&gt; Streamer&lt;&#39;a, Item=T&gt;
{}
</code></pre>
<p>但是这个声明有 <strong>三个</strong> 问题：</p>
<ol>
<li><code>S</code> 没有绑定特定生命周期，实际上大多数 stream 都包含者一个底层状态机的引用，才能迭代访问Fst</li>
<li>区分 “stream” 和 “stream 构建器” 的概念，往往会给我们带来方便。在标准库中，这对应这 <code>Iterator</code> 和 <code>IntoIterator</code></li>
<li><code>Item=T</code> 是非法的，因为 <code>Streamer</code> 的关联类型要求绑定一个生命周期参数，但是我们没有办法给任意的类型构建器标记一个生命周期绑定。（当前的情况里，<code>T</code>就是一个类型构建器，因为它始终需要一个生命周期才能成为一个具体的类型）</li>
</ol>
<p>因此，我们需要重新写成这样的庞然大物</p>
<pre><code class="rust">fn takes_stream&lt;&#39;f, I, S&gt;(s: I)
    where I: for&lt;&#39;a&gt; IntoStreamer&lt;&#39;a, Into=S, Item=(&amp;&#39;a [u8], Output)&gt;,
          S: &#39;f + for&lt;&#39;a&gt; Streamer&lt;&#39;a, Item=(&amp;&#39;a [u8], Output)&gt;
{}
</code></pre>
<p>我们是这样解决问题的：</p>
<ol>
<li><code>S</code>现在绑定<code>&#39;f</code>，表示底层stream的生命周期，可能是<code>&#39;static</code></li>
<li>类型参数<code>I</code>加入，表示一个知道如何构建 stream 的类型。注意<code>I</code> 和 <code>S</code>并没有共享相同的生命周期，因为高阶生命周期绑定的<code>’a</code>表示任意的生命周期。</li>
<li><code>T</code> 被替换成了一个具体类型。注意到具体类型在 <code>I</code> 和 <code>S</code> 中是重复的。在 <code>Iterator</code> 和 <code>IntoIterator</code> 中，<code>I</code>可以通过<code>S::Item</code>简写，但是在高阶生命周期绑定中，我们不能访问关联类型。</li>
</ol>
<p>如你所见，stream 的灵活零欠缺，一丢丢反人类，给了一大堆难以阅读的trait绑定。情况就是这么尴尬，但是没有它，我们又不能组合各种数据流。</p>
<p>唯一的慰藉可能是，完全相同的 trait bound 可以到处用。一旦你领会了精神，剩下的可能就是复制粘贴。</p>
<p>“””</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><code>Iterator</code>并不是万能的，需要了解它的使用场景和局限</li>
<li>编译错误可能并不能指导修改，程序的语义需要自己把握</li>
<li>单是函数的签名就能反应出整个工作流程，很神奇</li>
</ul>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Rust</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <!-- <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p>  -->
    <div id="tocbot"></div>
  </div>


        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>

  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
<script src="/js/main.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>

<script src="/js/post.js"></script>

<script src="/js/plugins/prettify.js"></script>
<script>
  $(document).ready(function () {
    $('pre').addClass('prettyprint');
    prettyPrint();
  })
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>