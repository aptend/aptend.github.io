<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/howl.png">
    <link rel="icon" type="image/png" href="/howl.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Is Life Always This Hard? / After all this time?">
    <meta name="author" content="aptend">
    <meta name="keywords" content>
    <title>serde你在干什么 - deserialize - II ~ No one</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/github.min.css">
    
    <link rel="stylesheet" href="/css/github-markdown.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>No one</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">serde你在干什么 - deserialize - II</p>
            <br>
            
            <p>Wednesday, January 8th 2020, 7:10 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="markdown-body post-content py-5 z-depth-3 main">
                <p>serde 源码解析 deserialization篇 第二部分</p>
<a id="more"></a>
<p>上篇，已经把反序列化的总体过程描述了一遍，也留下了几个问题，<code>DeserializeSeed</code>和<code>PhantomData</code>是什么，<code>EnumAccess</code>中的<code>variant</code>方法被<code>visit_enum</code>调用后，为什么能产生一个<code>__Field</code>实例呢？</p>
<h2 id="DeserializeSeed"><a href="#DeserializeSeed" class="headerlink" title="DeserializeSeed"></a><a href="https://docs.serde.rs/serde/de/trait.DeserializeSeed.html" target="_blank" rel="noopener">DeserializeSeed</a></h2><pre><code class="rust">pub trait DeserializeSeed&lt;&#39;de&gt;: Sized {
    type Value;
    fn deserialize&lt;D&gt;(self, deserializer: D) -&gt; Result&lt;Self::Value, D::Error&gt;
    where
        D: Deserializer&lt;&#39;de&gt;;
}

pub trait Deserialize&lt;&#39;de&gt;: Sized {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;&#39;de&gt;;
}
</code></pre>
<p>和<code>Deserialize</code>的区别，就在于用<code>DeserializeSeed</code>自定义了输出的类型，不必和实现类型一致。</p>
<p>也就是说，对一个<code>DeserializeSeed-thing</code>调用它的<code>deserialize</code>去消费一个<code>deserializer</code>提供的数据，可以返回的是自定义的Value类型。</p>
<p>回忆通常情况下，对<code>Deserialize</code>的使用，是利用泛型参数，由<code>Result&lt;T&gt;</code>推断出具体的T类型，再调用对应的<code>deserialze</code>方法，返回一个T类型的实例，这个过程只有类型参与，属于无状态的反序列化，比如下面的<code>T::deserialize()</code></p>
<pre><code class="rust">pub fn from_str&lt;&#39;a, T&gt;(s: &amp;&#39;a str) -&gt; Result&lt;T&gt;
where
    T: Deserialize&lt;&#39;a&gt;,
{
    let mut deserializer = Deserializer::from_str(s);
    let t = T::deserialize(&amp;mut deserializer)?;
       Ok(t)
}
</code></pre>
<p>但是对于实现了<code>DeserializeSeed</code>的类型，使用上有所不同，通常是初始化成为一个实例，可以拥有自己的数据，常被当作参数<code>seed</code>传入一个形如<code></code>fn *_seed()<code>的方法，由它调用</code>seed<code>上的反序列化方法，比如下面的</code>seed.deserialize()<code>，这个deserialize过程则允许</code>seed`自身数据参与，所以是个有状态的反序列化过程。</p>
<pre><code class="rust">fn variant_seed&lt;V&gt;(self, seed: V) -&gt; Result&lt;(V::Value, Self::Variant)&gt;
where
    V: DeserializeSeed&lt;&#39;de&gt;,
{
    let val = seed.deserialize(&amp;mut *self.de)?;
    if self.de.next_char()? == &#39;:&#39; {
        Ok((val, self))
    } else {
        Err(Error::ExpectedMapColon)
    }
}
</code></pre>
<p>不妨再来看看，哪些地方存在这样的<code>fn *_seed()</code>:</p>
<ul>
<li><p><code>SeqAccess</code>中的<code>next_element_seed</code></p>
</li>
<li><p><code>MapAccess</code>中的<code>next_key_seed</code>、<code>next_value_seed</code>、<code>next_entry_seed</code></p>
</li>
<li><p><code>EnumAccess</code>中的<code>variant_seed</code></p>
</li>
<li><p><code>VariantAcess</code>中的<code>newtype_variant_seed</code></p>
</li>
</ul>
<p>这些方法出现在<code>deserializer</code>为<code>visitor</code>提供的集合数据类型中。一个<code>visitor</code>，只有在实现了<code>visit_seq</code>、<code>visit_map</code>、<code>visit_enum</code>这类方法的前提下，才有机会使用有状态的反序列化。</p>
<p>但在实际工作中，大多数情况的反序列化，都是无状态的，所以给这些<code>fn *_seed()</code>方法传递的<code>DeserializeSeed-thing</code>，也就是参数<code>seed</code>，自然可以没有自己的数据，仅仅把某种类型信息给传递进去。像这种有类型、却没有实际数据的东西，标准库里专门有个类型叫<code>PhantomData</code>，幽灵数据来表示，编译器不会给他分配内存空间，只用来做类型的推断和方法的关联。</p>
<p>Serde已经为<code>PhantomData</code>实现<code>DeserializeSeed</code>，使其成为<code>DeserializeSeed-thing</code>，直接把<code>PhantomData</code>传入<code>fn *_seed()</code>里，就等效于无状态<code>Deserialize</code>的过程，只有类型参与。</p>
<pre><code class="rust">impl&lt;&#39;de, T&gt; DeserializeSeed&lt;&#39;de&gt; for PhantomData&lt;T&gt;
where
    T: Deserialize&lt;&#39;de&gt;,
{
    type Value = T;

    #[inline]
    fn deserialize&lt;D&gt;(self, deserializer: D) -&gt; Result&lt;T, D::Error&gt;
    where
        D: Deserializer&lt;&#39;de&gt;,
    {
        // 方法调用PhantomData的deserialize，最后落脚到这里，等于绕了一圈确定T类型
        T::deserialize(deserializer)
    }
}
</code></pre>
<p>甚至，因为无状态反序列化太普遍，Serde提供了一种快捷方式，比如<code>next_element_seed</code>的无状态化版本是<code>next_element</code>，就直接帮你传入了<code>PhantomData</code>，使用<code>next_element</code>时，T就通过表达式左值的类型来推断就OK了。</p>
<pre><code class="rust">fn next_element&lt;T&gt;(&amp;mut self) -&gt; Result&lt;Option&lt;T&gt;, Self::Error&gt;
where
    T: Deserialize&lt;&#39;de&gt;,
{
    self.next_element_seed(PhantomData)
}
</code></pre>
<p>有了这样的基础，再看<code>visit_enum</code>就清楚了，中间调用<code>match _serde::de::EnumAccess::variant(__data)</code>时，推断出T的类型是<code>__Field</code>，也就是使用的<code>variant</code>版本如下：</p>
<pre><code class="rust">fn variant&lt;__Field&gt;(self) -&gt; Result&lt;(__Field, Self::Variant), Self::Error&gt;
where
    __Field: Deserialize&lt;&#39;de&gt;,
{
    self.variant_seed(PhantomData)
}
</code></pre>
<p>因此<code>PhantomData</code>是<code>PhantomData&lt;__Field&gt;</code>的一个“实例”，实现了<code>DeserializeSeed</code>，传到<code>variant_seed</code>中叫做<code>seed</code>，根据<code>PhantomData</code>默认的<code>DeserializeSeed</code>的实现，<code>variant_seed</code>中语句<code>seed.deserialize(deserializer)</code>的本质就是<code>__Field::deserialize(deserializer)</code>，于是产生了具体的<code>__Field</code>值。</p>
<h2 id="嵌套之路"><a href="#嵌套之路" class="headerlink" title="嵌套之路"></a>嵌套之路</h2><p>清楚了<code>__Field</code>的来历之后，不妨再关注一下tuple中的第二项，<code>VariantAccess-thing</code>，它包含着四个必须实现的方法，概括了可能出现的枚举形态</p>
<ul>
<li><code>unit_variant</code>，比如对应<code>Command::Quit</code></li>
<li><code>newtype_variant</code>，比如对应<code>Command::Rm</code></li>
<li><code>tuple_variant</code>，比如对应<code>Command::SomeCmd(a, b, c)</code>这种</li>
<li><code>struct_variant</code>，比如对应<code>Command::{Get, Set}</code></li>
</ul>
<p>一个<code>VariantAccess</code>可以看做特定领域的<code>deserializer</code>，这个四个方法和通用的<code>deserialize_*</code>方法的作用类似，由上层调用，提示接下来的数据应该可以按照什么样的规则去解析。所以这里的<code>Visitor</code>和<code>VariantAccess</code>功能上如同一对<code>Deserialize</code>和<code>Deserializer</code>，这不就是一层嵌套吗？</p>
<p>举两个例子，这两个简单的match分支，<code>Command::Quit</code>和<code>Command::Rm</code> ，就分别提示接下来按照<code>unit_variat</code>和<code>newtype_variant</code>的规则解析数据。</p>
<pre><code class="rust">// derive_de.rs
(__Field::__field2, __variant) =&gt; {
    _serde::export::Result::map(_serde::de::VariantAccess::newtype_variant::&lt;String&gt;(__variant), Command::Rm)
}
(__Field::__field3, __variant) =&gt; {
    match _serde::de::VariantAccess::unit_variant(__variant) {
        _serde::export::Ok(__val) =&gt; __val,
        _serde::export::Err(__err) =&gt; {
            return _serde::export::Err(__err);
        }
    };
    _serde::export::Ok(Command::Quit)
}
</code></pre>
<p>但是复杂一点的<code>Command::Set</code>，它调用的是<code>struct_variant</code>，表明接下来期待的是结构性的枚举。到这里，更明显的嵌套出现了，又新建一个<code>__Field</code>类型，用来保存<code>Command::Get</code>中的<code>Key</code>和<code>Value</code>的标识符信息。然后派出一个<code>visitor</code>，可以从<code>SeqAccess</code>或者<code>MapAccess</code>类型的数据来构建<code>Command::Get</code>的实例。</p>
<pre><code class="rust">// derive_de.rs

#[allow(non_camel_case_types)]
enum __Field { __field0, __field1, __ignore, }
struct __FieldVisitor;
impl&lt;&#39;de&gt; _serde::de::Visitor&lt;&#39;de&gt; for __FieldVisitor {
    type Value = __Field;
    fn expecting(&amp;self, __formatter: &amp;mut _serde::export::Formatter)
    fn visit_u64&lt;__E&gt;(self, __value: u64) 
    fn visit_str&lt;__E&gt;(self, __value: &amp;str) 
    fn visit_bytes&lt;__E&gt;(self, __value: &amp;[u8])
}
impl&lt;&#39;de&gt; _serde::Deserialize&lt;&#39;de&gt; for __Field { ... }

// 再造一个Command::Set的visitor           
struct __Visitor&lt;&#39;de&gt; {
    marker: _serde::export::PhantomData&lt;Command&gt;,
    lifetime: _serde::export::PhantomData&lt;&amp;&#39;de ()&gt;,
}
impl&lt;&#39;de&gt; _serde::de::Visitor&lt;&#39;de&gt; for __Visitor&lt;&#39;de&gt; {
    type Value = Command;
    fn expecting(&amp;self, __formatter: &amp;mut _serde::export::Formatter) -&gt; _serde::export::fmt::Result {
        _serde::export::Formatter::write_str(__formatter, &quot;struct variant Command::Set&quot;)
    }
    // Set由Seq生成
    #[inline]
    fn visit_seq&lt;__A&gt;(self, mut __seq: __A) -&gt; _serde::export::Result&lt;Self::Value, __A::Error&gt;
    where
    __A: _serde::de::SeqAccess&lt;&#39;de&gt;,
    {
        // 反序列化两个字段，类型为String，由最后的构建函数推断
        let __field0 = match match _serde::de::SeqAccess::next_element::&lt;String&gt;(&amp;mut __seq) {
            _serde::export::Ok(__val) =&gt; __val,
            _serde::export::Err(__err) =&gt; {
                return _serde::export::Err(__err);
            }
        } {
            _serde::export::Some(__value) =&gt; __value,
            _serde::export::None =&gt; {
                return _serde::export::Err(_serde::de::Error::invalid_length(
                    0usize,
                    &amp;&quot;struct variant Command::Set with 2 elements&quot;,
                ));
            }
        };
        let __field1 = match match _serde::de::SeqAccess::next_element::&lt;String&gt;(&amp;mut __seq) {
            _serde::export::Ok(__val) =&gt; __val,
            _serde::export::Err(__err) =&gt; {
                return _serde::export::Err(__err);
            }
        } {
            _serde::export::Some(__value) =&gt; __value,
            _serde::export::None =&gt; {
                return _serde::export::Err(_serde::de::Error::invalid_length(
                    1usize,
                    &amp;&quot;struct variant Command::Set with 2 elements&quot;,
                ));
            }
        };
        // 一个Set成功返回
        _serde::export::Ok(Command::Set {
            key: __field0,
            value: __field1,
        })
    }
    // 还可以从map生成，省略
    #[inline]
    fn visit_map&lt;__A&gt;(self, mut __map: __A)
}
// 使用struct_variant提示，尝试解析出一个struct的枚举，也就是Set
const FIELDS: &amp;&#39;static [&amp;&#39;static str] = &amp;[&quot;key&quot;, &quot;value&quot;];
_serde::de::VariantAccess::struct_variant(
    __variant,
    FIELDS,
    __Visitor {
        marker: _serde::export::PhantomData::&lt;Command&gt;,
        lifetime: _serde::export::PhantomData,
    },
)
</code></pre>
<p>因为json中<code>struct</code>和字典表达形式相同，并且key值都包含在序列化数据中，所以不必使用提供的<code>_fields</code>参数，直接交给<code>deserialize_map</code>就足够。</p>
<pre><code class="rust">// de.rs
fn struct_variant&lt;V&gt;(self, _fields: &amp;&#39;static [&amp;&#39;static str], visitor: V) -&gt; Result&lt;V::Value&gt;
where
    V: Visitor&lt;&#39;de&gt;,
{
    de::Deserializer::deserialize_map(self.de, visitor)
}
</code></pre>
<p><code>deserialize_map</code>自然检查map的开闭标识，然后给予一个实现了<code>MapAccess</code>的结构。</p>
<pre><code class="rust">fn deserialize_map&lt;V&gt;(mut self, visitor: V) -&gt; Result&lt;V::Value&gt;
where
    V: Visitor&lt;&#39;de&gt;,
{
    // 字典由{开启
    if self.next_char()? == &#39;{&#39; {
        // 调用 visit_map，所以给一个MapAccess，由CommaSeparated实现
        let value = visitor.visit_map(CommaSeparated::new(&amp;mut self))?;
        // 字典由}结束
        if self.next_char()? == &#39;}&#39; {
            Ok(value)
        } else {
            Err(Error::ExpectedMapEnd)
        }
    } else {
        Err(Error::ExpectedMap)
    }
}
</code></pre>
<p>后面的事情，就是<code>CommaSeparated</code>和<code>visit_map</code>相互配合产生<code>Command::Get</code>了，过程类似<code>Enum</code>和<code>visit_enum</code>的交互，这里就不再详细一步步跟踪了。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>我们用两章的篇幅介绍了反序列化过程。</p>
<p>第一个关键点，明确角色</p>
<ul>
<li><code>Deserialize</code>观察目标类型，制作<code>Visitor</code>，调用<code>Deserializer</code>，交付<code>Visitor</code></li>
<li><code>Deserialzier</code>和被序列化数据打交道，根据<code>Deserialize</code>的提示，把序列化数据解析成恰当的基础数据结构，交给<code>Visitor</code></li>
<li><code>Visitor</code>根据<code>Deserializer</code>给的基础数据类型，按既定规则生成目标类型</li>
</ul>
<p>第二个关键点，集合类型的反序列化</p>
<p>当<code>Deserializer</code>被提示接下来的数据可能是由集合类型序列化而来时，所谓的恰当的基础数据结构，就是实现了<code>*Access</code>系列 trait 的结构，代表着某一种特定结构的<code>Deserializer</code>。其实也就只有四个。</p>
<table>
<thead>
<tr>
<th>Trait</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.serde.rs/serde/de/trait.EnumAccess.html" target="_blank" rel="noopener">EnumAccess</a></td>
<td>重要方法是<code>variant</code>，一次性调用，返回(T, VariantAccess)，判断数据属于哪种枚举</td>
</tr>
<tr>
<td><a href="https://docs.serde.rs/serde/de/trait.VariantAccess.html" target="_blank" rel="noopener">VariantAccess</a></td>
<td>四个必须方法，一次性调用，解析具体的某种枚举</td>
</tr>
<tr>
<td><a href="https://docs.serde.rs/serde/de/trait.MapAccess.html" target="_blank" rel="noopener">MapAccess</a></td>
<td>按照map的风格访问处理已序列化数据，<code>next_key</code>，<code>next_value</code>等</td>
</tr>
<tr>
<td><a href="https://docs.serde.rs/serde/de/trait.SeqAccess.html" target="_blank" rel="noopener">SeqAccess</a></td>
<td>按照seq的风格访问处理已序列化数据，<code>next_element</code></td>
</tr>
</tbody>
</table>
<p>他们统一的风格就是都使用了<code>fn *_seed()</code>的模式，通过<code>DeserializerSeed</code>，提供有状态反序列化的能力。普通的反序列化场景，往往不需要有状态，因此传入<code>PhantomData</code>，直接使用无状态反序列化。</p>
<p>Ok，反序列化也介绍到这里吧。如果想要进一步巩固serde，自己写一个data format的<code>Deserializer</code>和<code>Serializer</code>吧。下一篇，我们为redis协议写一个基础的序列化工具。</p>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Rust</span>
                        &nbsp;
                         
                        <span class="badge badge-light">#&nbsp;Serde你在干什么</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <!-- <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p>  -->
    <div id="tocbot"></div>
  </div>


        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>

  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
<script src="/js/main.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>

<script src="/js/post.js"></script>

<script src="/js/plugins/prettify.js"></script>
<script>
  $(document).ready(function () {
    $('pre').addClass('prettyprint');
    prettyPrint();
  })
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>