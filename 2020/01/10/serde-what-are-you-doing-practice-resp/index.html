<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/howl.png">
    <link rel="icon" type="image/png" href="/howl.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Is Life Always This Hard? / After all this time?">
    <meta name="author" content="aptend">
    <meta name="keywords" content>
    <title>serde你在干什么 - 实践篇 ~ No one</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/github.min.css">
    
    <link rel="stylesheet" href="/css/github-markdown.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>No one</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">serde你在干什么 - 实践篇</p>
            <br>
            
            <p>Friday, January 10th 2020, 10:34 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="markdown-body post-content py-5 z-depth-3 main">
                <p>用Redis Simple Protocol做练习</p>
<a id="more"></a>
<p><code>serde你在干什么</code>的实践篇。基于serde框架，我们来写一个redis协议的deserializer和serializer</p>
<h2 id="Redis-Protocol"><a href="#Redis-Protocol" class="headerlink" title="Redis Protocol"></a>Redis Protocol</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p>redis 客户端和服务端通信的序列化标准</p>
<p>优点(哪都有这三个)：</p>
<ul>
<li>Simple to implement.</li>
<li>Fast to parse.</li>
<li>Human readable.</li>
</ul>
<p>特点：</p>
<ul>
<li>对bulk数据，前置数据长度，binary safe，不需要考虑处理转义的事情。</li>
<li>为Error专门设置了一个类型，方便客户端的错误处理。</li>
</ul>
<h3 id="序列化规范"><a href="#序列化规范" class="headerlink" title="序列化规范"></a>序列化规范</h3><p>可以序列化的类型：</p>
<ul>
<li>For <strong>Simple Strings</strong> the first byte of the reply is “+”</li>
<li>For <strong>Errors</strong> the first byte of the reply is “-“</li>
<li>For <strong>Integers</strong> the first byte of the reply is “:”</li>
<li>For <strong>Bulk Strings</strong> the first byte of the reply is “$” ，等效于&amp;[u8]</li>
<li>For <strong>Arrays</strong> the first byte of the reply is “<code>*</code>“，即Vec</li>
</ul>
<p>Simple Strings</p>
<pre><code class="txt">&quot;+OK\r\n&quot;
</code></pre>
<p>​    </p>
<p>Errors</p>
<pre><code>&quot;-Error message\r\n&quot;
</code></pre><p>​    和Simple Strings基本相同，但是添加一个错误类型段</p>
<p>Integers</p>
<pre><code class="txt">&quot;:1000\r\n&quot;
</code></pre>
<p>​    bool值也使用0、1整型表示</p>
<p>Bulk Strings</p>
<pre><code class="txt">&quot;$6\r\nfoobar\r\n&quot;  [u8; 6]
&quot;$-1\r\n&quot;  () None
</code></pre>
<p>Arrays</p>
<pre><code>&quot;*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n&quot;  [b&quot;foo&quot;, b&quot;bar&quot;]
&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;  [1, 2, 3]
&quot;*0\r\n&quot; []

*2\r\n
*3\r\n
:1\r\n
:2\r\n
:3\r\n
*2\r\n
+Foo\r\n
-Bar\r\n  [[1, 2, 3], [&quot;Foo&quot;, Err(Bar)]]

*3\r\n
$3\r\n
foo\r\n
$-1\r\n
$3\r\n
bar\r\n  [&quot;foo&quot;,nil,&quot;bar&quot;]
</code></pre><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>使用上，客户端发送 用 <strong>Array of Bulk Strings</strong> 的形式给服务器端发送 <strong>命令及参数</strong> 作为 Request；服务器端给客户端发送 任意的类型(组合) 作为 Response。</p>
<pre><code class="txt">C: *2\r\n$3\r\nget\r\n$4\r\nkey1\r\n   get key1
S: $3\r\n101\rn  101
</code></pre>
<p>redis 支持多个command的提交，一次性运行，提升单位时间的执行数量。成为<a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">piplining</a></p>
<pre><code class="shell">$ printf &#39;*2\r\n$3\r\nget\r\n$1\r\nA\r\n*2\r\n$3\r\nget\r\n$1\r\nA\r\n&#39; | nc localhost 6379
$3
101
$3
101

$ printf &#39;get A\n get A\n&#39; | nc localhost 6379
$3
101
$3
101
</code></pre>
<h2 id="serde实现"><a href="#serde实现" class="headerlink" title="serde实现"></a>serde实现</h2><p>如前所述，正常情况下，客户端 –&gt; 服务端， 得用 <strong>Array of Bulk Strings</strong> 的格式告知 <strong>命令及参数</strong>；但是服务端反馈结果给客户端时，可以使用<strong>任意的格式组合</strong>。这其实表示了有两套序列化和反序列化的接口：</p>
<ol>
<li>客户端的序列化，服务端的反序列化，以 <strong>Array of Bulk Strings</strong> 为中介</li>
<li>服务端的序列化，客户端的反序列化，以 <strong>任意的格式组合</strong> 为中介</li>
</ol>
<p>当前实践篇，主要目的还是学习，简化一下，暂时忽略第二种，姑且认为服务端给客户端发送的也是<strong>Array of Bulk Strings</strong>，类型由rust本身的类型系统进行约束。</p>
<p>因此，我们希望客户端和服务端都有一套<strong>共同的Request/Response类型</strong>。还是以<code>Get</code>、<code>Set</code>、<code>Remove</code>三兄弟为例来设计。</p>
<pre><code class="rust">#[derive(Debug, Serialize, Deserialize)]
enum Request {
    Get { key: String },
    Set { key: String, value: String },
    Remove { key: String },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum GetResponse {
    Ok(Option&lt;String&gt;),
    Err(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SetResponse {
    Ok(()),
    Err(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum RemoveResponse {
    Ok(()),
    Err(String),
}
</code></pre>
<p>根据协议要求，服务端接受的一定是 <strong>Array of Bulk Strings</strong>，用<code>u8</code>序列表示，所以，假定序列化接口为</p>
<pre><code class="rust">pub fn&lt;T: Serialize&gt; to_bytes(value: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;&gt;
</code></pre>
<p>序列化过程可以通过如下的测试：</p>
<pre><code class="rust">#[test]
fn test_ser() {
    let get = Request::Get {
        key: &quot;key1&quot;.to_owned(),
    };
    assert_eq!(
        to_bytes(&amp;get).unwrap(),
        b&quot;*2\r\n$3\r\nGet\r\n$4\r\nkey1\r\n&quot;
    );
    let set = Request::Set {
        key: &quot;key1&quot;.to_owned(),
        value: &quot;value1&quot;.to_owned(),
    };
    assert_eq!(
        to_bytes(&amp;set).unwrap(),
        &quot;*3\r\n$3\r\nSet\r\n$4\r\nkey1\r\n$6\r\nvalue1\r\n&quot;.as_bytes()
    );
    let rm = Request::Remove {
        key: &quot;key1&quot;.to_owned(),
    };
    assert_eq!(
        to_bytes(&amp;rm).unwrap(),
        b&quot;*2\r\n$6\r\nRemove\r\n$4\r\nkey1\r\n&quot;
    );
}
</code></pre>
<p>在这个过程中，enum的名字不重要，每个variant的名字才是”命令”，所以放入array的第一项，variant的数据字段，追加到array中作为命令的参数。</p>
<p>影响序列化的关键一点是，不管”参数”是什么类型，最后都会以bulk string的形式作为array的元素。即使数据本身是int型，比如42，也会序列化为<code>$2\r\n\42\r\n</code>，而不是<code>:42\r\n</code>。</p>
<p>在服务端一侧，数据是从网络连接中读取的，因此我们假定反序列化接口为，</p>
<pre><code class="rust">pub fn from_reader(r: R) -&gt; Result&lt;T&gt;
where
    R: io:Read,
    T: DeserializeOwned
</code></pre>
<p>反序列化过程可以通过如下的测试：</p>
<pre><code class="rust">
#[test]
fn test_de() {
    let get = &quot;*2\r\n$3\r\nGet\r\n$4\r\nkey1\r\n&quot;.as_bytes();
    match from_reader::&lt;_, Request&gt;(get).unwrap() {
        Request::Get { key } =&gt; assert_eq!(key, &quot;key1&quot;.to_owned()),
        _ =&gt; assert!(false, &quot;fail to deserialize into `Get`&quot;),
    }

    let set = &quot;*3\r\n$3\r\nSet\r\n$4\r\nkey1\r\n$6\r\nvalue1\r\n&quot;.as_bytes();
    match from_reader::&lt;_, Request&gt;(set).unwrap() {
        Request::Set { key, value } =&gt; {
            assert_eq!(key, &quot;key1&quot;.to_owned());
            assert_eq!(value, &quot;value1&quot;.to_owned());
        }
        _ =&gt; assert!(false, &quot;fail to deserialize into `Set`&quot;),
    }
    // Remove 略
}
</code></pre>
<p>对于<code>GetResponse</code>等结构，也是基本相同的过程，只不过由服务端序列化后，交给客户端去反序列化。</p>
<p>有了基本的测试用例，就可以着手具体实现了，还是分为Serialize和Deserialize两个过程。</p>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Rust</span>
                        &nbsp;
                         
                        <span class="badge badge-light">#&nbsp;Serde你在干什么</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <!-- <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p>  -->
    <div id="tocbot"></div>
  </div>


        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>

  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
<script src="/js/main.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>

<script src="/js/post.js"></script>

<script src="/js/plugins/prettify.js"></script>
<script>
  $(document).ready(function () {
    $('pre').addClass('prettyprint');
    prettyPrint();
  })
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>