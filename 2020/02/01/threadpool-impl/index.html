<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/howl.png">
    <link rel="icon" type="image/png" href="/howl.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Is Life Always This Hard? / After all this time?">
    <meta name="author" content="aptend">
    <meta name="keywords" content>
    <title>Rust线程池源码拆解及实现 ~ No one</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/github.min.css">
    
    <link rel="stylesheet" href="/css/github-markdown.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>No one</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">Rust线程池源码拆解及实现</p>
            <br>
            
            <p>Saturday, February 1st 2020, 10:49 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="markdown-body post-content py-5 z-depth-3 main">
                <p>看了rust的threadpool crate，照虎画猫！</p>
<a id="more"></a>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>基本模型是，存在一个任务channel，发送头在<code>ThreadPool</code>里，通过<code>execute</code>方法发送任务闭包，已初始化的若干个工作线程一直处在loop里，行为是从任务通道里取任务，执行，取任务……这样循环。因为有loop，所以线程就一直没退出，免去了回收、再创建的消耗。</p>
<p><img src="https://s2.ax1x.com/2020/02/01/1JFENj.png" alt="threadpool.png"></p>
<p>任务闭包签名为<code>FnOnce() + Send + &#39;static</code>，没有参数，没有返回值，所以需要对真实的调用函数做适配，捕获参数，构造闭包，如果有返回值就直接用共享的变量收集，比如下面这样，每个任务是产生输入参数的平方数，结果收集到<code>Vec</code>里</p>
<pre><code class="rust">fn do_something(i: usize) -&gt; usize {
    thread::sleep(Duration::from_micros(50 * i as u64));
    i * i
}

fn main() {
    let pool = ThreadPool::new(4);
    let ans = Arc::new(Mutex::new(Vec::&lt;usize&gt;::new()));
    for i in 0..10 {
        let ans = ans.clone();
        let job = move || {
            let result = do_something(i);
            (*ans.lock().unwrap()).push(result);
        };
        pool.execute(job)
    }
    pool.join();
    assert_eq!(285usize, (*ans.lock().unwrap()).iter().sum());
}
</code></pre>
<h2 id="搭建骨架"><a href="#搭建骨架" class="headerlink" title="搭建骨架"></a>搭建骨架</h2><p>任务闭包用Box装箱来传指针，动态查找虽然有性能损耗，但是闭包结构的复制消耗也相对固定，免得有个什么大闭包结构被莫名复制到线程栈上。</p>
<pre><code class="rust">type Job = Box&lt;dyn FnOnce() + Send + &#39;static&gt;;
</code></pre>
<p>初始化一个工作线程，就是把一个channel的接收端加锁，传给线程，同步地从channel中拿出任务来执行。<code>Mutex</code>加锁，<code>Arc</code>创建共享所有权。</p>
<pre><code class="rust">fn spawn_in_pool(receiver: Arc&lt;Mutex&lt;Receiver&lt;Job&gt;&gt;&gt;) {
    thread::spawn(move || loop {
        let recv_result = {
            // 以最少时间占用锁
            receiver.lock().expect(&quot;can&#39;t lock channel receiver&quot;).recv()
        };

        let job_fn = match recv_result {
            Ok(job) =&gt; job,
            Err(_) =&gt; break, // 这个错误说明另一端已经drop，退出该线程就可以
        };
        job_fn();
    });
}
</code></pre>
<p><code>ThreadPool</code>现在只要一个channel的传输入口，用于任务发送。</p>
<pre><code class="rust">struct ThreadPool {
    sender: Sender&lt;Job&gt;,
}

impl ThreadPool {
    ...
    fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + &#39;static,
    {
        self.sender.send(Box::new(f)).unwrap();
    }
    ...    
}
</code></pre>
<p>初始化工作自然就是要建立起任务channel，然后调用<code>spawn_in_pool</code>，初始化要求个数的工作线程</p>
<pre><code class="rust">impl ThreadPool {
    fn new(threads_num: usize) -&gt; ThreadPool {
        let (tx, rx) = channel::&lt;Job&gt;(); // 建channel
        let receiver = Arc::new(Mutex::new(rx)); // 初始化工作线程
        for _ in 0..threads_num {
            let receiver = receiver.clone();
            spawn_in_pool(receiver);
        }
        ThreadPool { sender: tx }  // 返回pool
    }
}
</code></pre>
<p><code>join</code>作用就等待工作线程完成全部任务，这个事情下阶段来做，这里先随便<code>sleep</code>替代一下，能通过测试用例就可以。</p>
<pre><code class="rust">impl ThreadPool {
    fn join(&amp;self) {
        println!(&quot;waiting...&quot;);
        thread::sleep(Duration::from_secs(2));
    }
}
</code></pre>
<p>很好，测试通过！🎉🎉🎉🎉线程池写完了！膨胀得先去吃个烧烤庆祝一下！</p>
<h2 id="正确地join"><a href="#正确地join" class="headerlink" title="正确地join"></a>正确地join</h2><p>什么时候说明任务执行完了？</p>
<ul>
<li>任务队列任务计数为0，记为<code>queue_cnt == 0</code></li>
<li>没有正在执行任务的线程，记为<code>active_cnt == 0</code></li>
</ul>
<p>所以我们需要共享这两个变量给所有工作线程。工作线程取出一个任务，<code>queue_cnt -= 1</code>，执行任务前<code>active_cnt += 1</code>，完成后<code>active_cnt -= 1</code>。显然<code>ThreadPool</code>也需要共享这两个变量，<code>execute</code>时<code>queue_cnt += 1</code>。</p>
<p><code>join</code>时，可以简单粗暴地轮询这些两个变量判断。但是这种通知的同步场景，使用条件变量来挂起等待线程，有事件时重启线程更高效。</p>
<p>谁在等待？<code>join</code>方法，使用条件变量的<code>wait</code>挂起线程，等待事件发生。</p>
<p>谁来通知？工作线程，当完成一个任务后，检查任务是否全部完成，如果是，就<code>notify_all</code>（因为<code>ThreadPool</code>也可以在多个线程里并发地发送任务）。</p>
<p>所以现在要共享的变量又多了4个，只能单独写一个结构来封装他们，然后共享给工作线程。对于<code>queue_cnt</code>，<code>active_cnt</code>这种基本类型，有<code>AtomicXxx</code>等原子类型供选择，但是内存顺序暂时还没看懂，先用<code>Mutex</code>代替吧，性能低点就低。为了方便，直接把判断和通知的方法实现在这个<code>SharedData</code>里。</p>
<p>条件变量和互斥锁配套使用，互斥锁的基本作用是，对条件变量的操作，无论是<code>wait</code>、<code>notify_*</code>，都是互斥进行的，保证条件变量在增加、移除暂停线程时的安全性，另外互斥锁本身也可以携带信息，作为条件判断的对象。但是这个里的<code>cond_guard</code>只起第一个作用，条件的判断由<code>queue_cnt</code>和<code>active_cnt</code>承担。</p>
<pre><code class="rust">struct SharedData {
    receiver: Mutex&lt;Receiver&lt;Job&gt;&gt;,
    queue_cnt: Mutex&lt;usize&gt;,
    active_cnt: Mutex&lt;usize&gt;,
    cond_guard: Mutex&lt;()&gt;,
    cond: Condvar,
}

impl SharedData {
    fn has_task(&amp;self) -&gt; bool {
        *self.queue_cnt.lock().expect(&quot;can&#39;t lock queue_cnt&quot;) &gt; 0
            || *self.active_cnt.lock().expect(&quot;can&#39;t lock active_cnt&quot;) &gt; 0
    }

    fn notify_when_no_tasks(&amp;self) {
        if !self.has_task() {
            *self.cond_guard.lock().expect(&quot;can&#39;t lock cond_guard&quot;);
            self.cond.notify_all(); // 独占地通知
        }
    }
}
</code></pre>
<p>接下来就是围绕这个新的中间结构，改造之前的骨架就可以，比如<code>spawn_in_pool</code>的要改签名，增加变量维护的逻辑。</p>
<pre><code class="rust">fn spawn_in_pool(data: Arc&lt;SharedData&gt;) {
    // ...取出任务
    {
         *data.queue_cnt.lock().expect(&quot;can&#39;t lock queue_cnt&quot;) -= 1;
    }
    {
        *data.active_cnt.lock().expect(&quot;can&#39;t lock queue_cnt&quot;) += 1;
    }
    job_fn();
    {
        *data.active_cnt.lock().expect(&quot;can&#39;t lock queue_cnt&quot;) -= 1;
    }

    data.notify_when_no_tasks();
}
</code></pre>
<p><code>ThreadPool</code>本身也多了一个<code>data</code>字段，方便<code>join</code>、<code>execute</code>时使用</p>
<pre><code class="rust">struct ThreadPool {
    sender: Sender&lt;Job&gt;,
    data: Arc&lt;SharedData&gt;,
}

impl ThreadPool {
    fn new(threads_num: usize) -&gt; ThreadPool {
        let (tx, rx) = channel::&lt;Job&gt;();
        let data = Arc::new(SharedData {
            receiver: Mutex::new(rx),
            queue_cnt: Mutex::new(0),
            active_cnt: Mutex::new(0),
            cond_guard: Mutex::new(()),
            cond: Condvar::new(),
        });

        for _ in 0..threads_num {
            let data = data.clone();
            spawn_in_pool(data);
        }
        ThreadPool {
            sender: tx,
            data: data,
        }
    }

    fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + &#39;static,
    {
        {
            *self.data.queue_cnt.lock().expect(&quot;can&#39;t lock queue_cnt&quot;) += 1;
        }
        self.sender.send(Box::new(f)).unwrap();
    }

    fn join(&amp;self) {
        if !self.data.has_task() { // 一个小优化，有机会避免一次cond_guard的加锁
            return;
        }
        let mut guard = self.data.cond_guard.lock().expect(&quot;can&#39;t lock cond guard&quot;);
        while self.data.has_task() {
            guard = self.data.cond.wait(guard).unwrap();
        }
    }
}
</code></pre>
<p>🐮🍺，测试通过！🎉🎉🎉🎉阶段性成果！成功完成了正常工作的<code>join</code></p>
<h2 id="动态设置工作线程数"><a href="#动态设置工作线程数" class="headerlink" title="动态设置工作线程数"></a>动态设置工作线程数</h2><p>线程池创建之后，如果想要动态增加或者减少线程数量可咋搞？分两种情况来考虑。</p>
<ol>
<li>工作线程数增加，差多少个，就调用多少次<code>spawn_in_pool</code>，补齐差距。</li>
<li>工作线程减少，那就要让一些工作线程自动地break，退出后自动被回收。怎么让这些多余的线程知道自己被下岗了呢？现在正在执行任务的线程不能动，那些执行完，再次循环去工作队列里拿任务前，就可以检查多少线程正在工作<code>active_cnt</code>，如果大于设定的最大工作线程数，那么自己就主动退出。</li>
</ol>
<p>所以思路就是</p>
<ul>
<li>在<code>SharedData</code>里增加一个<code>max_threads_cnt</code>字段；</li>
<li>给<code>ThreadPool</code>实现<code>set_threads_num</code>方法，如果是增加，就调用<code>spawn_in_pool</code>补齐；</li>
<li>工作线程的每次取任务前都检查一下<code>active_cnt</code>是否大于<code>max_threads_cnt</code>，是就break；</li>
</ul>
<p>后两点变动的代码是</p>
<pre><code class="rust">impl ThreadPool {
    // ...
    fn set_threads_num(&amp;self, size: usize) {
        let mut prev_cnt = size;
        {
            let mut p_thread_cnt = self
                .data
                .max_threads_cnt
                .lock()
                .expect(&quot;can&#39;t lock max_threads_cnt&quot;);
            prev_cnt = *p_thread_cnt;
            *p_thread_cnt = size;
        }
        if let Some(n) = size.checked_sub(prev_cnt) {
            for _ in 0..n {
                let data = self.data.clone();
                spawn_in_pool(data);
            }
        }
    }
}


fn spawn_in_pool(data: Arc&lt;SharedData&gt;) {
    {
        if *data.active_cnt.lock().unwrap() &gt;= *data.max_threads_cnt.lock().unwrap() {
            break
        }
    }
    // ...取出任务
}
</code></pre>
<h2 id="工作线程panic怎么办"><a href="#工作线程panic怎么办" class="headerlink" title="工作线程panic怎么办"></a>工作线程panic怎么办</h2><p>如果任务闭包<code>job_fn</code>执行产生了panic，那么会产生什么影响？首先是线程退出</p>
<ul>
<li>线程退出，工作线程不等于当初设定的线程数</li>
<li><code>job_fn</code>后面的代码没有执行：<code>active_cnt</code>没有减一、没有通知<code>join</code></li>
</ul>
<p>所以因panic退出时，得执行被跳过的逻辑，并且重启线程。</p>
<p>panic退出时还要执行代码？这咋办呢，只能是某个结构实现<code>Drop</code>trait，在<code>drop</code>方法中执行没有执行完的逻辑。下面是源码中<code>Sentinel</code>哨兵的实现。</p>
<pre><code class="rust">impl&lt;&#39;a&gt; Sentinel&lt;&#39;a&gt; {
    // 在工作线程进入loop前，new一个新鲜的sentinel
    fn new(shared_data: &amp;&#39;a Arc&lt;ThreadPoolSharedData&gt;) -&gt; Sentinel&lt;&#39;a&gt; {
        Sentinel {
            shared_data: shared_data,
            active: true,
        }
    }

    /// loop正常break出来，执行cancel.
    fn cancel(mut self) {
        self.active = false;
    }
}

impl&lt;&#39;a&gt; Drop for Sentinel&lt;&#39;a&gt; {
    fn drop(&amp;mut self) {
        if self.active { // 说明不是break正常退出
            self.shared_data.active_count.fetch_sub(1, Ordering::SeqCst);
            if thread::panicking() { 
                self.shared_data.panic_count.fetch_add(1, Ordering::SeqCst);
            }
            self.shared_data.no_work_notify_all();
            spawn_in_pool(self.shared_data.clone())
        }
    }
}
</code></pre>
<p>然后我的疑问是：为什么会有哨兵的<code>active</code>字段和<code>thread::panicking()</code>的双重检查？非正常退出除了panic还有其他的情况？如果是其他情况，为什么进入active分支后直接对<code>active_cnt</code>进行减1操作，这个操作的潜在假设是逻辑流一定中止于闭包调用呀，那么除了<code>job_fn</code>本身panic，还能有什么可能满足这个假设呢？我还试过了，源代码实现中，如果获取获取工作队列锁失败，<code>expect</code>产生的panic也会进入<code>drop</code>方法，造成<code>active_count</code>减1后溢出，行为完全失控。</p>
<p>我个人看法，正确的解决办法，应该是<code>drop</code>只应对一种情况，就是任务闭包panic，这是唯一不可控的代码，其他情况如果出现error，就地处理，比如工作队列获取锁，如果失败，标记sentinel的<code>drop</code>不要处理，主动<code>spand_in_pool</code>挽救。像我这里没有使用<code>AtomicXxx</code>，获取状态字段时出错，那么就是严重的运行时问题，已经无法维持线程池的正确状态，也是标记<code>drop</code>不要处理，同时标记线程池停止工作，抛出panic。</p>
<h2 id="还有什么可以做的吗？"><a href="#还有什么可以做的吗？" class="headerlink" title="还有什么可以做的吗？"></a>还有什么可以做的吗？</h2><ul>
<li>现在异常只会计数，是不是可以给每个任务增加名字，join之后可以重新执行失败的任务？</li>
<li>任务超时怎么办？<code>ThreadPool</code>结构就得主动杀死线程，所以还得共享一个&lt;线程id-状态&gt;的映射？</li>
<li>把工作队列的性质也做成初始化参数？用户可以选择使用有界队列和无界队列？</li>
<li>工作线程panic的问题，还待确认解决方案。</li>
<li>源代码中的<code>test_threads_num_decreasing</code>测试用例有误，第二次<code>execute</code>的数量应该多于<code>new_threads_num</code></li>
</ul>
<p>OK，线程池的源码解析就到这里吧，挺有收获的</p>
<ol>
<li>终于明白了线程池的模型，原来是队列+多个loop线程👏</li>
<li>熟悉了rust中的线程同步工具。算是对<a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html" target="_blank" rel="noopener"><code>Unique+Share</code></a>角度的复习，这个角度思考真的非常有用！<code>Arc</code>、<code>Mutex</code>啥的看得更清楚了。</li>
</ol>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Rust</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <!-- <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p>  -->
    <div id="tocbot"></div>
  </div>


        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>

  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
<script src="/js/main.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>

<script src="/js/post.js"></script>

<script src="/js/plugins/prettify.js"></script>
<script>
  $(document).ready(function () {
    $('pre').addClass('prettyprint');
    prettyPrint();
  })
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>